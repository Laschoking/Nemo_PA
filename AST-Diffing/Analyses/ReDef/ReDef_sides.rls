% currently takes 1 CFG file, with separated sides 
@import IfCondition[string,integer,integer]: csv{resource="IfCondition.csv"}.
@import WhileCondition[string,integer,integer]: csv{resource="WhileCondition.csv"}.
@import CFG[string, integer,integer]: csv{resource = "CFG.csv"}.
@import CFGRoot[string,string,string,integer]: csv{resource = "CFGRoot.csv"}.
@import BBMethodHead[string,string,string,integer]: csv{resource = "BBMethodHead.csv"}.
@import LookupBB[string,integer,integer]: csv{resource = "LookupBB.csv"}.
@import ASTBB[string,integer,integer,string,string,string,integer]: csv{resource = "ASTBB.csv"}.
@import Iter[integer,integer]: csv{resource= "Iter.csv"}.
@import NextLineBB[string,integer,integer,integer] : csv{resource= "NextLineBB.csv"}.
@import LastStmtBB[string,integer,integer] :csv{resource= "LastStmtBB.csv"}.
@declare EnvironmentUse(string,integer,string,string).
@declare DefUse(string, integer,integer,string,integer,string).
% in which statements is variable V used, before redeclaration?

% find all declarations (Def)
% follow BB-Flow for Use 

% VariablenDeklaration (int a;)
% assume that "VariableDeclarator" is the child of "VarDeclStmt"
Decl(?side,?BB,?nr,?var):-
    ASTBB(?side,?BB,?nr,"VariableDeclarator",?var,_,_).

% only if a declared variable has further statements in "Opt" it is also DEFINED
% if "Opt" is not empty expressions, constants etc. are assigned there
Def(?side,?BB,?decNr,?var):-
    Decl(?side,?BB,?decNr,?var),
    ASTBB(?side,?BB,?optNr,"Opt",_,_,?decNr),
    ASTBB(?side,?BB,_,_,_,_,?optNr).

% VariableAssignment if variable is declared already:
% (a = b) has 2 entries of "VarAccess" after the "VariableAssignment" (first is "a", second "b") 
% (a = b+c;) creates a subtree "AddExpr" as second child 
FirstVarAccess(?side,?nr, #min(?nr2)):-
    ASTBB(?side,?BB,?nr,"AssignSimpleExpr",_,_,_),
    ASTBB(?side,?BB,?nr2,"VarAccess",_,_,?nr).

% First child is being defined
Def(?side,?BB,?nr,?var):-
    FirstVarAccess(?side,_,?nr),
    ASTBB(?side,?BB,?nr,_,?var,_,_).

% -------------------------------------------- %
% detect Uses that are not by assignement (a=b;)
Comp("GTExpr").
Comp("GEExpr").
Comp("EQExpr").
Comp("LTExpr").
Comp("LEExpr").
Comp("NEExpr").

% Logische Operatoren kommen eh nur nach If-Stmt
Comp("LogNotExpr").
Comp("AndLogicalExpr").
Comp("OrLogicalExpr").

% In most cases, a binary operator is parent of the "VarAccess"

EnvironmentUse(?side,?nrVar,?var,?op):-
    Comp(?op),
    ASTBB(?side,_, ?nrOp,?op,_,_,_),
    ASTBB(?side,_,?nrVar,"VarAccess",?var,_,?nrOp).

% But sometimes not i.e. if(a){} ->
% Those cases need to be checked for each structure (if,while, return a; meth(a); )...

% If (a)
EnvironmentUse(?side,?ifCond,?var,"ifCond"):-
    IfCondition(?side,_,?ifCond),
    ASTBB(?side,_,?ifCond,"VarAccess",?var,_,_).

% while(a)
EnvironmentUse(?side,?whileCond,?var, "whileCond"):-
    WhileCondition(?side,_, ?whileCond),
    ASTBB(?side,_,?whileCond,"VarAccess",?var,_,_).

% -------------------------------------------- %

% detect Uses through assignment (a = b;)

PossUse(?side,?BB,?defNr,?useNr,?type,?var):-
    FirstVarAccess(?side,?parNr, ?defNr),
    ASTBB(?side,?BB,?useNr,?type ,?var,_,?parNr),
    ?useNr > ?defNr.


% Find all Sub-Tree nodes of a Variable Declarator
% even if they are just placeholders
PossUse(?side,?BB,?defNr,?useNr,?type,?id):-
    Def(?side,?BB,?defNr,?var),
    ASTBB(?side,?BB,?useNr,?type,?id,_,?defNr).

%transitive closure
PossUse(?side,?BB,?defNr,?useNr2,?type,?id):-
    PossUse(?side,?BB,?defNr,?useNr1,_,_),
    ASTBB(?side,?BB,?useNr2,?type,?id,_,?useNr1).

% Extract use-Variables that have a "VarAccess"
Use(?side,?BB,?defNr,?defVar,?useNr,?useVar):-
    PossUse(?side,?BB,?defNr,?useNr,"VarAccess",?useVar),
    Def(?side,?BB,?defNr,?defVar).

% -------------------------------------------- %


% Propagate Variables through Tree (full mode)

% variables get active once we leave their subtree
% first find parent node (AssignSimpleExpr) and then take all children as subtree
TraverseSubtree(?side,?BB,?var,?defNr,?nr):-
    ASTBB(?side, ?BB, ?defNr,_,_,_,?parNr),
    Def(?side,?BB,?defNr,?var),
    ASTBB(?side,?BB,?nr,_,_,_,?parNr).

TraverseSubtree(?side,?BB,?var,?defNr,?nr2):-
    TraverseSubtree(?side,?BB,?var,?defNr,?nr1),
    ASTBB(?side,?BB,?nr2,_,_,_,?nr1).

LastStmtInDef(?side,?BB,?var,?defNr,#max(?nr)):-
    TraverseSubtree(?side,?BB,?var,?defNr,?nr).

% Initialise relation
% Variable becomes active AFTER its assignment in BB
VarActive(?side,?BB,?defNr,?var, ?nextStmt):-
    Def(?side,?BB,?defNr,?var),
    LastStmtInDef(?side,?BB,?var,?defNr,?lastStmt),
    NextLineBB(?side,?BB,?lastStmt, ?nextStmt).

% if var-Assignment was last stmt in BB -> propagate VarActivity further
VarActive(?side,?BB2,?defNr,?var, ?BB2):-
    Def(?side,?BB1,?defNr,?var),
    LastStmtInDef(?side,?BB1,?var,?defNr,?lastStmt),
    CFG(?side,?BB1,?BB2).

% Copy live-variables from predecessor if the variable is not re-defined
VarActive(?side,?BB,?defNr,?var,?nr2):-
    VarActive(?side,?BB,?defNr,?var,?nr1),
    NextLineBB(?side,?BB,?nr1,?nr2),
    ~LastStmtInDef(?side,?BB,?var,_,?nr2).

% TODO rethink the lower part & fuse results
% Detect redefinition i.e. (a = 1; b = a; a = 2; c = a;) 
RedefineVar(?side,?BB,?defNr,?var,?nr2):-
    VarActive(?side,?BB,?defNr,?var,?nr1),
    NextLineBB(?side,?BB,?nr1,?nr2),
    Def(?side,?BB,?nr2,?var).

% propagate live-variables across BBs
VarActive(?side,?BB2,?defNr,?var,?BB2):-
    VarActive(?side,?BB1,?defNr,?var,?nr),
    LastStmtBB(?side,?BB1,?nr),
    CFG(?side,?BB1,?BB2).

%
DefUse(?side,?BB,?defNr,?var,?newDefNr,?newDefVar):-
    VarActive(?side,?BB1,?defNr,?var,?useNr),
    Use(?side,?BB,?newDefNr,?newDefVar,?useNr,?var). 

DefUse(?side,?BB1,?defNr,?var,?useNr,?cond):-
    EnvironmentUse(?side,?useNr,?var,?cond),
    VarActive(?side,?BB1,?defNr,?var,?useNr).

SpecialReassignment(?side,?BB,?newDefNr, ?var, ?useNr):-
    Use(?side, ?BB, ?newDefNr,?var,?useNr,?var).




@output TraverseSubtree.
@output LastStmtInDef.
@output SpecialReassignment.
@output VarActive.
%@output TraverseSubtree.
@output Def.
@output RedefineVar.
@output Use.
@output DefUse.
@output EnvironmentUse.
