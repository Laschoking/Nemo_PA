// This program transforms the normal facts into an extended version (pre-computing)
// It is used f.e. by the Control Flow Analysis
// does not include the basic parts for Pointer-Analysis


.decl ActualParam(?index:number, ?invocation:symbol, ?var:symbol)
.decl AllocatedObjectSupportsFinalize(?heap:symbol, ?inmethod:symbol)
.decl AnnotationElement(?annotationKind:symbol, ?element:symbol, ?parentId:symbol, ?id:symbol, ?name:symbol, ?value1:symbol, ?value2:symbol)
.decl AnyMainMethodDeclaration(?symbol:symbol, ?type:symbol)
.decl ApplicationAllocation(?allocation:symbol)
.decl ApplicationClass(?ref:symbol)

.decl ArrayNumIndex(?insn:symbol, ?index:number)
.decl _ArrayNumIndex(?instruction:symbol, ?index:number)
.decl _ArrayType(?arrayType:symbol)
.decl _AssignBinop(?instruction:symbol, ?index:number, ?to:symbol, ?inmethod:symbol)
.decl AssignCast_From(?insn:symbol, ?from:symbol)
.decl _AssignCast(?instruction:symbol, ?index:number, ?from:symbol, ?to:symbol, ?type:symbol, ?inmethod:symbol)
.decl _AssignCastNull(?instruction:symbol, ?index:number, ?to:symbol, ?type:symbol, ?symbol:symbol)
.decl AssignCastNumConstant_Id(?insn:symbol, ?const:symbol)
.decl _AssignCastNumConstant(?instruction:symbol, ?index:number, ?const:symbol, ?to:symbol, ?type:symbol, ?inmethod:symbol)
.decl AssignCast_Type(?insn:symbol, ?type:symbol)
.decl AssignCast(?type:symbol, ?from:symbol, ?to:symbol, ?inmethod:symbol)
.decl AssignHeapAllocation_Heap(?insn:symbol, ?heap:symbol)
.decl AssignHeapAllocation(?heap:symbol, ?to:symbol, ?inmethod:symbol)
.decl _AssignHeapAllocation(?instruction:symbol, ?index:number, ?heap:symbol, ?to:symbol, ?inmethod:symbol, ?linenumber:number)
.decl AssignInstanceOf_From(?insn:symbol, ?from:symbol)
.decl _AssignInstanceOf(?instruction:symbol, ?index:number, ?from:symbol, ?to:symbol, ?type:symbol, ?inmethod:symbol)
.decl AssignInstanceOf_Type(?insn:symbol, ?type:symbol)
.decl AssignInstruction_To(?insn:symbol, ?to:symbol)
.decl AssignLocal_From(?insn:symbol, ?from:symbol)
.decl AssignLocal(?from:symbol, ?to:symbol, ?inmethod:symbol)
.decl _AssignLocal(?instruction:symbol, ?index:number, ?from:symbol, ?to:symbol, ?inmethod:symbol)
.decl _AssignNull(?instruction:symbol, ?index:number, ?to:symbol, ?symbol:symbol)
.decl AssignNull(?to:symbol, ?inmethod:symbol)
.decl AssignNumConstant_Id(?insn:symbol, ?const:symbol)
.decl _AssignNumConstant(?instruction:symbol, ?index:number, ?const:symbol, ?to:symbol, ?inmethod:symbol)
.decl AssignOper_FromConstant(?insn:symbol, ?pos: number, ?fro:number)
.decl _AssignOperFromConstant(?instruction:symbol, ?pos: number, ?fro:number)
.decl AssignOper_From(?insn:symbol, ?pos:number, ?from:symbol)
.decl _AssignOperFrom(?instruction:symbol, ?pos: number, ?from:symbol)
.decl _AssignPhantomInvoke(?instruction:symbol, ?index:number, ?symbol:symbol)
.decl _AssignReturnValue(?invocation:symbol, ?to:symbol)
.decl AssignReturnValue(?invocation:symbol, ?to:symbol)
.decl _AssignUnop(?instruction:symbol, ?index:number, ?to:symbol, ?inmethod:symbol)
.decl BBHeadInMethod(?insn:symbol, ?symbol:symbol)
.decl _BootstrapParam(?index:number, ?invocation:symbol, ?var:symbol)
.decl BootstrapParam(?index:number, ?invocation:symbol, ?var:symbol)
.decl _BreakpointStmt(?instruction:symbol, ?index:number, ?symbol:symbol)
.decl _BridgeMethod(?bridge:symbol, ?name:symbol, ?type:symbol)
.decl CFGRoot(?insn:symbol, ?symbol:symbol)
.decl _ClassArtifact(?artifact:symbol, ?className:symbol, ?subArtifact:symbol, ?size:number)
.decl ClassConstructor(?symbol:symbol, ?type:symbol)
.decl _ClassHeap(?id:symbol, ?instanceType:symbol)
.decl ClassHeap_InstanceType(?classHeap:symbol, ?instanceType:symbol)
.decl Class_InterestingSubtype(?class:symbol, ?subClass:symbol)
.decl _ClassModifier(?modifier:symbol, ?class:symbol)
.decl ClassModifier(?mod:symbol, ?class:symbol)
.decl _ClassType(?class:symbol)
.decl _ComponentType(?arrayType:symbol, ?componentType:symbol)
.decl ComponentType(?arrayType:symbol, ?componentType:symbol)
.decl ConcreteClass(?ref:symbol)
.decl ConcreteMethodDeclared(?meth:symbol, ?class:symbol)
.decl DirectSubclass(?a:symbol, ?c:symbol)
.decl _DirectSuperclass(?class:symbol, ?superclass:symbol)
.decl DirectSuperclass(?class:symbol, ?superclass:symbol)
.decl _DirectSuperinterface(?class:symbol, ?interface:symbol)
.decl DirectSuperinterface(?ref:symbol, ?interface:symbol)
.decl DummyIf_Var(?insn:symbol, ?Var:symbol)
.decl _DummyIfVar(?instruction:symbol, ?var:symbol)
.decl DynamicMethodInvocation_Bootstrap(?invocation:symbol, ?bootSignature:symbol)
.decl DynamicMethodInvocation_DynArity(?invocation:symbol, ?dynArity:number)
.decl DynamicMethodInvocation_DynName(?invocation:symbol, ?dynName:symbol)
.decl _DynamicMethodInvocation_DynParamType(?invocation:symbol, ?idx:number, ?pType:symbol)
.decl DynamicMethodInvocation_DynParamTypes(?invocation:symbol, ?dynParamTypes:symbol)
.decl DynamicMethodInvocation_DynReturnType(?invocation:symbol, ?dynRetType:symbol)
.decl DynamicMethodInvocation_HandleTag(?instruction:symbol, ?tag:number)
.decl _DynamicMethodInvocation(?instruction:symbol, ?index:number, ?bootSignature:symbol, ?dynName:symbol, ?dynRetType:symbol, ?dynArity:number, ?dynParamTypes:symbol, ?tag:number, ?symbol:symbol)
.decl _EmptyArray(?id:symbol)
.decl _EnterMonitor(?instruction:symbol, ?index:number, ?var:symbol, ?symbol:symbol)
.decl EnterMonitor_Var(?insn:symbol, ?var:symbol)
.decl ExceptionHandler_Before(?before:symbol, ?handler:symbol)
.decl ExceptionHandler_Begin(?handler:symbol, ?index:number)
.decl ExceptionHandler_End(?handler:symbol, ?index:number)
.decl ExceptionHandler_FormalParam(?handler:symbol, ?var:symbol)
.decl _ExceptionHandler(?handler:symbol, ?symbol:symbol, ?index:number, ?type:symbol, ?begin:number, ?end:number)
.decl ExceptionHandler_Impossible(?type:symbol, ?h2:symbol, ?insn:symbol)
.decl ExceptionHandler_Index(?handler:symbol, ?index:number)
.decl ExceptionHandler_InRange(?handler:symbol, ?instruction:symbol)
.decl ExceptionHandler_Method(?handler:symbol, ?inmethod:symbol)
.decl _ExceptionHandler_Previous(?handler:symbol, ?previous:symbol)
.decl ExceptionHandler_Previous(?handler:symbol, ?previous:symbol)
.decl ExceptionHandler_SameBlock_PartialOrder(?repr:symbol, ?handler:symbol)
.decl ExceptionHandler_SameBlock_Repr(?handler:symbol, ?repr:symbol)
.decl ExceptionHandler_SameInsn_PartialOrder(?h1:symbol, ?h2:symbol, ?insn:symbol)
.decl ExceptionHandler_SameInsn_Repr(?insn:symbol, ?repr:symbol)
.decl ExceptionHandler_Type(?handler:symbol, ?type:symbol)
.decl ExceptionHandler_TypeIsCaught(?type:symbol, ?block:symbol)
.decl ExercisedEntryPointMethod(?class:symbol, ?symbol:symbol)
.decl _ExitMonitor(?instruction:symbol, ?index:number, ?var:symbol, ?symbol:symbol)
.decl ExitMonitor_Var(?insn:symbol, ?var:symbol)
.decl Field_Annotation(?fld:symbol, ?annotation:symbol)
.decl Field_DeclaringType(?field:symbol, ?declaringClass:symbol)
.decl FieldInstruction_Signature(?insn:symbol, ?sign:symbol)
.decl _Field_Modifier(?modifier:symbol, ?field:symbol)
.decl Field_Modifier(?mod:symbol, ?field:symbol)
.decl _Field(?signature:symbol, ?declaringClass:symbol, ?simplename:symbol, ?type:symbol)
.decl Field_SimpleName(?field:symbol, ?simpleName:symbol)
.decl Field_Type(?field:symbol, ?type:symbol)
.decl _FormalParam(?index:number, ?symbol:symbol, ?var:symbol)
.decl FormalParam(?index:number, ?symbol:symbol, ?var:symbol)
.decl _Goto(?instruction:symbol, ?index:number, ?to:number, ?symbol:symbol)
.decl Goto_Target(?insn:symbol, ?index:number)
.decl HeapAllocation_EmptyArray(?heap:symbol)
.decl HeapAllocation_Null(?null:symbol)
.decl HeapAllocation_Type(?heap:symbol, ?type:symbol)
.decl If_Constant(?insn:symbol, ?pos: number, ?cons:number)
.decl _IfConstant(?instruction:symbol, ?pos:number, ?con:number)
.decl _If(?instruction:symbol, ?index:number, ?to:number, ?symbol:symbol)
.decl If_Target(?insn:symbol, ?index:number)
.decl If_Var(?insn:symbol, ?pos:number, ?var:symbol)
.decl _IfVar(?instruction:symbol, ?pos:number, ?var:symbol)
.decl Instruction_Index(?insn:symbol, ?index:number)
.decl Instruction_Line(?insn:symbol, ?index:number)
.decl Instruction_Method(?insn:symbol, ?inMethod:symbol)
.decl _InterfaceType(?interface:symbol)
.decl isAnnotation(?a:symbol)
.decl isArrayInstruction(?insn:symbol)
.decl isArrayType(?t:symbol)
.decl isAssignBinop_Insn(?insn:symbol)
.decl isAssignCast_Insn(?insn:symbol)
.decl isAssignCastNull_Insn(?insn:symbol)
.decl isAssignCastNumConstant_Insn(?insn:symbol)
.decl isAssignHeapAllocation_Insn(?insn:symbol)
.decl isAssignInstanceOf_Insn(?insn:symbol)
.decl isAssignInstruction(?insn:symbol)
.decl isAssignLocal_Insn(?insn:symbol)
.decl isAssignNull_Insn(?insn:symbol)
.decl isAssignNumConstant_Insn(?insn:symbol)
.decl isAssignOper_Insn(?insn:symbol)
.decl isAssignPhantomInvoke(?insn:symbol)
.decl isAssignUnop_Insn(?insn:symbol)
.decl isBreakpointStmt(?insn:symbol)
.decl isClassHeap(?h:symbol)
.decl isClassType(?t:symbol)
.decl isDynamicMethodInvocation_Insn(?insn:symbol)
.decl isEnterMonitor_Insn(?insn:symbol)
.decl isExceptionHandler(?handler:symbol)
.decl isExitMonitor_Insn(?insn:symbol)
.decl isField(?field:symbol)
.decl isFieldInstruction(?insn:symbol)
.decl isGoto_Insn(?insn:symbol)
.decl isHeapAllocation(?h:symbol)
.decl isIf_Insn(?insn:symbol)
.decl isInstruction(?insn:symbol)
.decl isIntegerType(?type:symbol)
.decl isInterfaceType(?t:symbol)
.decl isJVMDescriptor(?jvmd:symbol)
.decl isLoadArrayIndex_Insn(?insn:symbol)
.decl isLoadInstanceField_Insn(?insn:symbol)
.decl isLoadStaticField_Insn(?insn:symbol)
.decl isLookupSwitch_Insn(?insn:symbol)
.decl isMethodDescriptor(?md:symbol)
.decl isMethodHandleConstant(?h:symbol)
.decl isMethodInvocation(?insn:symbol)
.decl isMethod(?m:symbol)
.decl isMethodTypeConstant(?h:symbol)
.decl isModifier(?m:symbol)
.decl isMonitorInstruction(?insn:symbol)
.decl isNormalHeap(?h:symbol)
.decl isNullType(?t:symbol)
.decl isNumConstant(?n:symbol)
.decl isOpaqueInstruction(?insn:symbol)
.decl isOpaqueMethod(?m:symbol)
.decl isPrimitiveType(?t:symbol)
.decl isReferenceType(?t:symbol)
.decl isReturnInstruction(?insn:symbol)
.decl isReturnNonvoid_Insn(?insn:symbol)
.decl isReturnVoid_Insn(?insn:symbol)
.decl isSpecialMethodInvocation_Insn(?insn:symbol)
.decl isStaticMethodInvocation_Insn(?insn:symbol)
.decl isStoreArrayIndex_Insn(?insn:symbol)
.decl isStoreInstanceField_Insn(?insn:symbol)
.decl isStoreStaticField_Insn(?insn:symbol)
.decl isStringConstant(?h:symbol)
.decl isStringRaw(?id:symbol)
.decl isSuperMethodInvocation_Insn(?insn:symbol)
.decl isSwitch_Insn(?insn:symbol)
.decl isTableSwitch_Insn(?insn:symbol)
.decl isThrow_Insn(?insn:symbol)
.decl isThrowNull_Insn(?insn:symbol)
.decl isType(?t:symbol)
.decl isUnsupportedInstruction(?insn:symbol)
.decl isVar(v:symbol)
.decl isVirtualMethodInvocation_Insn(?insn:symbol)
.decl JNIMethod_NativeId(?javaMethod:symbol, ?nativeId:symbol)
.decl KeepClass(?c:symbol)
.decl KeepClassesWithMembers(?m:symbol)
.decl KeepClassMembers(?m:symbol)
.decl KeepMethod(?m:symbol)
.decl LoadArrayIndex_Base(?insn:symbol, ?var:symbol)
.decl LoadArrayIndex(?base:symbol, ?to:symbol, ?inmethod:symbol)
.decl _LoadArrayIndex(?instruction:symbol, ?index:number, ?to:symbol, ?base:symbol, ?symbol:symbol)
.decl LoadArrayIndex_To(?insn:symbol, var:symbol)
.decl LoadInstanceField_Base(?insn:symbol, ?var:symbol)
.decl LoadInstanceField(?base:symbol, ?sig:symbol, ?to:symbol, ?inmethod:symbol)
.decl _LoadInstanceField(?instruction:symbol, ?index:number, ?to:symbol, ?base:symbol, ?signature:symbol, ?symbol:symbol)
.decl LoadInstanceField_To(?insn:symbol, ?var:symbol)
.decl _LoadStaticField(?instruction:symbol, ?index:number, ?to:symbol, ?signature:symbol, ?symbol:symbol)
.decl LoadStaticField(?sig:symbol, ?to:symbol, ?inmethod:symbol)
.decl LoadStaticField_To(?insn:symbol, ?var:symbol)
.decl _LookupSwitch_DefaultTarget(?instruction:symbol, ?target:number)
.decl _LookupSwitch(?instruction:symbol, ?index:number, ?key:symbol, ?symbol:symbol)
.decl _LookupSwitch_Target(?instruction:symbol, ?value:number, ?target:number)
.decl MainClass(?class:symbol)
.decl MainMethodArgArrayContent(?heap:symbol)
.decl MainMethodArgArray(?heap:symbol)
.decl MainMethodDeclaration(?symbol:symbol)
.decl Method_Annotation(?symbol:symbol, ?annotation:symbol)
.decl Method_Arity(?symbol:symbol, ?arity:number)
.decl Method_CovariantBridge(?bridge:symbol, ?cometh:symbol)
.decl MethodDeclaredOrInherited(?meth:symbol, ?class:symbol)
.decl _Method_DeclaresException(?exceptionType:symbol, ?symbol:symbol)
.decl Method_DeclaresException(?exceptionType:symbol, ?symbol:symbol)
.decl Method_DeclaringType(?symbol:symbol, ?declaringType:symbol)
.decl Method_Descriptor(?symbol:symbol, ?descriptor:symbol)
.decl Method_FirstInstruction(?symbol:symbol, ?insn:symbol)
.decl MethodHandleConstant_Arity(?heap:symbol, ?arity:number)
.decl _MethodHandleConstant(?id:symbol, ?symbol:symbol, ?retType:symbol, ?paramTypes:symbol, ?arity:number)
.decl MethodHandleConstant_Method(?heap:symbol, ?symbol:symbol)
.decl MethodHandleConstant_ParamTypes(?heap:symbol, ?paramTypes:symbol)
.decl MethodHandleConstant_ReturnType(?heap:symbol, ?retType:symbol)
.decl MethodImplementedModuloCovariance(?simplename:symbol, ?descriptor:symbol, ?type:symbol, ?symbol:symbol)
.decl MethodImplemented(?simplename:symbol, ?descriptor:symbol, ?type:symbol, ?symbol:symbol)
.decl MethodInvocation_Base(?invocation:symbol, ?base:symbol)
.decl _MethodInvocation_Line(?instruction:symbol, line:number)
.decl MethodInvocation_Line(?invocation:symbol, ?line:number)
.decl MethodInvocation_Method(?invocation:symbol, ?signature:symbol)
.decl MethodInvocation_SimpleName(?invocation:symbol, ?simpleName:symbol)
.decl Method_JVMDescriptor(?symbol:symbol, ?descriptor:symbol)
.decl _MethodLookup_ClassResolution(?simplename:symbol, ?descriptor:symbol, ?type:symbol, ?symbol:symbol)
.decl _MethodLookup_ClosestInterface(?simplename:symbol, ?descriptor:symbol, ?type:symbol, ?symbol:symbol)
.decl _MethodLookup_ImpossibleClosest(?simplename:symbol, ?descriptor:symbol, ?type:symbol, ?symbol:symbol)
.decl _MethodLookup_MoreThanOne(?simplename:symbol, ?descriptor:symbol, ?type:symbol)
.decl _MethodLookup_MultiClosestInterfaces(?simplename:symbol, ?descriptor:symbol, ?type:symbol)
.decl MethodLookup(?simplename:symbol, ?descriptor:symbol, ?type:symbol, ?symbol:symbol)
.decl _MethodLookup_WithLen(?simplename:symbol, ?descriptor:symbol, ?type:symbol, ?symbol:symbol, ?len:number)
.decl MethodMightBeCovariantBridge(?bridge:symbol, ?meth:symbol)
.decl _Method_Modifier(?mod:symbol, ?symbol:symbol)
.decl Method_Modifier(?mod:symbol, ?symbol:symbol)
.decl MethodNotCovariantBridge(?meth1:symbol, ?meth2:symbol)
.decl MethodOverridesOther(?methodSub:symbol, ?methodSuper:symbol)
.decl Method_ParamTypes(?symbol:symbol, ?params:symbol)
.decl Method_ReturnType(?symbol:symbol, ?returnType:symbol)
.decl Method_SimpleName(?symbol:symbol, ?simpleName:symbol)
.decl MethodsOfSameNonSDKType(?method1:symbol, ?method2:symbol, ?class:symbol)
.decl MethodsOfSameOrSuperType(?method1:symbol, ?method2:symbol)
.decl _Method(?symbol:symbol, ?simplename:symbol, ?descriptor:symbol, ?declaringType:symbol, ?returnType:symbol, ?jvmDescriptor:symbol, ?arity:number)
.decl MethodTypeConstant_Arity(?heap:symbol, ?arity:number)
.decl _MethodTypeConstant(?id:symbol, ?arity:number, ?retType:symbol, ?paramTypes:symbol)
.decl _MethodTypeConstantParam(?id:symbol, ?idx:number, ?type:symbol)
.decl MethodTypeConstant_ParamTypes(?heap:symbol, ?paramTypes:symbol)
.decl MethodTypeConstant_ReturnType(?heap:symbol, ?retType:symbol)
.decl Modifier_abstract(?mod:symbol)
.decl Modifier_final(?mod:symbol)
.decl Modifier_private(?mod:symbol)
.decl Modifier_public(?mod:symbol)
.decl Modifier_static(?mod:symbol)
.decl _NativeLibEntryPoint(?lib:symbol, ?function:symbol, ?addr:symbol)
.decl _NativeMethodId(?javaMethod:symbol, ?nativeId:symbol)
.decl _NativeMethodTypeCandidate(?lib:symbol, ?function:symbol, ?descriptor:symbol, ?offset2:number)
.decl _NativeNameCandidate(?lib:symbol, ?function:symbol, ?name:symbol, ?offset1:number)
.decl _NativeReturnVar(?var:symbol, ?symbol:symbol)
.decl NativeReturnVar(?var:symbol, ?symbol:symbol)
.decl _NativeXRef(?string:symbol, ?lib:symbol, ?function:symbol, ?dataAddr:number)
.decl NonDomPredecessorBBsToSameBB(?insn:symbol, ?prev1:symbol, ?prev2:symbol)
.decl _NormalHeap(?id:symbol, ?type:symbol)
.decl NumConstantRaw(?const:symbol, ?type:symbol)
.decl _OperatorAt(?instruction:symbol, ?operator:symbol)
.decl OptInstructionFromMethodIndex(?symbol:symbol, ?index:number, ?insn:symbol)
.decl OptReturnInsn(?insn:symbol, ?symbol:symbol)
.decl OriginalHeapAllocation_Type(?heap:symbol, ?type:symbol)
.decl OverloadedJNIMethod(?javaMethod:symbol, ?type:symbol, ?name:symbol, ?descriptor:symbol)
.decl OverridesFinalize(?class:symbol)
.decl Param_Annotation(?symbol:symbol, ?index:number, ?annotation:symbol)
.decl PhantomBasedMethod(?m:symbol)
.decl PhantomMethod(?m:symbol)
.decl PhantomType(?t:symbol)
.decl _PolymorphicInvocation(?invocation:symbol, ?simpleName:symbol)
.decl PossibleNativeCodeTargetMethodLocalized(?symbol:symbol, ?function:symbol, ?file:symbol)
.decl PossibleNativeCodeTargetMethod(?symbol:symbol, ?function:symbol, ?file:symbol)
.decl PreviousNonDomPredecessorToSameBB(?insn:symbol, ?nextPred:symbol, ?prevPred:symbol)
.decl Properties(?path:symbol, ?key:symbol, ?value:symbol)
.decl ResolveInvocation(?type:symbol, ?invocation:symbol, ?tomethod:symbol)
.decl _Return(?instruction:symbol, ?index:number, ?var:symbol, ?symbol:symbol)
.decl ReturnNonvoid_Var(?return:symbol, ?var:symbol)
.decl ReturnVar(?var:symbol, ?symbol:symbol)
.decl _ReturnVoid(?instruction:symbol, ?index:number, ?symbol:symbol)
.decl RootCodeElement(?id:symbol)
.decl SpecialMethodInvocation_Base(?invocation:symbol, ?base:symbol)
.decl SpecialMethodInvocation_Descriptor(?invocation:symbol, ?descriptor:symbol)
.decl _SpecialMethodInvocation(?instruction:symbol, ?index:number, ?signature:symbol, ?base:symbol, ?symbol:symbol)
.decl SpecialMethodInvocation_SimpleName(?invocation:symbol, ?simplename:symbol)
.decl StaticMethodInvocation_Descriptor(?invocation:symbol, ?descriptor:symbol)
.decl _StaticMethodInvocation(?instruction:symbol, ?index:number, ?signature:symbol, ?symbol:symbol)
.decl StaticMethodInvocation(?invocation:symbol, ?signature:symbol, ?inmethod:symbol)
.decl StaticMethodInvocation_SimpleName(?invocation:symbol, ?simplename:symbol)
.decl StoreArrayIndex_Base(?insn:symbol, ?var:symbol)
.decl StoreArrayIndex_From(?insn:symbol, ?var:symbol)
.decl StoreArrayIndex(?from:symbol, ?base:symbol, ?inmethod:symbol)
.decl _StoreArrayIndex(?instruction:symbol, ?index:number, ?from:symbol, ?base:symbol, ?symbol:symbol)
.decl StoreInstanceField_Base(?insn:symbol, ?var:symbol)
.decl StoreInstanceField_From(?insn:symbol, ?var:symbol)
.decl StoreInstanceField(?from:symbol, ?base:symbol, ?signature:symbol, ?inmethod:symbol)
.decl _StoreInstanceField(?instruction:symbol, ?index:number, ?from:symbol, ?base:symbol, ?signature:symbol, ?symbol:symbol)
.decl StoreStaticField_From(?insn:symbol, ?var:symbol)
.decl StoreStaticField(?from:symbol, ?signature:symbol, ?inmethod:symbol)
.decl _StoreStaticField(?instruction:symbol, ?index:number, ?from:symbol, ?signature:symbol, ?symbol:symbol)
.decl _StringConstant(?id:symbol)
.decl _StringRaw(?id:symbol, ?rawId:symbol)
.decl String_toRaw(?id:symbol, ?rawId:symbol)
.decl Subclassable(?type:symbol)
.decl Subclass(?c:symbol, ?a:symbol)
.decl SubtypeOfDifferent(?subtype:symbol, ?type:symbol)
.decl SubtypeOf(?subtype:symbol, ?type:symbol)
.decl Superclass(?c:symbol, ?a:symbol)
.decl Superinterface(?k:symbol, ?c:symbol)
.decl SuperMethodInvocation_Base(?invocation:symbol, ?base:symbol)
.decl SuperMethodInvocation_Descriptor(?invocation:symbol, ?descriptor:symbol)
.decl _SuperMethodInvocation(?instruction:symbol, ?index:number, ?signature:symbol, ?base:symbol, ?symbol:symbol)
.decl SuperMethodInvocation(?invocation:symbol, ?signature:symbol, ?inmethod:symbol)
.decl SuperMethodInvocation_SimpleName(?invocation:symbol, ?simplename:symbol)
.decl SupertypeOf(?supertype:symbol, ?type:symbol)
.decl Switch_DefaultTarget(?insn:symbol, ?index:number)
.decl Switch_Key(?insn:symbol, ?key:symbol)
.decl Switch_Target(?insn:symbol, ?value:number, ?index:number)
.decl _TableSwitch_DefaultTarget(?instruction:symbol, ?target:number)
.decl _TableSwitch(?instruction:symbol, ?index:number, ?key:symbol, ?symbol:symbol)
.decl _TableSwitch_Target(?instruction:symbol, ?value:number, ?target:number)
.decl _ThisVar(?symbol:symbol, ?var:symbol)
.decl ThisVar(?symbol:symbol, ?var:symbol)
.decl Throw(?insn:symbol, ?var:symbol)
.decl _Throw(?instruction:symbol, ?index:number, ?var:symbol, ?symbol:symbol)
.decl _ThrowNull(?instruction:symbol, ?index:number, ?symbol:symbol)
.decl Throw_Var(?insn:symbol, ?var:symbol)
.decl Type_Annotation(?type:symbol, ?annotation:symbol)
.decl Type_boolean(?t:symbol)
.decl Type_byte(?t:symbol)
.decl Type_char(?t:symbol)
.decl Type_double(?t:symbol)
.decl Type_float(?t:symbol)
.decl Type_int(?t:symbol)
.decl Type_long(?t:symbol)
.decl Type_null(?t:symbol)
.decl Type_object(?t:symbol)
.decl Type_short(?t:symbol)
.decl Type_void(?t:symbol)
.decl Unsubclassable(?type:symbol)
.decl _UnsupportedInstruction(?instruction:symbol, ?index:number, ?symbol:symbol)
.decl _Valid_Type(?type:symbol)
.decl _Var_DeclaringMethod(?var:symbol, ?symbol:symbol)
.decl Var_DeclaringMethod(?var:symbol, ?symbol:symbol)
.decl _Var_SimpleName(?var:symbol, ?simplename:symbol)
.decl Var_SimpleName(?var:symbol, ?simplename:symbol)
.decl _Var_Type(?var:symbol, ?type:symbol)
.decl Var_Type(?var:symbol, ?type:symbol)
.decl VirtualMethodInvocation_Base(?invocation:symbol, ?base:symbol)
.decl VirtualMethodInvocation_BaseType(?invocation:symbol, ?type:symbol)
.decl VirtualMethodInvocation_Descriptor(?invocation:symbol, ?descriptor:symbol)
.decl _VirtualMethodInvocation(?instruction:symbol, ?index:number, ?signature:symbol, ?base:symbol, ?symbol:symbol)
.decl VirtualMethodInvocation(?invocation:symbol, ?signature:symbol, ?inmethod:symbol)
.decl VirtualMethodInvocation_SimpleName(?invocation:symbol, ?simplename:symbol)
.decl XMLNodeAttribute(?file:symbol, ?nodeId:symbol, ?index:symbol, ?localName:symbol, ?qName:symbol, ?value:symbol)
.decl XMLNodeData(?file:symbol, ?nodeId:symbol, ?data:symbol)
.decl XMLNode(?file:symbol, ?nodeId:symbol, ?parentNodeId:symbol, ?namespaceURI:symbol, ?localName:symbol, ?qName:symbol)

@import KeepMethod :- tsv{resource="KeepMethod.facts",format=()}
@import KeepClassMembers :- tsv{resource="KeepClassMembers.facts",format=()}
@import KeepClassesWithMembers :- tsv{resource="KeepClassesWithMembers.facts",format=()}
@import KeepClass :- tsv{resource="KeepClass.facts",format=()}
@import RootCodeElement :- tsv{resource="RootCodeElement.facts",format=()}
@import _ClassType :- tsv{resource="Method.facts",format=()}
@import _ArrayType :- tsv{resource="ArrayType.facts",format=()}
@import _InterfaceType :- tsv{resource="InterfaceType.facts",format=()}
@import _ComponentType :- tsv{resource="ComponentType.facts",format=()}
@import ActualParam :- tsv{resource="ActualParam.facts",format=()}
@import _BootstrapParam :- tsv{resource="BootstrapParam.facts",format=()}
@import _DirectSuperinterface :- tsv{resource="DirectSuperinterface.facts",format=()}
@import _DirectSuperclass :- tsv{resource="DirectSuperclass.facts",format=()}
@import _Field_Modifier :- tsv{resource="Field-Modifier.facts",format=()}
@import _ClassModifier :- tsv{resource="ClassModifier.facts",format=()}
@import _FormalParam :- tsv{resource="FormalParam.facts",format=()}
@import _Method_DeclaresException :- tsv{resource="Method-DeclaresException.facts",format=()}
@import _Method_Modifier :- tsv{resource="Method-Modifier.facts",format=()}
@import _NativeReturnVar :- tsv{resource="NativeReturnVar.facts",format=()}
@import _Var_Type :- tsv{resource="Var-Type.facts",format=()}
@import _Var_DeclaringMethod :- tsv{resource="Var-DeclaringMethod.facts",format=()}
@import _Var_SimpleName :- tsv{resource="Var-SimpleName.facts",format=()}
@import ApplicationClass :- tsv{resource="ApplicationClass.facts",format=()}
@import _ThisVar :- tsv{resource="ThisVar.facts",format=()}
@import _ExceptionHandler_Previous :- tsv{resource="ExceptionHandler-Previous.facts",format=()}
@import _AssignReturnValue :- tsv{resource="AssignReturnValue.facts",format=()}
@import Properties :t{ts,format=()}
resource=mport _OperatorAt :- tsv{resource="OperatorAt.facts",format=()}
@import MainClass :t{ts,format=()}
resource=mport _ClassArtifact :- tsv{resource="Class-Artifact.facts",format=()}
@import _NormalHeap :- tsv{resource="NormalHeap.facts",format=()}
@import _StringConstant :- tsv{resource="StringConstant.facts",format=()}
@import _StringRaw :- tsv{resource="StringRaw.facts",format=()}
@import _ClassHeap :- tsv{resource="ClassHeap.facts",format=()}
@import _MethodHandleConstant :- tsv{resource="MethodHandleConstant.facts",format=()}
@import _MethodTypeConstant :- tsv{resource="MethodTypeConstant.facts",format=()}
@import _MethodTypeConstantParam :- tsv{resource="MethodTypeConstantParam.facts",format=()}
@import _NativeLibEntryPoint :- tsv{resource="NativeLibEntryPoint.facts",format=()}
@import _NativeMethodTypeCandidate :- tsv{resource="NativeMethodTypeCandidate.facts",format=()}
@import _NativeNameCandidate :- tsv{resource="NativeNameCandidate.facts",format=()}
@import _NativeMethodId :- tsv{resource="NativeMethodId.facts",format=()}
@import _NativeXRef :- tsv{resource="NativeXRef.facts",format=()}
@import _EmptyArray :- tsv{resource="EmptyArray.facts",format=()}
@import ArrayAllocation :- tsv{resource="ArrayAllocation.facts",format=()}
@import _AssignHeapAllocation :- tsv{resource="AssignHeapAllocation.facts",format=()}
@import _AssignLocal :- tsv{resource="AssignLocal.facts",format=()}
@import _AssignBinop :- tsv{resource="AssignBinop.facts",format=()}
@import _AssignUnop :- tsv{resource="AssignUnop.facts",format=()}
@import _AssignOperFrom :- tsv{resource="AssignOperFrom.facts",format=()}
@import _AssignOperFromConstant :- tsv{resource="AssignOperFromConstant.facts",format=()}
@import _IfConstant :- tsv{resource="IfConstant.facts",format=()}
@import _IfVar :- tsv{resource="IfVar.facts",format=()}
@import _DummyIfVar :- tsv{resource="DummyIfVar.facts",format=()}
@import _AssignCast :- tsv{resource="AssignCast.facts",format=()}
@import _AssignCastNumConstant :- tsv{resource="AssignCastNumConstant.facts",format=()}
@import _AssignCastNull :- tsv{resource="AssignCastNull.facts",format=()}
@import _AssignNumConstant :- tsv{resource="AssignNumConstant.facts",format=()}
@import _AssignNull :- tsv{resource="AssignNull.facts",format=()}
@import _AssignInstanceOf :- tsv{resource="AssignInstanceOf.facts",format=()}
@import _Field :- tsv{resource="Field.facts",format=()}
@import _EnterMonitor :- tsv{resource="EnterMonitor.facts",format=()}
@import _ExitMonitor :- tsv{resource="ExitMonitor.facts",format=()}
@import _MethodInvocation_Line :- tsv{resource="MethodInvocation-Line.facts",format=()}
@import _StaticMethodInvocation :- tsv{resource="StaticMethodInvocation.facts",format=()}
@import _SpecialMethodInvocation :- tsv{resource="SpecialMethodInvocation.facts",format=()}
@import _VirtualMethodInvocation :- tsv{resource="VirtualMethodInvocation.facts",format=()}
@import _SuperMethodInvocation :- tsv{resource="SuperMethodInvocation.facts",format=()}
@import _DynamicMethodInvocation :- tsv{resource="DynamicMethodInvocation.facts",format=()}
@import _DynamicMethodInvocation_DynParamType :- tsv{resource="DynamicMethodInvocation-ParamType.facts",format=()}
@import _PolymorphicInvocation :- tsv{resource="PolymorphicInvocation.facts",format=()}
@import _Throw :- tsv{resource="Throw.facts",format=()}
@import _ThrowNull :- tsv{resource="ThrowNull.facts",format=()}
@import _ExceptionHandler :- tsv{resource="ExceptionHandler.facts",format=()}
@import ExceptionHandler_FormalParam :- tsv{resource="ExceptionHandler-FormalParam.facts",format=()}
@import _Method :- tsv{resource="Method.facts",format=()}
@import _StoreInstanceField :- tsv{resource="StoreInstanceField.facts",format=()}
@import _LoadInstanceField :- tsv{resource="LoadInstanceField.facts",format=()}
@import _StoreStaticField :- tsv{resource="StoreStaticField.facts",format=()}
@import _LoadStaticField :- tsv{resource="LoadStaticField.facts",format=()}
@import _StoreArrayIndex :- tsv{resource="StoreArrayIndex.facts",format=()}
@import _LoadArrayIndex :- tsv{resource="LoadArrayIndex.facts",format=()}
@import ArrayInsnIndex :- tsv{resource="ArrayInsnIndex.facts",format=()}
@import _ArrayNumIndex :- tsv{resource="ArrayNumIndex.facts",format=()}
@import _Goto :- tsv{resource="Goto.facts",format=()}
@import _If :- tsv{resource="If.facts",format=()}
@import _TableSwitch :- tsv{resource="TableSwitch.facts",format=()}
@import _LookupSwitch :- tsv{resource="LookupSwitch.facts",format=()}
@import _TableSwitch_Target :- tsv{resource="TableSwitch-Target.facts",format=()}
@import _LookupSwitch_Target :- tsv{resource="LookupSwitch-Target.facts",format=()}
@import _TableSwitch_DefaultTarget :- tsv{resource="TableSwitch-Default.facts",format=()}
@import _LookupSwitch_DefaultTarget :- tsv{resource="LookupSwitch-Default.facts",format=()}
@import _Return :- tsv{resource="Return.facts",format=()}
@import _ReturnVoid :- tsv{resource="ReturnVoid.facts",format=()}
@import _AssignPhantomInvoke :- tsv{resource="AssignPhantomInvoke.facts",format=()}
@import _BreakpointStmt :- tsv{resource="BreakpointStmt.facts",format=()}
@import _UnsupportedInstruction :- tsv{resource="UnsupportedInstruction.facts",format=()}
@import Type_Annotation :- tsv{resource="Type-Annotation.facts",format=()}
@import Method_Annotation :- tsv{resource="Method-Annotation.facts",format=()}
@import Field_Annotation :- tsv{resource="Field-Annotation.facts",format=()}
@import Param_Annotation :- tsv{resource="Param-Annotation.facts",format=()}
@import AnnotationElement :- tsv{resource="AnnotationElement.facts",format=()}
@import PhantomType :- tsv{resource="PhantomType.facts",format=()}
@import PhantomMethod :- tsv{resource="PhantomMethod.facts",format=()}
@import PhantomBasedMethod :- tsv{resource="PhantomBasedMethod.facts",format=()}
@import NumConstantRaw :- tsv{resource="NumConstantRaw.facts",format=()}
@import XMLNode :- tsv{resource="XMLNode.facts",format=()}
@import XMLNodeAttribute :- tsv{resource="XMLNodeAttribute.facts",format=()}
@import XMLNodeData :- tsv{resource="XMLNodeData.facts",format=()}



AllocatedObjectSupportsFinalize(?heap, ?inmethod) :-
    AssignHeapAllocation(?heap, _, ?inmethod),
    HeapAllocation_Type(?heap, ?class),
    OverridesFinalize(?class).


Throw(?insn, ?var) :-
	isThrow_Insn(?insn),
	Throw_Var(?insn, ?var).


isType(?t) :- isPrimitiveType(?t) ; isReferenceType(?t).

isReferenceType(?t) :-
  isNullType(?t) ; isArrayType(?t) ; isClassType(?t) ; isInterfaceType(?t) ; isAnnotation(?t).

isInstruction(?i) :-
  isThrow_Insn(?i) ; isGoto_Insn(?i) ; isIf_Insn(?i) ; isSwitch_Insn(?i) ; isMonitorInstruction(?i) ;
  isFieldInstruction(?i) ; isArrayInstruction(?i) ; isAssignInstruction(?i) ;
  isReturnInstruction(?i) ; isMethodInvocation(?i) ; isUnsupportedInstruction(?i).

isThrowNull_Insn(?i) :- isThrow_Insn(?i).

isSwitch_Insn(?i) :- isTableSwitch_Insn(?i) ; isLookupSwitch_Insn(?i).

isMonitorInstruction(?i) :- isEnterMonitor_Insn(?i) ; isExitMonitor_Insn(?i).

isFieldInstruction(?i) :-
  isLoadInstanceField_Insn(?i) ; isStoreInstanceField_Insn(?i) ;
  isLoadStaticField_Insn(?i) ; isStoreStaticField_Insn(?i).

isArrayInstruction(?i) :- isLoadArrayIndex_Insn(?i) ; isStoreArrayIndex_Insn(?i).

isAssignInstruction(?i) :-
  isAssignOper_Insn(?i) ; isAssignInstanceOf_Insn(?i) ; isAssignNull_Insn(?i) ;
  isAssignNumConstant_Insn(?i) ; isAssignCast_Insn(?i) ; isAssignHeapAllocation_Insn(?i).

isAssignOper_Insn(?i) :-
  isAssignBinop_Insn(?i) ; isAssignUnop_Insn(?i) ; isAssignLocal_Insn(?i).

isAssignCast_Insn(?i) :- isAssignCastNumConstant_Insn(?i) ; isAssignCastNull_Insn(?i).

isReturnInstruction(?i) :- isReturnVoid_Insn(?i) ; isReturnNonvoid_Insn(?i).

isMethodInvocation(?i) :-
  isVirtualMethodInvocation_Insn(?i) ; isSpecialMethodInvocation_Insn(?i) ; isStaticMethodInvocation_Insn(?i) ;
  isSuperMethodInvocation_Insn(?i) ; isDynamicMethodInvocation_Insn(?i).

isUnsupportedInstruction(?i) :- isAssignPhantomInvoke(?i) ; isBreakpointStmt(?i).

isClassType(?class) :- _ClassType(?class).

isArrayType(?arrayType) :- _ArrayType(?arrayType).

isInterfaceType(?interface) :- _InterfaceType(?interface).

isArrayType(?arrayType),
isType(?componentType),
ComponentType(?arrayType, ?componentType) :-
  _ComponentType(?arrayType, ?componentType).

isMethodInvocation(?invocation),
isVar(?var):-
  ActualParam(?index, ?invocation, ?var).

isDynamicMethodInvocation_Insn(?invocation),
isVar(?var),
BootstrapParam(?index, ?invocation, ?var) :-
  _BootstrapParam(?index, ?invocation, ?var).
  isReferenceType(?class),
isInterfaceType(?interface),
DirectSuperinterface(?class, ?interface) :-
  _DirectSuperinterface(?class, ?interface).

isClassType(?class),
isClassType(?superclass),
DirectSuperclass(?class, ?superclass) :-
  _DirectSuperclass(?class, ?superclass).

isModifier(?modifier),
isField(?field),
Field_Modifier(?modifier, ?field) :-
  _Field_Modifier(?modifier, ?field).

ClassModifier(?modifier, ?class) :-
  _ClassModifier(?modifier, ?class).

isMethod(?symbol),
isVar(?var),
FormalParam(?index, ?symbol, ?var) :-
  _FormalParam(?index, ?symbol, ?var).

isReferenceType(?exceptionType),
isMethod(?symbol),
Method_DeclaresException(?exceptionType, ?symbol) :-
  _Method_DeclaresException(?exceptionType, ?symbol).

isModifier(?mod),
isMethod(?symbol),
Method_Modifier(?mod, ?symbol) :-
  _Method_Modifier(?mod, ?symbol).

isVar(?var),
isMethod(?symbol),
NativeReturnVar(?var, ?symbol) :-
  _NativeReturnVar(?var, ?symbol).

isVar(?var),
isType(?type),
Var_Type(?var, ?type) :-
  _Var_Type(?var, ?type).

isVar(?var),
isMethod(?symbol),
Var_DeclaringMethod(?var, ?symbol) :-
  _Var_DeclaringMethod(?var, ?symbol).

isVar(?var),
Var_SimpleName(?var, ?simplename) :-
  _Var_SimpleName(?var, ?simplename).

isReferenceType(?type) :-
  ApplicationClass(?type).

isMethod(?symbol),
isVar(?var),
ThisVar(?symbol, ?var) :-
  _ThisVar(?symbol, ?var).

isExceptionHandler(?handler),
isExceptionHandler(?previous),
ExceptionHandler_Previous(?handler, ?previous) :-
  _ExceptionHandler_Previous(?handler, ?previous).

isMethodInvocation(?invocation),
isVar(?to),
AssignReturnValue(?invocation, ?to) :-
  _AssignReturnValue(?invocation, ?to).
  MainClass(?b):-
  MainClass(?a),
  ?l1 = strlen(?a),
  ?l2 = strlen("Example"),
  ?b = substr(?a, ?l1 - ?l2, ?l2),
  match(".*Example",?a).


isType(?type),
isNormalHeap(?id),
OriginalHeapAllocation_Type(?id, ?type),
HeapAllocation_Type(?id, ?type) :-
  _NormalHeap(?id, ?type).

isClassType("java.lang.String").

isStringConstant(?id),
OriginalHeapAllocation_Type(?id, "java.lang.String"),
HeapAllocation_Type(?id, "java.lang.String") :-
  _StringConstant(?id).

isStringRaw(?id),
String_toRaw(?id, ?rawId) :-
  _StringRaw(?id, ?rawId).

isType(?instanceType),
isClassHeap(?id),
OriginalHeapAllocation_Type(?id, "java.lang.Class"),
HeapAllocation_Type(?id, "java.lang.Class") :-
  _ClassHeap(?id, ?instanceType).
  isType("java.lang.invoke.MethodHandle").
isReferenceType("java.lang.invoke.MethodHandle").
isClassType("java.lang.invoke.MethodHandle").

isMethodHandleConstant(?id),
OriginalHeapAllocation_Type(?id, "java.lang.invoke.MethodHandle"),
MethodHandleConstant_Method(?id, ?symbol),
MethodHandleConstant_Arity(?id, ?arity),
MethodHandleConstant_ReturnType(?id, ?retType),
MethodHandleConstant_ParamTypes(?id, ?paramTypes),
HeapAllocation_Type(?id, "java.lang.invoke.MethodHandle") :-
  _MethodHandleConstant(?id, ?symbol, ?retType, ?paramTypes, ?arity).
  isMethodTypeConstant(?id),
HeapAllocation_Type(?id, "java.lang.invoke.MethodType"),
MethodTypeConstant_Arity(?id, ?arity),
MethodTypeConstant_ReturnType(?id, ?retType),
MethodTypeConstant_ParamTypes(?id, ?paramTypes),
OriginalHeapAllocation_Type(?id, "java.lang.invoke.MethodType") :-
  _MethodTypeConstant(?id, ?arity, ?retType, ?paramTypes).


HeapAllocation_EmptyArray(?id) :-
  _EmptyArray(?id).


isAssignHeapAllocation_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Line(?instruction, ?linenumber),
Instruction_Method(?instruction, ?symbol),
AssignInstruction_To(?instruction, ?to),
AssignHeapAllocation_Heap(?instruction, ?heap) :-
  _AssignHeapAllocation(?instruction, ?index, ?heap, ?to, ?symbol, ?linenumber).

isAssignLocal_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
AssignLocal_From(?instruction, ?from),
AssignInstruction_To(?instruction, ?to) :-
  _AssignLocal(?instruction, ?index, ?from, ?to, ?symbol).

isAssignBinop_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
AssignInstruction_To(?instruction, ?to) :-
  _AssignBinop(?instruction, ?index, ?to, ?symbol).

isAssignUnop_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
AssignInstruction_To(?instruction, ?to) :-
  _AssignUnop(?instruction, ?index, ?to, ?symbol).

AssignOper_From(?instruction, ?pos, ?from) :-
  _AssignOperFrom(?instruction, ?pos, ?from).
  AssignOper_FromConstant(?instruction, ?pos, ?from) :-
  _AssignOperFromConstant(?instruction, ?pos, ?from).
  If_Constant(?instruction, ?pos, ?cons) :-
  _IfConstant(?instruction, ?pos, ?cons).

If_Var(?instruction, ?pos, ?var) :-
  _IfVar(?instruction, ?pos, ?var).
  DummyIf_Var(?instruction, ?var) :-
  _DummyIfVar(?instruction, ?var).
  isAssignCast_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
AssignCast_Type(?instruction, ?type),
AssignCast_From(?instruction, ?from),
AssignInstruction_To(?instruction, ?to) :-
  _AssignCast(?instruction, ?index, ?from, ?to, ?type, ?symbol).

isAssignCastNumConstant_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
AssignCast_Type(?instruction, ?type),
AssignCastNumConstant_Id(?instruction, ?const),
AssignInstruction_To(?instruction, ?to) :-
  _AssignCastNumConstant(?instruction, ?index, ?const, ?to, ?type, ?symbol).

isAssignCastNull_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
AssignCast_Type(?instruction, ?type),
AssignInstruction_To(?instruction, ?to) :-
  _AssignCastNull(?instruction, ?index, ?to, ?type, ?symbol).

isNumConstant(?const),
isAssignNumConstant_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
AssignNumConstant_Id(?instruction, ?const),
AssignInstruction_To(?instruction, ?to) :-
  _AssignNumConstant(?instruction, ?index, ?const, ?to, ?symbol).

isAssignNull_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
AssignInstruction_To(?instruction, ?to) :-
  _AssignNull(?instruction, ?index, ?to, ?symbol).

isAssignInstanceOf_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
AssignInstanceOf_From(?instruction, ?from),
AssignInstanceOf_Type(?instruction, ?type),
AssignInstruction_To(?instruction, ?to) :-
  _AssignInstanceOf(?instruction, ?index, ?from, ?to, ?type, ?symbol).

isField(?signature),
Field_DeclaringType(?signature, ?declaringType),
Field_SimpleName(?signature, ?simplename),
Field_Type(?signature, ?type) :-
  _Field(?signature, ?declaringType, ?simplename, ?type).
  isEnterMonitor_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
EnterMonitor_Var(?instruction, ?var) :-
  _EnterMonitor(?instruction, ?index, ?var, ?symbol).

isExitMonitor_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
ExitMonitor_Var(?instruction, ?var) :-
  _ExitMonitor(?instruction, ?index, ?var, ?symbol).

isMethodInvocation(?instruction),
MethodInvocation_Line(?instruction, ?line) :-
  _MethodInvocation_Line(?instruction, ?line).

MethodInvocation_Base(?invocation, ?base) :-
  VirtualMethodInvocation_Base(?invocation, ?base).
MethodInvocation_Base(?invocation, ?base) :-
  SpecialMethodInvocation_Base(?invocation, ?base).

isMethod(?signature),
isMethodInvocation(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
MethodInvocation_Method(?instruction, ?signature) :-
  _StaticMethodInvocation(?instruction, ?index, ?signature, ?symbol).

isStaticMethodInvocation_Insn(?instruction) :-
  _StaticMethodInvocation(?instruction, _, ?signature, _),
  !isOpaqueMethod(?signature).
  isMethod(?signature),
isMethodInvocation(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
MethodInvocation_Method(?instruction, ?signature) :-
  _SpecialMethodInvocation(?instruction, ?index, ?signature, _, ?symbol).

isSpecialMethodInvocation_Insn(?instruction),
SpecialMethodInvocation_Base(?instruction, ?base) :-
  _SpecialMethodInvocation(?instruction, _, ?signature, ?base, _),
  !isOpaqueMethod(?signature).
  isMethod(?signature),
isMethodInvocation(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
MethodInvocation_Method(?instruction, ?signature) :-
  _VirtualMethodInvocation(?instruction, ?index, ?signature, _, ?symbol).

isVirtualMethodInvocation_Insn(?instruction),
VirtualMethodInvocation_Base(?instruction, ?base) :-
  _VirtualMethodInvocation(?instruction, _, ?signature, ?base, _),
  !isOpaqueMethod(?signature).
  isMethod(?signature),
isMethodInvocation(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
MethodInvocation_Method(?instruction, ?signature),
isSuperMethodInvocation_Insn(?instruction),
SuperMethodInvocation_Base(?instruction, ?base) :-
  _SuperMethodInvocation(?instruction, ?index, ?signature, ?base, ?symbol).
  isDynamicMethodInvocation_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
DynamicMethodInvocation_Bootstrap(?instruction, ?bootSignature),
DynamicMethodInvocation_DynName(?instruction, ?dynName),
DynamicMethodInvocation_DynReturnType(?instruction, ?dynRetType),
DynamicMethodInvocation_DynParamTypes(?instruction, ?dynParamTypes),
DynamicMethodInvocation_HandleTag(?instruction, ?tag),
DynamicMethodInvocation_DynArity(?instruction, ?dynArity) :-
  _DynamicMethodInvocation(?instruction, ?index, ?bootSignature, ?dynName, ?dynRetType, ?dynArity, ?dynParamTypes, ?tag, ?symbol).



isThrow_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
Throw(?instruction, ?var),
Throw_Var(?instruction, ?var) :-
  _Throw(?instruction, ?index, ?var, ?symbol).

isThrowNull_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol) :-
  _ThrowNull(?instruction, ?index, ?symbol).

isExceptionHandler(?handler),
isInstruction(?handler),
Instruction_Index(?handler, ?index),
Instruction_Method(?handler, ?symbol),
ExceptionHandler_Method(?handler, ?symbol),
ExceptionHandler_Index(?handler, ?index),
ExceptionHandler_Type(?handler, ?type),
ExceptionHandler_Begin(?handler, ?begin),
ExceptionHandler_End(?handler, ?end) :-
  _ExceptionHandler(?handler, ?symbol, ?index, ?type, ?begin, ?end).

isMethod(?symbol),
isJVMDescriptor(?jvmDescriptor),
Method_SimpleName(?symbol, ?simplename),
Method_ParamTypes(?symbol, ?params),
Method_DeclaringType(?symbol, ?declaringType),
Method_JVMDescriptor(?symbol, ?jvmDescriptor),
Method_Arity(?symbol, ?arity),
Method_ReturnType(?symbol, ?returnType) :-
  _Method(?symbol, ?simplename, ?params, ?declaringType, ?returnType, ?jvmDescriptor, ?arity).

isMethodDescriptor(?descriptor),
Method_Descriptor(?symbol, ?descriptor) :-
  Method_ReturnType(?symbol, ?returnType),
  Method_ParamTypes(?symbol, ?params),
  ?descriptor = cat(?returnType, cat("(", cat(?params, ")"))).
  isStoreInstanceField_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
FieldInstruction_Signature(?instruction, ?signature),
StoreInstanceField_Base(?instruction, ?base),
StoreInstanceField_From(?instruction, ?from) :-
  _StoreInstanceField(?instruction, ?index, ?from, ?base, ?signature, ?symbol).

isLoadInstanceField_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
FieldInstruction_Signature(?instruction, ?signature),
LoadInstanceField_Base(?instruction, ?base),
LoadInstanceField_To(?instruction, ?to) :-
  _LoadInstanceField(?instruction, ?index, ?to, ?base, ?signature, ?symbol).

isStoreStaticField_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
FieldInstruction_Signature(?instruction, ?signature),
StoreStaticField_From(?instruction, ?from) :-
  _StoreStaticField(?instruction, ?index, ?from, ?signature, ?symbol).

isLoadStaticField_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
FieldInstruction_Signature(?instruction, ?signature),
LoadStaticField_To(?instruction, ?to) :-
  _LoadStaticField(?instruction, ?index, ?to, ?signature, ?symbol).

isStoreArrayIndex_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
StoreArrayIndex_Base(?instruction, ?base),
StoreArrayIndex_From(?instruction, ?from) :-
  _StoreArrayIndex(?instruction, ?index, ?from, ?base, ?symbol).

isLoadArrayIndex_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
LoadArrayIndex_Base(?instruction, ?base),
LoadArrayIndex_To(?instruction, ?to) :-
  _LoadArrayIndex(?instruction, ?index, ?to, ?base, ?symbol).


ArrayNumIndex(?instruction, ?index) :-
  _ArrayNumIndex(?instruction, ?index).

isGoto_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
Goto_Target(?instruction, ?to) :-
  _Goto(?instruction, ?index, ?to, ?symbol).

isIf_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
If_Target(?instruction, ?to) :-
  _If(?instruction, ?index, ?to, ?symbol).

isTableSwitch_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
Switch_Key(?instruction, ?key) :-
  _TableSwitch(?instruction, ?index, ?key, ?symbol).


isLookupSwitch_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
Switch_Key(?instruction, ?key) :-
  _LookupSwitch(?instruction, ?index, ?key, ?symbol).

Switch_Target(?instruction, ?value, ?target) :-
  _TableSwitch_Target(?instruction, ?value, ?target).


Switch_Target(?instruction, ?value, ?target) :-
  _LookupSwitch_Target(?instruction, ?value, ?target).
  Switch_DefaultTarget(?instruction, ?target) :-
  _TableSwitch_DefaultTarget(?instruction, ?target).


Switch_DefaultTarget(?instruction, ?target) :-
  _LookupSwitch_DefaultTarget(?instruction, ?target).

isReturnNonvoid_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol),
ReturnNonvoid_Var(?instruction, ?var) :-
  _Return(?instruction, ?index, ?var, ?symbol).

isReturnVoid_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol) :-
  _ReturnVoid(?instruction, ?index, ?symbol).

isAssignPhantomInvoke(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol) :-
  _AssignPhantomInvoke(?instruction, ?index, ?symbol).

isBreakpointStmt(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol) :-
  _BreakpointStmt(?instruction, ?index, ?symbol).

isUnsupportedInstruction(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?symbol) :-
  _UnsupportedInstruction(?instruction, ?index, ?symbol).




.output isOpaqueInstruction
.output Instruction_Method
.output Goto_Target
.output If_Target
.output isIf_Insn
.output isThrow_Insn
.output isGoto_Insn
.output isSwitch_Insn
.output AssignInstruction_To
.output Switch_DefaultTarget
.output isInstruction
.output isReturnInstruction
.output Instruction_Index

.output Instruction_Method
.output Instruction_Index
.output AssignInstruction_To
.output isReturnInstruction
.output isAssignLocal_Insn
.output isThrow_Insn
.output isSwitch_Insn
.output isGoto_Insn
.output ExceptionHandler_Method
.output ExceptionHandler_Index
.output Switch_Target
.output If_Target
.output Goto_Target
.output isInstruction







// Making explicit, so it can be negated.

// This is almost but not really a "may" relation for successor
// instructions. It does not include the targets of throw
// instructions. Hence the predicate name, meant to remind users that
// they should always check if the instruction is the beginning of
// an exception handler.

// Same concept for basic blocks. Reduces the cost significantly, since
// subsequent computation is quadratic.

// The Dominates relation is defined on basic blocks,
// represented by their first instruction (head). Defining
// a dense quadratic relation, like Dominates, on individual
// instructions was hugely expensive.

// To get to ?insn, we need to have gone through ?dominator

// ?insn dominates its predecessor. Must be head of basic block
// (head of a loop).

// A generally useful concept. Includes the case of both being in the
// same basic block.

// Phi Nodes Definition. If we have SSA input, then any multiple
// assignments to the same var are because of a Phi node. In fact,
// these will also be consecutive.


// Just inverting for efficiency.

// There may be multiple return instructions. This is a pain,
// since they also represent merges of control- and data-flow.
// We often need to define "forall" behavior over them.


//default implementation also includes exeception throws
// thus creating more thatn one FirstInstruction per Methode

Method_FirstInstruction(?method, ?insn) :-
   Instruction_Method(?insn, ?method),
   !Instruction_Prev(?insn, _),
   !IsJumpTarget(?insn),
   !_Throw(?insn, _, _, ?method).

OptInstructionFromMethodIndex(?method, ?index, ?insn) :-
   Instruction_Method(?insn, ?method),
   Instruction_Index(?insn, ?index).

Instruction_Next(?insn, ?next) :-
   Instruction_Method(?insn, ?inMethod),
   Instruction_Index(?insn, ?i),
   OptInstructionFromMethodIndex(?inMethod, ?i + 1, ?next).

Instruction_Prev(?insn, ?prev) :-
   Instruction_Method(?insn, ?inMethod),
   Instruction_Index(?insn, ?i),
   OptInstructionFromMethodIndex(?inMethod, ?i - 1, ?prev).

JumpTarget(?insn, ?goto) :-
   Goto_Target(?goto, ?targetIndex),
   Instruction_Method(?goto, ?gotoMethod),
   OptInstructionFromMethodIndex(?gotoMethod, ?targetIndex, ?insn).
JumpTarget(?insn, ?if) :-
   If_Target(?if, ?targetIndex),
   Instruction_Method(?if, ?method),
   OptInstructionFromMethodIndex(?method, ?targetIndex, ?insn).
JumpTarget(?insn, ?sw) :-
   (Switch_Target(?sw, _, ?targetIndex) ; Switch_DefaultTarget(?sw, ?targetIndex)),
   Instruction_Method(?sw, ?method),
   OptInstructionFromMethodIndex(?method, ?targetIndex, ?insn).

IsJumpTarget(?insn) :-
   JumpTarget(?insn, _).

ExceptionHandlerFirstInstruction(?insn) :-
   ExceptionHandler_Index(?handler, ?index),
   ExceptionHandler_Method(?handler, ?method),
   OptInstructionFromMethodIndex(?method, ?index, ?insn).

FallThrough(?insn) :-
   isIf_Insn(?if),
   Instruction_Next(?if, ?insn).
// REVIEW: The next two shouldn't matter much since without a label the
// fallthrough instruction would be dead code OR the beginning of an
// exception handler. The latter is handled specially. For the former, we
// consider such dead code to start a new BB, so that it doesn't accidentally
// get considered a continuation of the previous BB.
FallThrough(?insn) :-
   isReturnInstruction(?ret),
   Instruction_Next(?ret, ?insn).
FallThrough(?insn) :-
   isThrow_Insn(?throw),
   Instruction_Next(?throw, ?insn).


// First instruction of a method is a basic block beginning
BasicBlockBegin(?insn) :-
   OptInstructionFromMethodIndex(_, 1, ?insn).
BasicBlockBegin(?insn) :-
   ExceptionHandlerFirstInstruction(?insn).
BasicBlockBegin(?insn) :-
   JumpTarget(?insn, _).
BasicBlockBegin(?insn) :-
   FallThrough(?insn).

NextInSameBasicBlock(?insn, ?next) :-
   Instruction_Next(?insn, ?next),
   !BasicBlockBegin(?next).

PrevInSameBasicBlock(?insn, ?prev) :-
   NextInSameBasicBlock(?prev, ?insn).

BasicBlockHead(?insn, ?insn) :-
   BasicBlockBegin(?insn).
BasicBlockHead(?insn, ?headInsn) :-
   BasicBlockHead(?prev, ?headInsn),
   NextInSameBasicBlock(?prev, ?insn).

BasicBlockTail(?headInsn, ?tailInsn) :-
   BasicBlockHead(?tailInsn, ?headInsn),
   !NextInSameBasicBlock(?tailInsn, _).

BasicBlockEnd(?insn) :- BasicBlockTail(_, ?insn).

UnconditionalControlTransfer(?insn) :-
   isGoto_Insn(?insn) ;
   isSwitch_Insn(?insn) ;
   isReturnInstruction(?insn) ;
   isThrow_Insn(?insn).

MaySuccessorModuloThrow(?next, ?prev) :-
   JumpTarget(?next, ?prev).
MaySuccessorModuloThrow(?next, ?insn) :-
   Instruction_Next(?insn, ?next),
   !UnconditionalControlTransfer(?insn).

MayPredecessorModuloThrow(?prev, ?next) :-
   MaySuccessorModuloThrow(?next, ?prev).

MaySuccessorBBModuloThrow(?next, ?prev) :-
   MaySuccessorModuloThrow(?next, ?prevEnd),
   BasicBlockEnd(?prevEnd),
   BasicBlockBegin(?next),
   BasicBlockHead(?prevEnd, ?prev).

MayPredecessorBBModuloThrow(?prev, ?next) :-
   MaySuccessorBBModuloThrow(?next, ?prev).

// The Dominates relation is defined on basic blocks,
// represented by their first instruction (head). Defining
// a dense quadratic relation, like Dominates, on individual
// instructions was hugely expensive.

// Dominates(?dominator, ?insn): To get to ?insn, we need to have gone
// through ?dominator
Dominates(?dominator, ?insn) :-
   SameMethodBBHeads(?dominator, ?insn),
   !DoesNotDominate(?dominator, ?insn).

// Either the first instruction...
CFGRoot(?insn, ?method) :-
   OptInstructionFromMethodIndex(?method, 1, ?insn).
// or... could also be beginning of exception handler
CFGRoot(?insn, ?method) :-
   BBHeadInMethod(?insn, ?method),
   !(MayPredecessorBBModuloThrow(_, ?insn)).

ExistsMayPredecessorBBModuloThrow(?insn) :-
   MayPredecessorBBModuloThrow(_, ?insn).

// DoesNotDominate(?dominatorCandidate, ?insn): ?insn (which is a
// basic block head) is NOT dominated by ?dominatorCandidate
DoesNotDominate(?dominatorCandidate, ?insn) :-
   BBHeadInMethod(?dominatorCandidate, ?method),
   CFGRoot(?insn, ?method),
   ?dominatorCandidate != ?insn.

DoesNotDominate(?dominatorCandidate, ?insn) :-
   DoesNotDominate(?dominatorCandidate, ?otherInsn),
   MaySuccessorBBModuloThrow(?insn, ?otherInsn),
   ?insn != ?dominatorCandidate.


// ?insn dominates its predecessor. ?insn must be the head of a basic
// block (head of a loop).
DominatesItsPredecessorInstruction(?prevInsn, ?insn) :-
   JumpTarget(?insn, ?prevInsn),
   BasicBlockHead(?prevInsn, ?prevInsnHead),
   (?insn = ?prevInsnHead;
    Dominates(?insn, ?prevInsnHead)).

// KF: Currently this rules is not being used at all.
// // Includes the case of both being in the same basic block.
// DominatesItsSuccessorInstruction(?insn, ?prevInsn) :-
//    MaySuccessorModuloThrow(?insn, ?prevInsn),
//    BasicBlockHead[?prevInsn] = ?prevInsnHead,
//    BasicBlockHead[?insn] = ?insnHead,
//    (?insnHead = ?prevInsnHead;
//     Dominates(?prevInsnHead, ?insnHead)).


NextInSamePhiNode(?insn, ?nextInsn) :-
   isAssignLocal_Insn(?insn),
   AssignInstruction_To(?insn, ?var),
   Instruction_Next(?insn, ?nextInsn),
   isAssignLocal_Insn(?nextInsn),
   AssignInstruction_To(?nextInsn, ?var).

PhiNodeHead(?nextInsn, ?insn),
PhiNodeHead(?insn, ?insn) :-
   NextInSamePhiNode(?insn, ?nextInsn),
   Instruction_Prev(?insn, ?prevInsn),
   !NextInSamePhiNode(?prevInsn, ?insn).

PhiNodeHead(?nextInsn, ?insn),
PhiNodeHead(?insn, ?insn) :-
   NextInSamePhiNode(?insn, ?nextInsn),
   !Instruction_Prev(?insn, _).

PhiNodeHead(?nextInsn, ?headInsn) :-
   PhiNodeHead(?phiInsn, ?headInsn),
   NextInSamePhiNode(?phiInsn, ?nextInsn).

// Just inverting for efficiency.
InstructionInPhiNode(?insn, ?headInsn) :-
   PhiNodeHead(?insn, ?headInsn).


///// auxiliary quick-and-dirty predicates
OptReturnInsn(?insn, ?method) :-
   isReturnInstruction(?insn),
   Instruction_Method(?insn, ?method).

HigherReturnIndex(?insn, ?indexHigher) :-
   OptReturnInsn(?insn, ?method),
   OptReturnInsn(?insnHigher, ?method),
   Instruction_Index(?insnHigher, ?indexHigher),
   Instruction_Index(?insn, ?index),
   ?index < ?indexHigher.

NextReturnIndex(?returnInsn, ?nextReturnIndex) :-
   isInstruction(?returnInsn), 
   ?nextReturnIndex = min ?index : HigherReturnIndex(?returnInsn, ?index).

NextReturn(?returnInsn, ?nextReturnInsn) :-
   NextReturnIndex(?returnInsn, ?nextReturnIndex),
   Instruction_Method(?returnInsn, ?meth),
   OptInstructionFromMethodIndex(?meth, ?nextReturnIndex, ?nextReturnInsn).

ExistsPreviousReturn(?insn) :-
   NextReturn(_, ?insn).

BBHeadInMethod(?insn, ?method) :-
   BasicBlockBegin(?insn),
   Instruction_Method(?insn, ?method).

SameMethodBBHeads(?insn1, ?insn2) :-
   BBHeadInMethod(?insn1, ?method),
   BBHeadInMethod(?insn2, ?method).

// Auxiliaries...

// Quadratic, but doesn't matter, since it's so local and only
// defined on basic blocks.
PredecessorBBsToSameBB(?insn, ?prev1, ?prev2) :-
   MayPredecessorBBModuloThrow(?prev1, ?insn),
   MayPredecessorBBModuloThrow(?prev2, ?insn),
   ?prev1 != ?prev2.

LargerPredecessorIndexToSameBB(?insn, ?indexLarge, ?prevSmall) :-
   PredecessorBBsToSameBB(?insn, ?prevLarge, ?prevSmall),
   Instruction_Index(?prevLarge, ?indexLarge),
   Instruction_Index(?prevSmall, ?indexSmall),
   ?indexLarge > ?indexSmall.

.output NextPredecessorIndexToSameBB
NextPredecessorIndexToSameBB(?insn, ?prev, ?indexNext) :-
   LargerPredecessorIndexToSameBB(?insn, _, ?prev),
   ?indexNext = min ?index : LargerPredecessorIndexToSameBB(?insn, ?index, ?prev).

NextPredecessorToSameBB(?insn, ?pred, ?nextPred) :-
   NextPredecessorIndexToSameBB(?insn, ?pred, ?indexNext),
   Instruction_Method(?insn, ?method),
   OptInstructionFromMethodIndex(?method, ?indexNext, ?nextPred).

PreviousPredecessorToSameB(?insn, ?nextPred, ?prevPred) :-
   NextPredecessorToSameBB(?insn, ?prevPred, ?nextPred).

ExistsPreviousPredecessorToSameBB(?pred, ?insn) :-
   NextPredecessorToSameBB(?insn, _, ?pred).


// Same concepts as above, but for non-dominated (shortened to "NonDom")
// predecessors
NonDomPredecessorBBsToSameBB(?insn, ?prev1, ?prev2) :-   
   MayPredecessorBBModuloThrow(?prev1, ?insn),
   MayPredecessorBBModuloThrow(?prev2, ?insn),
   BasicBlockTail(?prev1, ?prevTail1),
   BasicBlockTail(?prev2, ?prevTail2),
   !DominatesItsPredecessorInstruction(?prevTail1, ?insn),
   !DominatesItsPredecessorInstruction(?prevTail2, ?insn),
   ?prev1 != ?prev2.

LargerNonDomPredecessorIndexToSameBB(?insn, ?indexLarge, ?prevSmall) :-
   NonDomPredecessorBBsToSameBB(?insn, ?prevLarge, ?prevSmall),
   Instruction_Index(?prevLarge, ?indexLarge),
   Instruction_Index(?prevSmall, ?indexSmall),
   ?indexLarge > ?indexSmall.

.output NextNonDomPredecessorIndexToSameBB
NextNonDomPredecessorIndexToSameBB(?insn, ?prev, ?indexNext) :-
   LargerNonDomPredecessorIndexToSameBB(?insn, _, ?prev),
   ?indexNext = min ?index : LargerNonDomPredecessorIndexToSameBB(?insn, ?index, ?prev).

NextNonDomPredecessorToSameBB(?insn, ?pred, ?nextPred) :-
   NextNonDomPredecessorIndexToSameBB(?insn, ?pred, ?indexNext),
   Instruction_Method(?insn, ?method),
   OptInstructionFromMethodIndex(?method, ?indexNext, ?nextPred).

PreviousNonDomPredecessorToSameBB(?insn, ?nextPred, ?prevPred) :-
   NextNonDomPredecessorToSameBB(?insn, ?prevPred, ?nextPred).

ExistsPreviousNonDomPredecessorToSameBB(?pred, ?insn) :-
   NextNonDomPredecessorToSameBB(?insn, _, ?pred).

.output MayPredecessorBBModuloThrow
.output BasicBlockHead
.output Method_FirstInstruction
.output OptInstructionFromMethodIndex
.output PhiNodeHead
.output Dominates
.output InstructionInPhiNode
.output BasicBlockTail
.output JumpTarget
.output Instruction_Next
.output MaySuccessorBBModuloThrow
.output BasicBlockBegin
.output DominatesItsPredecessorInstruction
.output BBHeadInMethod