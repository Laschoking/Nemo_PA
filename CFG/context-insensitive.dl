.type Modifier = symbol
.decl isModifier(?m:Modifier)

.decl Modifier_abstract(?mod:Modifier)
.decl Modifier_final(?mod:Modifier)
.decl Modifier_public(?mod:Modifier)
.decl Modifier_private(?mod:Modifier)
.decl Modifier_static(?mod:Modifier)


.type Type = symbol
.type PrimitiveType = Type
.type ReferenceType = Type
.type NullType = ReferenceType
.type ArrayType = ReferenceType
.type ClassType = ReferenceType
.type InterfaceType = ReferenceType

.decl isType(?t:Type)
.decl isPrimitiveType(?t:PrimitiveType)
.decl isReferenceType(?t:ReferenceType)
.decl isNullType(?t:ReferenceType)
.decl isArrayType(?t:ArrayType)
.decl isClassType(?t:ClassType)
.decl isInterfaceType(?t:InterfaceType)



.decl DirectSuperclass(?class:ClassType, ?superclass:ClassType)
.decl DirectSuperinterface(?ref:ReferenceType, ?interface:InterfaceType)



.decl ConcreteClass(?ref:ClassType)
.decl MainClass(?class:ClassType)



.decl Type_boolean(?t:PrimitiveType)
.decl Type_byte(?t:PrimitiveType)
.decl Type_char(?t:PrimitiveType)
.decl Type_short(?t:PrimitiveType)
.decl Type_int(?t:PrimitiveType)
.decl Type_long(?t:PrimitiveType)
.decl Type_float(?t:PrimitiveType)
.decl Type_double(?t:PrimitiveType)
.decl Type_void(?t:Type)
.decl Type_null(?t:NullType)
.decl Type_object(?t:ReferenceType)

.decl isIntegerType(?type:Type)

.decl ClassModifier(?mod:Modifier, ?class:ReferenceType)



.type Field = symbol
.decl isField(?field:Field)

.decl Field_DeclaringType(?field:Field, ?declaringClass:ReferenceType)
.decl Field_SimpleName(?field:Field, ?simpleName:symbol)
.decl Field_Type(?field:Field, ?type:Type)
.decl Field_Modifier(?mod:Modifier, ?field:Field)




.type MethodDescriptor = symbol
.decl isMethodDescriptor(?md:MethodDescriptor)

.type Method = symbol
.decl isMethod(?m:Method)

.decl Method_DeclaringType(?method:Method, ?declaringType:ReferenceType)
.decl Method_ReturnType(?method:Method, ?returnType:Type)
.decl Method_SimpleName(?method:Method, ?simpleName:symbol)
.decl Method_ParamTypes(?method:Method, ?params:symbol)
.decl Method_Descriptor(?method:Method, ?descriptor:MethodDescriptor)
.decl Method_Arity(?method:Method, ?arity:number)

.type JVMDescriptor = symbol
.decl isJVMDescriptor(?jvmd:JVMDescriptor)


.decl Method_JVMDescriptor(?method:Method, ?descriptor:JVMDescriptor)

.decl Method_Modifier(?mod:Modifier, ?method:Method)




.decl Method_DeclaresException(?exceptionType:ReferenceType, ?method:Method)

.decl FormalParam(?index:number, ?method:Method, ?var:Var)

.decl ThisVar(?method:Method, ?var:Var)



.type Var = symbol
.decl isVar(v:Var)

.decl Var_Type(?var:Var, ?type:Type)
.decl Var_DeclaringMethod(?var:Var, ?method:Method)
.decl Var_SimpleName(?var:Var, ?simplename:symbol)






.type Value = symbol

.decl isValue(?value:Value)





.type NumConstant = Value

.decl isNumConstant(?n:NumConstant)





.type HeapAllocation = Value
.type NormalHeap = HeapAllocation
.type StringConstant = HeapAllocation
.type ClassHeap = HeapAllocation
.type MethodHandleConstant = HeapAllocation
.type MethodTypeConstant = HeapAllocation

.decl isHeapAllocation(?h:HeapAllocation)
.decl isNormalHeap(?h:NormalHeap)
.decl isStringConstant(?h:StringConstant)
.decl isClassHeap(?h:ClassHeap)
.decl isMethodHandleConstant(?h:MethodHandleConstant)
.decl isMethodTypeConstant(?h:MethodTypeConstant)
.decl isStringRaw(?id:symbol)

.decl HeapAllocation_Type(?heap:HeapAllocation, ?type:ReferenceType)
.decl OriginalHeapAllocation_Type(?heap:HeapAllocation, ?type:ReferenceType)


.decl HeapAllocation_EmptyArray(?heap:HeapAllocation)
.decl HeapAllocation_Null(?null:HeapAllocation)
.decl MainMethodArgArray(?heap:HeapAllocation)
.decl MainMethodArgArrayContent(?heap:HeapAllocation)

.decl ClassHeap_InstanceType(?classHeap:ClassHeap, ?instanceType:ReferenceType)
.decl MethodHandleConstant_Method(?heap:MethodHandleConstant, ?method:Method)
.decl MethodHandleConstant_ReturnType(?heap:MethodHandleConstant, ?retType:Type)
.decl MethodHandleConstant_ParamTypes(?heap:MethodHandleConstant, ?paramTypes:symbol)
.decl MethodHandleConstant_Arity(?heap:MethodHandleConstant, ?arity:number)
.decl MethodTypeConstant_Arity(?heap:MethodTypeConstant, ?arity:number)
.decl MethodTypeConstant_ReturnType(?heap:MethodTypeConstant, ?retType:Type)
.decl MethodTypeConstant_ParamTypes(?heap:MethodTypeConstant, ?paramTypes:symbol)





.type Instruction = symbol
.decl isInstruction(?insn:Instruction)

.decl Instruction_Index(?insn:Instruction, ?index:number)
.decl Instruction_Line(?insn:Instruction, ?index:number)
.decl Instruction_Method(?insn:Instruction, ?inMethod:Method)
.output Instruction_Method

.type Throw_Insn = Instruction
.type ThrowNull_Insn = Throw_Insn
.type Goto_Insn = Instruction
.type If_Insn = Instruction
.type Switch_Insn = Instruction
.type TableSwitch_Insn = Switch_Insn
.type LookupSwitch_Insn = Switch_Insn
.type MonitorInstruction = Instruction
.type EnterMonitor_Insn = MonitorInstruction
.type ExitMonitor_Insn = MonitorInstruction
.type FieldInstruction = Instruction
.type LoadInstanceField_Insn = FieldInstruction
.type StoreInstanceField_Insn = FieldInstruction
.type LoadStaticField_Insn = FieldInstruction
.type StoreStaticField_Insn = FieldInstruction
.type ArrayInstruction = Instruction
.type LoadArrayIndex_Insn = ArrayInstruction
.type StoreArrayIndex_Insn = ArrayInstruction

.decl isThrow_Insn(?insn:Throw_Insn)
.decl isThrowNull_Insn(?insn:ThrowNull_Insn)
.decl isGoto_Insn(?insn:Goto_Insn)
.decl isIf_Insn(?insn:If_Insn)
.decl isSwitch_Insn(?insn:Switch_Insn)
.decl isTableSwitch_Insn(?insn:TableSwitch_Insn)
.decl isLookupSwitch_Insn(?insn:LookupSwitch_Insn)
.decl isMonitorInstruction(?insn:MonitorInstruction)
.decl isEnterMonitor_Insn(?insn:EnterMonitor_Insn)
.decl isExitMonitor_Insn(?insn:ExitMonitor_Insn)
.decl isFieldInstruction(?insn:FieldInstruction)
.decl isLoadInstanceField_Insn(?insn:LoadInstanceField_Insn)
.decl isStoreInstanceField_Insn(?insn:StoreInstanceField_Insn)
.decl isLoadStaticField_Insn(?insn:LoadStaticField_Insn)
.decl isStoreStaticField_Insn(?insn:StoreStaticField_Insn)
.decl isArrayInstruction(?insn:ArrayInstruction)
.decl isLoadArrayIndex_Insn(?insn:LoadArrayIndex_Insn)
.decl isStoreArrayIndex_Insn(?insn:StoreArrayIndex_Insn)

.type AssignInstruction = Instruction
.type AssignOper_Insn = AssignInstruction
.type AssignBinop_Insn = AssignOper_Insn
.type AssignUnop_Insn = AssignOper_Insn
.type AssignLocal_Insn = AssignOper_Insn
.type AssignInstanceOf_Insn = AssignInstruction
.type AssignNull_Insn = AssignInstruction
.type AssignNumConstant_Insn = AssignInstruction
.type AssignCast_Insn = AssignInstruction
.type AssignCastNull_Insn = AssignCast_Insn
.type AssignCastNumConstant_Insn = AssignCast_Insn
.type AssignHeapAllocation_Insn = AssignInstruction
.type ReturnInstruction = Instruction
.type ReturnVoid_Insn = ReturnInstruction
.type ReturnNonvoid_Insn = ReturnInstruction

.decl isAssignInstruction(?insn:AssignInstruction)
.decl isAssignOper_Insn(?insn:AssignOper_Insn)
.decl isAssignBinop_Insn(?insn:AssignBinop_Insn)
.decl isAssignUnop_Insn(?insn:AssignUnop_Insn)
.decl isAssignLocal_Insn(?insn:AssignLocal_Insn)
.decl isAssignInstanceOf_Insn(?insn:AssignInstanceOf_Insn)
.decl isAssignNull_Insn(?insn:AssignNull_Insn)
.decl isAssignNumConstant_Insn(?insn:AssignNumConstant_Insn)
.decl isAssignCast_Insn(?insn:AssignCast_Insn)
.decl isAssignCastNull_Insn(?insn:AssignCastNull_Insn)
.decl isAssignCastNumConstant_Insn(?insn:AssignCastNumConstant_Insn)
.decl isAssignHeapAllocation_Insn(?insn:AssignHeapAllocation_Insn)
.decl isReturnInstruction(?insn:ReturnInstruction)
.decl isReturnVoid_Insn(?insn:ReturnVoid_Insn)
.decl isReturnNonvoid_Insn(?insn:ReturnNonvoid_Insn)

.type MethodInvocation = Instruction
.type VirtualMethodInvocation_Insn = MethodInvocation
.type SpecialMethodInvocation_Insn = MethodInvocation
.type StaticMethodInvocation_Insn = MethodInvocation
.type SuperMethodInvocation_Insn = MethodInvocation
.type DynamicMethodInvocation_Insn = MethodInvocation

.decl isMethodInvocation(?insn:MethodInvocation)
.decl isVirtualMethodInvocation_Insn(?insn:VirtualMethodInvocation_Insn)
.decl isSpecialMethodInvocation_Insn(?insn:SpecialMethodInvocation_Insn)
.decl isStaticMethodInvocation_Insn(?insn:StaticMethodInvocation_Insn)
.decl isSuperMethodInvocation_Insn(?insn:SuperMethodInvocation_Insn)
.decl isDynamicMethodInvocation_Insn(?insn:DynamicMethodInvocation_Insn)

.type UnsupportedInstruction = Instruction
.type AssignPhantomInvoke = UnsupportedInstruction
.type BreakpointStmt = UnsupportedInstruction

.decl isUnsupportedInstruction(?insn:UnsupportedInstruction)
.decl isAssignPhantomInvoke(?insn:AssignPhantomInvoke)
.decl isBreakpointStmt(?insn:BreakpointStmt)



.decl DummyIf_Var(?insn:If_Insn, ?Var:Var)
.decl If_Var(?insn:If_Insn, ?pos:number, ?var:Var)
.decl If_Constant(?insn:If_Insn, ?pos: number, ?cons: NumConstant)
.decl Throw_Var(?insn:Throw_Insn, ?var:Var)
.decl Goto_Target(?insn:Goto_Insn, ?index:number)
.decl If_Target(?insn:If_Insn, ?index:number)
.decl Switch_Key(?insn:Switch_Insn, ?key:Var)
.decl Switch_Target(?insn:Switch_Insn, ?value:number, ?index:number)
.decl Switch_DefaultTarget(?insn:Switch_Insn, ?index:number)
.decl EnterMonitor_Var(?insn:EnterMonitor_Insn, ?var:Var)
.decl ExitMonitor_Var(?insn:ExitMonitor_Insn, ?var:Var)









.decl FieldInstruction_Signature(?insn:FieldInstruction, ?sign:Field)
.decl LoadInstanceField_Base(?insn:LoadInstanceField_Insn, ?var:Var)
.decl LoadInstanceField_To(?insn:LoadInstanceField_Insn, ?var:Var)
.decl StoreInstanceField_From(?insn:StoreInstanceField_Insn, ?var:Var)
.decl StoreInstanceField_Base(?insn:StoreInstanceField_Insn, ?var:Var)
.decl LoadStaticField_To(?insn:LoadStaticField_Insn, ?var:Var)










.decl StoreStaticField_From(?insn:StoreStaticField_Insn, ?var:Var)






.decl ArrayInsnIndex(?insn:Instruction, ?index:Var)
.decl ArrayNumIndex(?insn:Instruction, ?index:number)

.decl ComponentType(?arrayType:ArrayType, ?componentType:Type)

.decl LoadArrayIndex_Base(?insn:LoadArrayIndex_Insn, ?var:Var)
.decl LoadArrayIndex_To(?insn:LoadArrayIndex_Insn, var:Var)

.decl StoreArrayIndex_From(?insn:StoreArrayIndex_Insn, ?var:Var)
.decl StoreArrayIndex_Base(?insn:StoreArrayIndex_Insn, ?var:Var)

.decl ArrayAllocation(?insn:Instruction, ?pos:number, ?sizeVar:Var)







.decl AssignInstruction_To(?insn:AssignInstruction, ?to:Var)


.decl AssignNumConstant_Id(?insn:AssignNumConstant_Insn, ?const:symbol)


.decl AssignCast_From(?insn:AssignCast_Insn, ?from:Var)

.decl AssignCast_Type(?insn:AssignCast_Insn, ?type:Type)


.decl AssignCastNumConstant_Id(?insn:AssignCastNumConstant_Insn, ?const:symbol)


.decl AssignLocal_From(?insn:AssignLocal_Insn, ?from:Var)


.decl AssignInstanceOf_From(?insn:AssignInstanceOf_Insn, ?from:Var)

.decl AssignInstanceOf_Type(?insn:AssignInstanceOf_Insn, ?type:Type)


.decl AssignOper_From(?insn:AssignOper_Insn, ?pos:number, ?from:Var)


.decl AssignOper_FromConstant(?insn:AssignOper_Insn, ?pos: number, ?from:NumConstant)


.decl AssignHeapAllocation_Heap(?insn:AssignHeapAllocation_Insn, ?heap:HeapAllocation)






.decl ReturnNonvoid_Var(?return:ReturnNonvoid_Insn, ?var:Var)







.decl MethodInvocation_Line(?invocation:MethodInvocation, ?line:number)


.decl MethodInvocation_Method(?invocation:MethodInvocation, ?signature:Method)


.decl AssignReturnValue(?invocation:MethodInvocation, ?to:Var)



.decl ActualParam(?index:number, ?invocation:MethodInvocation, ?var:Var)


.decl VirtualMethodInvocation_Base(?invocation:VirtualMethodInvocation_Insn, ?base:Var)
.decl VirtualMethodInvocation_SimpleName(?invocation:MethodInvocation, ?simplename:symbol)
.decl VirtualMethodInvocation_Descriptor(?invocation:MethodInvocation, ?descriptor:MethodDescriptor)


.decl SuperMethodInvocation_Base(?invocation:SuperMethodInvocation_Insn, ?base:Var)
.decl SuperMethodInvocation_SimpleName(?invocation:MethodInvocation, ?simplename:symbol)
.decl SuperMethodInvocation_Descriptor(?invocation:MethodInvocation, ?descriptor:MethodDescriptor)


.decl DynamicMethodInvocation_Bootstrap(?invocation:DynamicMethodInvocation_Insn, ?bootSignature:Method)



.decl DynamicMethodInvocation_DynName(?invocation:DynamicMethodInvocation_Insn, ?dynName:symbol)
.decl DynamicMethodInvocation_DynReturnType(?invocation:DynamicMethodInvocation_Insn, ?dynRetType:Type)
.decl DynamicMethodInvocation_DynParamTypes(?invocation:DynamicMethodInvocation_Insn, ?dynParamTypes:symbol)

.decl DynamicMethodInvocation_DynArity(?invocation:DynamicMethodInvocation_Insn, ?dynArity:number)

.decl DynamicMethodInvocation_HandleTag(?instruction:DynamicMethodInvocation_Insn, ?tag:number)


.decl BootstrapParam(?index:number, ?invocation:DynamicMethodInvocation_Insn, ?var:Var)


.decl StaticMethodInvocation_SimpleName(?invocation:MethodInvocation, ?simplename:symbol)
.decl StaticMethodInvocation_Descriptor(?invocation:MethodInvocation, ?descriptor:MethodDescriptor)


.decl SpecialMethodInvocation_Base(?invocation:SpecialMethodInvocation_Insn, ?base:Var)
.decl SpecialMethodInvocation_SimpleName(?invocation:MethodInvocation, ?simplename:symbol)
.decl SpecialMethodInvocation_Descriptor(?invocation:MethodInvocation, ?descriptor:MethodDescriptor)

.decl MethodInvocation_Base(?invocation:MethodInvocation, ?base:Var)






.type ExceptionHandler = Instruction
.decl isExceptionHandler(?handler:ExceptionHandler)

.decl ExceptionHandler_Method(?handler:ExceptionHandler, ?inmethod:Method)


.decl ExceptionHandler_Index(?handler:ExceptionHandler, ?index:number)
.decl ExceptionHandler_Type(?handler:ExceptionHandler, ?type:Type)


.decl ExceptionHandler_FormalParam(?handler:ExceptionHandler, ?var:Var)


.decl ExceptionHandler_Begin(?handler:ExceptionHandler, ?index:number)



.decl ExceptionHandler_End(?handler:ExceptionHandler, ?index:number)


.decl ExceptionHandler_Previous(?handler:ExceptionHandler, ?previous:ExceptionHandler)


.decl ApplicationClass(?ref:ReferenceType)
.decl ApplicationField(?field:Field)
.decl ApplicationMethod(?method:Method)
.decl ApplicationVar(?var:Var)
.decl ApplicationInvocation(?invocation:MethodInvocation)
.decl ApplicationAllocation(?allocation:HeapAllocation)







.decl Properties(?path:StringConstant, ?key:StringConstant, ?value:StringConstant)


.decl NativeReturnVar(?var:Var, ?method:Method)


.type Annotation = ReferenceType
.decl isAnnotation(?a:Annotation)
.decl Type_Annotation(?type:ReferenceType, ?annotation:Annotation)
.decl Method_Annotation(?method:Method, ?annotation:Annotation)
.decl Field_Annotation(?fld:Field, ?annotation:Annotation)
.decl Param_Annotation(?method:Method, ?index:number, ?annotation:Annotation)
.decl AnnotationElement(?annotationKind:symbol, ?element:symbol, ?parentId:symbol, ?id:symbol, ?name:symbol, ?value1:symbol, ?value2:symbol)


.decl isOpaqueMethod(?m:Method)



.decl Stats_Metrics(order:symbol, msg:symbol, c:number)





.decl MockObject(?value:Value, ?class:ReferenceType)
.output MockObject
.decl MockObjFromOpenProgramEntryPointReceiver(?value:Value)
.decl ExercisedEntryPointMethod(?class:Type, ?method:Method)
.decl MockObjFromOpenProgramEntryPointArg(?value:Value)
.decl UnmockableFormalOfForcedReachableContext(?formal:Var, ?formalType:Type)
.decl Throw(?insn:Throw_Insn, ?var:Var)

.decl LoadInstanceField(?base:Var, ?sig:Field, ?to:Var, ?inmethod:Method)

.decl StoreInstanceField(?from:Var, ?base:Var, ?signature:Field, ?inmethod:Method)

.decl LoadStaticField(?sig:Field, ?to:Var, ?inmethod:Method)

.decl StoreStaticField(?from:Var, ?signature:Field, ?inmethod:Method)

.decl LoadArrayIndex(?base:Var, ?to:Var, ?inmethod:Method)

.decl StoreArrayIndex(?from:Var, ?base:Var, ?inmethod:Method)

.decl AssignCast(?type:Type, ?from:Var, ?to:Var, ?inmethod:Method)

.decl AssignLocal(?from:Var, ?to:Var, ?inmethod:Method)

.decl AssignNull(?to:Var, ?inmethod:Method)

.decl AssignHeapAllocation(?heap:HeapAllocation, ?to:Var, ?inmethod:Method)


.decl ReturnVar(?var:Var, ?method:Method)

.decl VirtualMethodInvocation(?invocation:MethodInvocation, ?signature:Method, ?inmethod:Method)

.decl SuperMethodInvocation(?invocation:MethodInvocation, ?signature:Method, ?inmethod:Method)

.decl StaticMethodInvocation(?invocation:MethodInvocation, ?signature:Method, ?inmethod:Method)


Throw(?insn, ?var) :-
	isThrow_Insn(?insn),
	Throw_Var(?insn, ?var).

LoadInstanceField(?base, ?sig, ?to, ?inmethod) :-
	isLoadInstanceField_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	LoadInstanceField_Base(?insn, ?base),
	FieldInstruction_Signature(?insn, ?sig),
	LoadInstanceField_To(?insn, ?to).

StoreInstanceField(?from, ?base, ?sig, ?inmethod) :-
	isStoreInstanceField_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	StoreInstanceField_From(?insn, ?from),
	StoreInstanceField_Base(?insn, ?base),
	FieldInstruction_Signature(?insn, ?sig).

LoadStaticField(?sig, ?to, ?inmethod) :-
	isLoadStaticField_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	FieldInstruction_Signature(?insn, ?sig),
	LoadStaticField_To(?insn, ?to).

StoreStaticField(?from, ?sig, ?inmethod) :-
	isStoreStaticField_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	StoreStaticField_From(?insn, ?from),
	FieldInstruction_Signature(?insn, ?sig).

LoadArrayIndex(?base, ?to, ?inmethod) :-
	isLoadArrayIndex_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	LoadArrayIndex_Base(?insn, ?base),
	LoadArrayIndex_To(?insn, ?to).

StoreArrayIndex(?from, ?base, ?inmethod) :-
	isStoreArrayIndex_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	StoreArrayIndex_From(?insn, ?from),
	StoreArrayIndex_Base(?insn, ?base).

AssignCast(?type, ?from, ?to, ?inmethod) :-
	isAssignCast_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	AssignCast_From(?insn, ?from),
	AssignInstruction_To(?insn, ?to),
	AssignCast_Type(?insn, ?type).

AssignLocal(?from, ?to, ?inmethod) :-
	isAssignLocal_Insn(?insn),
	AssignInstruction_To(?insn, ?to),
	Instruction_Method(?insn, ?inmethod),
	AssignLocal_From(?insn, ?from).

AssignNull(?to, ?inmethod) :-
	isAssignNull_Insn(?insn),
	AssignInstruction_To(?insn, ?to),
	Instruction_Method(?insn, ?inmethod).

AssignHeapAllocation(?heap, ?to, ?inmethod) :-
	isAssignHeapAllocation_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	AssignHeapAllocation_Heap(?insn, ?heap),
	AssignInstruction_To(?insn, ?to).

ReturnVar(?var, ?method) :-
	isReturnNonvoid_Insn(?insn),
	Instruction_Method(?insn, ?method),
	ReturnNonvoid_Var(?insn, ?var).

ReturnVar(?var, ?method) :-
	NativeReturnVar(?var, ?method).

VirtualMethodInvocation(?invocation, ?signature, ?inmethod) :-
	isVirtualMethodInvocation_Insn(?invocation),
	Instruction_Method(?invocation, ?inmethod),
	MethodInvocation_Method(?invocation, ?signature).

StaticMethodInvocation(?invocation, ?signature, ?inmethod) :-
	isStaticMethodInvocation_Insn(?invocation),
	Instruction_Method(?invocation, ?inmethod),
	MethodInvocation_Method(?invocation, ?signature).

SuperMethodInvocation(?invocation, ?signature, ?inmethod) :-
	isSuperMethodInvocation_Insn(?invocation),
	Instruction_Method(?invocation, ?inmethod),
	MethodInvocation_Method(?invocation, ?signature).

VirtualMethodInvocation_SimpleName(?invocation, ?simplename),
VirtualMethodInvocation_Descriptor(?invocation, ?descriptor) :-
	isVirtualMethodInvocation_Insn(?invocation),
	MethodInvocation_Method(?invocation, ?signature),
	Method_SimpleName(?signature, ?simplename),
	Method_Descriptor(?signature, ?descriptor).

StaticMethodInvocation_SimpleName(?invocation, ?simplename),
StaticMethodInvocation_Descriptor(?invocation, ?descriptor) :-
	isStaticMethodInvocation_Insn(?invocation),
	MethodInvocation_Method(?invocation, ?signature),
	Method_SimpleName(?signature, ?simplename),
	Method_Descriptor(?signature, ?descriptor).

SpecialMethodInvocation_SimpleName(?invocation, ?simplename),
SpecialMethodInvocation_Descriptor(?invocation, ?descriptor) :-
	isSpecialMethodInvocation_Insn(?invocation),
	MethodInvocation_Method(?invocation, ?signature),
	Method_SimpleName(?signature, ?simplename),
	Method_Descriptor(?signature, ?descriptor).

SuperMethodInvocation_SimpleName(?invocation, ?simplename),
SuperMethodInvocation_Descriptor(?invocation, ?descriptor) :-
	isSuperMethodInvocation_Insn(?invocation),
	MethodInvocation_Method(?invocation, ?signature),
	Method_SimpleName(?signature, ?simplename),
	Method_Descriptor(?signature, ?descriptor).

.decl MethodInvocation_SimpleName(?invocation:Instruction, ?simpleName:symbol)

MethodInvocation_SimpleName(?invocation, ?simplename) :-
	VirtualMethodInvocation_SimpleName(?invocation, ?simplename).
MethodInvocation_SimpleName(?invocation, ?simplename) :-
	SpecialMethodInvocation_SimpleName(?invocation, ?simplename).
MethodInvocation_SimpleName(?invocation, ?simplename) :-
	StaticMethodInvocation_SimpleName(?invocation, ?simplename).
MethodInvocation_SimpleName(?invocation, ?simplename) :-
	SuperMethodInvocation_SimpleName(?invocation, ?simplename).

.decl KeepMethod(?m:Method)
.decl KeepClassMembers(?m:Method)
.decl KeepClassesWithMembers(?m:Method)
.decl KeepClass(?c:ReferenceType)
.decl RootCodeElement(?id:symbol)

.input KeepMethod(filename="KeepMethod.facts")
.input KeepClassMembers(filename="KeepClassMembers.facts")
.input KeepClassesWithMembers(filename="KeepClassesWithMembers.facts")
.input KeepClass(filename="KeepClass.facts")
.input RootCodeElement(filename="RootCodeElement.facts")
.type OpaqueInstruction = Instruction

.decl isOpaqueInstruction(?insn:OpaqueInstruction)
.output isOpaqueInstruction



isOpaqueInstruction(?instruction) :-
   _StaticMethodInvocation(?instruction, _, ?signature, _),
   isOpaqueMethod(?signature).
isOpaqueInstruction(?instruction) :-
   _SpecialMethodInvocation(?instruction, _, ?signature, _, _),
   isOpaqueMethod(?signature).
isOpaqueInstruction(?instruction) :-
   _VirtualMethodInvocation(?instruction, _, ?signature, _, _),
   isOpaqueMethod(?signature).
isOpaqueMethod(m) :- isMethod(m), m = "<sun.misc.ProxyGenerator: byte[] generateClassFile()>" .
isType(?t) :- isPrimitiveType(?t) ; isReferenceType(?t).

isReferenceType(?t) :-
  isNullType(?t) ; isArrayType(?t) ; isClassType(?t) ; isInterfaceType(?t) ; isAnnotation(?t).

isHeapAllocation(?h) :-
  isNormalHeap(?h) ; isStringConstant(?h) ; isClassHeap(?h) ; isMethodHandleConstant(?h) ; isMethodTypeConstant(?h).


isInstruction(?i) :-
  isThrow_Insn(?i) ; isGoto_Insn(?i) ; isIf_Insn(?i) ; isSwitch_Insn(?i) ; isMonitorInstruction(?i) ;
  isFieldInstruction(?i) ; isArrayInstruction(?i) ; isAssignInstruction(?i) ;
  isReturnInstruction(?i) ; isMethodInvocation(?i) ; isUnsupportedInstruction(?i).

isThrowNull_Insn(?i) :- isThrow_Insn(?i).

isSwitch_Insn(?i) :- isTableSwitch_Insn(?i) ; isLookupSwitch_Insn(?i).

isMonitorInstruction(?i) :- isEnterMonitor_Insn(?i) ; isExitMonitor_Insn(?i).

isFieldInstruction(?i) :-
  isLoadInstanceField_Insn(?i) ; isStoreInstanceField_Insn(?i) ;
  isLoadStaticField_Insn(?i) ; isStoreStaticField_Insn(?i).

isArrayInstruction(?i) :- isLoadArrayIndex_Insn(?i) ; isStoreArrayIndex_Insn(?i).

isAssignInstruction(?i) :-
  isAssignOper_Insn(?i) ; isAssignInstanceOf_Insn(?i) ; isAssignNull_Insn(?i) ;
  isAssignNumConstant_Insn(?i) ; isAssignCast_Insn(?i) ; isAssignHeapAllocation_Insn(?i).

isAssignOper_Insn(?i) :-
  isAssignBinop_Insn(?i) ; isAssignUnop_Insn(?i) ; isAssignLocal_Insn(?i).

isAssignCast_Insn(?i) :- isAssignCastNumConstant_Insn(?i) ; isAssignCastNull_Insn(?i).

isReturnInstruction(?i) :- isReturnVoid_Insn(?i) ; isReturnNonvoid_Insn(?i).

isMethodInvocation(?i) :-
  isVirtualMethodInvocation_Insn(?i) ; isSpecialMethodInvocation_Insn(?i) ; isStaticMethodInvocation_Insn(?i) ;
  isSuperMethodInvocation_Insn(?i) ; isDynamicMethodInvocation_Insn(?i).

isUnsupportedInstruction(?i) :- isAssignPhantomInvoke(?i) ; isBreakpointStmt(?i).





.decl _ClassType(?class:ClassType)
.input _ClassType(filename="ClassType.facts")

isClassType(?class) :- _ClassType(?class).




.decl _ArrayType(?arrayType:ArrayType)
.input _ArrayType(filename="ArrayType.facts")

isArrayType(?arrayType) :- _ArrayType(?arrayType).




.decl _InterfaceType(?interface:InterfaceType)
.input _InterfaceType(filename="InterfaceType.facts")

isInterfaceType(?interface) :- _InterfaceType(?interface).




.decl _ComponentType(?arrayType:ArrayType, ?componentType:Type)
.input _ComponentType(filename="ComponentType.facts")

isArrayType(?arrayType),
isType(?componentType),
ComponentType(?arrayType, ?componentType) :-
  _ComponentType(?arrayType, ?componentType).




.decl _ActualParam(?index:number, ?invocation:MethodInvocation, ?var:Var)
.input _ActualParam(filename="ActualParam.facts")

isMethodInvocation(?invocation),
isVar(?var),
ActualParam(?index, ?invocation, ?var) :-
  _ActualParam(?index, ?invocation, ?var).



.decl _BootstrapParam(?index:number, ?invocation:MethodInvocation, ?var:Var)
.input _BootstrapParam(filename="BootstrapParam.facts")

isDynamicMethodInvocation_Insn(?invocation),
isVar(?var),
BootstrapParam(?index, ?invocation, ?var) :-
  _BootstrapParam(?index, ?invocation, ?var).



.decl _DirectSuperinterface(?class:ReferenceType, ?interface:InterfaceType)
.input _DirectSuperinterface(filename="DirectSuperinterface.facts")

isReferenceType(?class),
isInterfaceType(?interface),
DirectSuperinterface(?class, ?interface) :-
  _DirectSuperinterface(?class, ?interface).




.decl _DirectSuperclass(?class:ClassType, ?superclass:ClassType)
.input _DirectSuperclass(filename="DirectSuperclass.facts")

isClassType(?class),
isClassType(?superclass),
DirectSuperclass(?class, ?superclass) :-
  _DirectSuperclass(?class, ?superclass).




.decl _Field_Modifier(?modifier:Modifier, ?field:Field)
.input _Field_Modifier(filename="Field-Modifier.facts")

isModifier(?modifier),
isField(?field),
Field_Modifier(?modifier, ?field) :-
  _Field_Modifier(?modifier, ?field).




.decl _ClassModifier(?modifier:Modifier, ?class:ReferenceType)
.input _ClassModifier(filename="ClassModifier.facts")

ClassModifier(?modifier, ?class) :-
  _ClassModifier(?modifier, ?class).




.decl _FormalParam(?index:number, ?method:Method, ?var:Var)
.input _FormalParam(filename="FormalParam.facts")

isMethod(?method),
isVar(?var),
FormalParam(?index, ?method, ?var) :-
  _FormalParam(?index, ?method, ?var).




.decl _Method_DeclaresException(?exceptionType:ReferenceType, ?method:Method)
.input _Method_DeclaresException(filename="Method-DeclaresException.facts")

isReferenceType(?exceptionType),
isMethod(?method),
Method_DeclaresException(?exceptionType, ?method) :-
  _Method_DeclaresException(?exceptionType, ?method).




.decl _Method_Modifier(?mod:Modifier, ?method:Method)
.input _Method_Modifier(filename="Method-Modifier.facts")

isModifier(?mod),
isMethod(?method),
Method_Modifier(?mod, ?method) :-
  _Method_Modifier(?mod, ?method).




.decl _NativeReturnVar(?var:Var, ?method:Method)
.input _NativeReturnVar(filename="NativeReturnVar.facts")

isVar(?var),
isMethod(?method),
NativeReturnVar(?var, ?method) :-
  _NativeReturnVar(?var, ?method).




.decl _Var_Type(?var:Var, ?type:Type)
.input _Var_Type(filename="Var-Type.facts")

isVar(?var),
isType(?type),
Var_Type(?var, ?type) :-
  _Var_Type(?var, ?type).




.decl _Var_DeclaringMethod(?var:Var, ?method:Method)
.input _Var_DeclaringMethod(filename="Var-DeclaringMethod.facts")

isVar(?var),
isMethod(?method),
Var_DeclaringMethod(?var, ?method) :-
  _Var_DeclaringMethod(?var, ?method).




.decl _Var_SimpleName(?var:Var, ?simplename:symbol)
.input _Var_SimpleName(filename="Var-SimpleName.facts")

isVar(?var),
Var_SimpleName(?var, ?simplename) :-
  _Var_SimpleName(?var, ?simplename).




.decl _ApplicationClass(?type:ReferenceType)
.input _ApplicationClass(filename="ApplicationClass.facts")

isReferenceType(?type),
ApplicationClass(?type) :-
  _ApplicationClass(?type).




.decl _ApplicationPackage(?package:symbol)
.input _ApplicationPackage(filename="ApplicationPackage.facts")




.decl _ThisVar(?method:Method, ?var:Var)
.input _ThisVar(filename="ThisVar.facts")

isMethod(?method),
isVar(?var),
ThisVar(?method, ?var) :-
  _ThisVar(?method, ?var).




.decl _ExceptionHandler_Previous(?handler:ExceptionHandler, ?previous:ExceptionHandler)
.input _ExceptionHandler_Previous(filename="ExceptionHandler-Previous.facts")

isExceptionHandler(?handler),
isExceptionHandler(?previous),
ExceptionHandler_Previous(?handler, ?previous) :-
  _ExceptionHandler_Previous(?handler, ?previous).




.decl _AssignReturnValue(?invocation:MethodInvocation, ?to:Var)
.input _AssignReturnValue(filename="AssignReturnValue.facts")

isMethodInvocation(?invocation),
isVar(?to),
AssignReturnValue(?invocation, ?to) :-
  _AssignReturnValue(?invocation, ?to).



.input Properties


.decl _OperatorAt(?instruction:Instruction, ?operator:symbol)
.input _OperatorAt(filename="OperatorAt.facts")


.input MainClass

MainClass(?b):-
  MainClass(?a),
  ?l1 = strlen(?a),
  ?l2 = strlen("Example"),
  ?b = substr(?a, ?l1 - ?l2, ?l2),
  match(".*Example",?a).



.decl _ClassArtifact(?artifact:symbol, ?className:ReferenceType, ?subArtifact:symbol, ?size:number)
.input _ClassArtifact(filename="Class-Artifact.facts")



.decl _NormalHeap(?id:NormalHeap, ?type:ReferenceType)
.input _NormalHeap(filename="NormalHeap.facts")

isType(?type),
isNormalHeap(?id),
OriginalHeapAllocation_Type(?id, ?type),
HeapAllocation_Type(?id, ?type) :-
  _NormalHeap(?id, ?type).

isClassType("java.lang.String").




.decl _StringConstant(?id:StringConstant)
.input _StringConstant(filename="StringConstant.facts")

isStringConstant(?id),
OriginalHeapAllocation_Type(?id, "java.lang.String"),
HeapAllocation_Type(?id, "java.lang.String") :-
  _StringConstant(?id).




.decl _StringRaw(?id:symbol, ?rawId:symbol)
.input _StringRaw(filename="StringRaw.facts")

.decl String_toRaw(?id:symbol, ?rawId:symbol)

isStringRaw(?id),
String_toRaw(?id, ?rawId) :-
  _StringRaw(?id, ?rawId).




.decl _ClassHeap(?id:ClassHeap, ?instanceType:ReferenceType)
.input _ClassHeap(filename="ClassHeap.facts")

isType(?instanceType),
isClassHeap(?id),
ClassHeap_InstanceType(?id, ?instanceType),
OriginalHeapAllocation_Type(?id, "java.lang.Class"),
HeapAllocation_Type(?id, "java.lang.Class") :-
  _ClassHeap(?id, ?instanceType).



.decl _MethodHandleConstant(?id:MethodHandleConstant, ?method:Method, ?retType:Type, ?paramTypes:symbol, ?arity:number)
.input _MethodHandleConstant(filename="MethodHandleConstant.facts")

isType("java.lang.invoke.MethodHandle").
isReferenceType("java.lang.invoke.MethodHandle").
isClassType("java.lang.invoke.MethodHandle").

isMethodHandleConstant(?id),
OriginalHeapAllocation_Type(?id, "java.lang.invoke.MethodHandle"),
MethodHandleConstant_Method(?id, ?method),
MethodHandleConstant_Arity(?id, ?arity),
MethodHandleConstant_ReturnType(?id, ?retType),
MethodHandleConstant_ParamTypes(?id, ?paramTypes),
HeapAllocation_Type(?id, "java.lang.invoke.MethodHandle") :-
  _MethodHandleConstant(?id, ?method, ?retType, ?paramTypes, ?arity).



.decl _MethodTypeConstant(?id:MethodTypeConstant, ?arity:number, ?retType:Type, ?paramTypes:symbol)
.input _MethodTypeConstant(filename="MethodTypeConstant.facts")

isMethodTypeConstant(?id),
HeapAllocation_Type(?id, "java.lang.invoke.MethodType"),
MethodTypeConstant_Arity(?id, ?arity),
MethodTypeConstant_ReturnType(?id, ?retType),
MethodTypeConstant_ParamTypes(?id, ?paramTypes),
OriginalHeapAllocation_Type(?id, "java.lang.invoke.MethodType") :-
  _MethodTypeConstant(?id, ?arity, ?retType, ?paramTypes).

.decl _MethodTypeConstantParam(?id:MethodTypeConstant, ?idx:number, ?type:Type)
.input _MethodTypeConstantParam(filename="MethodTypeConstantParam.facts")



.decl _NativeLibEntryPoint(?lib:symbol, ?function:symbol, ?addr:symbol)
.input _NativeLibEntryPoint(filename="NativeLibEntryPoint.facts")

.decl _NativeMethodTypeCandidate(?lib:symbol, ?function:symbol, ?descriptor:symbol, ?offset2:number)
.input _NativeMethodTypeCandidate(filename="NativeMethodTypeCandidate.facts")

.decl _NativeNameCandidate(?lib:symbol, ?function:symbol, ?name:symbol, ?offset1:number)
.input _NativeNameCandidate(filename="NativeNameCandidate.facts")

.decl _NativeMethodId(?javaMethod:Method, ?nativeId:symbol)
.input _NativeMethodId(filename="NativeMethodId.facts")

.decl _NativeXRef(?string:symbol, ?lib:symbol, ?function:symbol, ?dataAddr:number)
.input _NativeXRef(filename="NativeXRef.facts")



.decl _EmptyArray(?id:HeapAllocation)
.input _EmptyArray(filename="EmptyArray.facts")

HeapAllocation_EmptyArray(?id) :-
  _EmptyArray(?id).



.decl _ArrayAllocation(?instruction:Instruction, ?pos:number, ?sizeVar:Var)
.input _ArrayAllocation(filename="ArrayAllocation.facts")

ArrayAllocation(?insn, ?pos, ?sizeVar) :-
  _ArrayAllocation(?insn, ?pos, ?sizeVar).




.decl _AssignHeapAllocation(?instruction:AssignHeapAllocation_Insn, ?index:number, ?heap:HeapAllocation, ?to:Var, ?inmethod:Method, ?linenumber:number)
.input _AssignHeapAllocation(filename="AssignHeapAllocation.facts")

isAssignHeapAllocation_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Line(?instruction, ?linenumber),
Instruction_Method(?instruction, ?method),
AssignInstruction_To(?instruction, ?to),
AssignHeapAllocation_Heap(?instruction, ?heap) :-
  _AssignHeapAllocation(?instruction, ?index, ?heap, ?to, ?method, ?linenumber).




.decl _AssignLocal(?instruction:AssignLocal_Insn, ?index:number, ?from:Var, ?to:Var, ?inmethod:Method)
.input _AssignLocal(filename="AssignLocal.facts")

isAssignLocal_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignLocal_From(?instruction, ?from),
AssignInstruction_To(?instruction, ?to) :-
  _AssignLocal(?instruction, ?index, ?from, ?to, ?method).




.decl _AssignBinop(?instruction:AssignBinop_Insn, ?index:number, ?to:Var, ?inmethod:Method)
.input _AssignBinop(filename="AssignBinop.facts")

isAssignBinop_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignInstruction_To(?instruction, ?to) :-
  _AssignBinop(?instruction, ?index, ?to, ?method).




.decl _AssignUnop(?instruction:AssignUnop_Insn, ?index:number, ?to:Var, ?inmethod:Method)
.input _AssignUnop(filename="AssignUnop.facts")

isAssignUnop_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignInstruction_To(?instruction, ?to) :-
  _AssignUnop(?instruction, ?index, ?to, ?method).




.decl _AssignOperFrom(?instruction:AssignOper_Insn, ?pos: number, ?from:Var)
.input _AssignOperFrom(filename="AssignOperFrom.facts")

AssignOper_From(?instruction, ?pos, ?from) :-
  _AssignOperFrom(?instruction, ?pos, ?from).



.decl _AssignOperFromConstant(?instruction:AssignOper_Insn, ?pos: number, ?from:NumConstant)
.input _AssignOperFromConstant(filename="AssignOperFromConstant.facts")

AssignOper_FromConstant(?instruction, ?pos, ?from) :-
  _AssignOperFromConstant(?instruction, ?pos, ?from).



.decl _IfConstant(?instruction:If_Insn, ?pos:number, ?cons:NumConstant)
.input _IfConstant(filename="IfConstant.facts")

If_Constant(?instruction, ?pos, ?cons) :-
  _IfConstant(?instruction, ?pos, ?cons).




.decl _IfVar(?instruction:If_Insn, ?pos:number, ?var:Var)
.input _IfVar(filename="IfVar.facts")

If_Var(?instruction, ?pos, ?var) :-
  _IfVar(?instruction, ?pos, ?var).



.decl _DummyIfVar(?instruction:If_Insn, ?var:Var)
.input _DummyIfVar(filename="DummyIfVar.facts")

DummyIf_Var(?instruction, ?var) :-
  _DummyIfVar(?instruction, ?var).



.decl _AssignCast(?instruction:AssignCast_Insn, ?index:number, ?from:Var, ?to:Var, ?type:Type, ?inmethod:Method)
.input _AssignCast(filename="AssignCast.facts")

isAssignCast_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignCast_Type(?instruction, ?type),
AssignCast_From(?instruction, ?from),
AssignInstruction_To(?instruction, ?to) :-
  _AssignCast(?instruction, ?index, ?from, ?to, ?type, ?method).




.decl _AssignCastNumConstant(?instruction:AssignCastNumConstant_Insn, ?index:number, ?const:symbol, ?to:Var, ?type:Type, ?inmethod:Method)
.input _AssignCastNumConstant(filename="AssignCastNumConstant.facts")

isAssignCastNumConstant_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignCast_Type(?instruction, ?type),
AssignCastNumConstant_Id(?instruction, ?const),
AssignInstruction_To(?instruction, ?to) :-
  _AssignCastNumConstant(?instruction, ?index, ?const, ?to, ?type, ?method).




.decl _AssignCastNull(?instruction:AssignCastNull_Insn, ?index:number, ?to:Var, ?type:Type, ?method:Method)
.input _AssignCastNull(filename="AssignCastNull.facts")

isAssignCastNull_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignCast_Type(?instruction, ?type),
AssignInstruction_To(?instruction, ?to) :-
  _AssignCastNull(?instruction, ?index, ?to, ?type, ?method).




.decl _AssignNumConstant(?instruction:AssignNumConstant_Insn, ?index:number, ?const:NumConstant, ?to:Var, ?inmethod:Method)
.input _AssignNumConstant(filename="AssignNumConstant.facts")

isNumConstant(?const),
isAssignNumConstant_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignNumConstant_Id(?instruction, ?const),
AssignInstruction_To(?instruction, ?to) :-
  _AssignNumConstant(?instruction, ?index, ?const, ?to, ?method).




.decl _AssignNull(?instruction:AssignNull_Insn, ?index:number, ?to:Var, ?method:Method)
.input _AssignNull(filename="AssignNull.facts")

isAssignNull_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignInstruction_To(?instruction, ?to) :-
  _AssignNull(?instruction, ?index, ?to, ?method).




.decl _AssignInstanceOf(?instruction:AssignInstanceOf_Insn, ?index:number, ?from:Var, ?to:Var, ?type:Type, ?inmethod:Method)
.input _AssignInstanceOf(filename="AssignInstanceOf.facts")

isAssignInstanceOf_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignInstanceOf_From(?instruction, ?from),
AssignInstanceOf_Type(?instruction, ?type),
AssignInstruction_To(?instruction, ?to) :-
  _AssignInstanceOf(?instruction, ?index, ?from, ?to, ?type, ?method).




.decl _Field(?signature:Field, ?declaringClass:ReferenceType, ?simplename:symbol, ?type:Type)
.input _Field(filename="Field.facts")

isField(?signature),
Field_DeclaringType(?signature, ?declaringType),
Field_SimpleName(?signature, ?simplename),
Field_Type(?signature, ?type) :-
  _Field(?signature, ?declaringType, ?simplename, ?type).



.decl _EnterMonitor(?instruction:EnterMonitor_Insn, ?index:number, ?var:Var, ?method:Method)
.input _EnterMonitor(filename="EnterMonitor.facts")

isEnterMonitor_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
EnterMonitor_Var(?instruction, ?var) :-
  _EnterMonitor(?instruction, ?index, ?var, ?method).




.decl _ExitMonitor(?instruction:ExitMonitor_Insn, ?index:number, ?var:Var, ?method:Method)
.input _ExitMonitor(filename="ExitMonitor.facts")

isExitMonitor_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
ExitMonitor_Var(?instruction, ?var) :-
  _ExitMonitor(?instruction, ?index, ?var, ?method).




.decl _MethodInvocation_Line(?instruction:MethodInvocation, line:number)
.input _MethodInvocation_Line(filename="MethodInvocation-Line.facts")

isMethodInvocation(?instruction),
MethodInvocation_Line(?instruction, ?line) :-
  _MethodInvocation_Line(?instruction, ?line).

MethodInvocation_Base(?invocation, ?base) :-
  VirtualMethodInvocation_Base(?invocation, ?base).
MethodInvocation_Base(?invocation, ?base) :-
  SpecialMethodInvocation_Base(?invocation, ?base).




.decl _StaticMethodInvocation(?instruction:StaticMethodInvocation_Insn, ?index:number, ?signature:Method, ?method:Method)
.input _StaticMethodInvocation(filename="StaticMethodInvocation.facts")

isMethod(?signature),
isMethodInvocation(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
MethodInvocation_Method(?instruction, ?signature) :-
  _StaticMethodInvocation(?instruction, ?index, ?signature, ?method).

isStaticMethodInvocation_Insn(?instruction) :-
  _StaticMethodInvocation(?instruction, _, ?signature, _),
  !isOpaqueMethod(?signature).



.decl _SpecialMethodInvocation(?instruction:SpecialMethodInvocation_Insn, ?index:number, ?signature:Method, ?base:Var, ?method:Method)
.input _SpecialMethodInvocation(filename="SpecialMethodInvocation.facts")

isMethod(?signature),
isMethodInvocation(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
MethodInvocation_Method(?instruction, ?signature) :-
  _SpecialMethodInvocation(?instruction, ?index, ?signature, _, ?method).

isSpecialMethodInvocation_Insn(?instruction),
SpecialMethodInvocation_Base(?instruction, ?base) :-
  _SpecialMethodInvocation(?instruction, _, ?signature, ?base, _),
  !isOpaqueMethod(?signature).



.decl _VirtualMethodInvocation(?instruction:VirtualMethodInvocation_Insn, ?index:number, ?signature:Method, ?base:Var, ?method:Method)
.input _VirtualMethodInvocation(filename="VirtualMethodInvocation.facts")

isMethod(?signature),
isMethodInvocation(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
MethodInvocation_Method(?instruction, ?signature) :-
  _VirtualMethodInvocation(?instruction, ?index, ?signature, _, ?method).

isVirtualMethodInvocation_Insn(?instruction),
VirtualMethodInvocation_Base(?instruction, ?base) :-
  _VirtualMethodInvocation(?instruction, _, ?signature, ?base, _),
  !isOpaqueMethod(?signature).



.decl _SuperMethodInvocation(?instruction:SuperMethodInvocation_Insn, ?index:number, ?signature:Method, ?base:Var, ?method:Method)
.input _SuperMethodInvocation(filename="SuperMethodInvocation.facts")

isMethod(?signature),
isMethodInvocation(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
MethodInvocation_Method(?instruction, ?signature),
isSuperMethodInvocation_Insn(?instruction),
SuperMethodInvocation_Base(?instruction, ?base) :-
  _SuperMethodInvocation(?instruction, ?index, ?signature, ?base, ?method).



.decl _DynamicMethodInvocation(?instruction:DynamicMethodInvocation_Insn, ?index:number, ?bootSignature:Method, ?dynName:symbol, ?dynRetType:Type, ?dynArity:number, ?dynParamTypes:symbol, ?tag:number, ?method:Method)
.input _DynamicMethodInvocation(filename="DynamicMethodInvocation.facts")

isDynamicMethodInvocation_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
DynamicMethodInvocation_Bootstrap(?instruction, ?bootSignature),
DynamicMethodInvocation_DynName(?instruction, ?dynName),
DynamicMethodInvocation_DynReturnType(?instruction, ?dynRetType),
DynamicMethodInvocation_DynParamTypes(?instruction, ?dynParamTypes),
DynamicMethodInvocation_HandleTag(?instruction, ?tag),
DynamicMethodInvocation_DynArity(?instruction, ?dynArity) :-
  _DynamicMethodInvocation(?instruction, ?index, ?bootSignature, ?dynName, ?dynRetType, ?dynArity, ?dynParamTypes, ?tag, ?method).

.decl _DynamicMethodInvocation_DynParamType(?invocation:DynamicMethodInvocation_Insn, ?idx:number, ?pType:Type)
.input _DynamicMethodInvocation_DynParamType(filename="DynamicMethodInvocation-ParamType.facts")




.decl _PolymorphicInvocation(?invocation:MethodInvocation, ?simpleName:symbol)
.input _PolymorphicInvocation(filename="PolymorphicInvocation.facts")



.decl _Throw(?instruction:Throw_Insn, ?index:number, ?var:Var, ?method:Method)
.input _Throw(filename="Throw.facts")

isThrow_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
Throw(?instruction, ?var),
Throw_Var(?instruction, ?var) :-
  _Throw(?instruction, ?index, ?var, ?method).




.decl _ThrowNull(?instruction:ThrowNull_Insn, ?index:number, ?method:Method)
.input _ThrowNull(filename="ThrowNull.facts")

isThrowNull_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method) :-
  _ThrowNull(?instruction, ?index, ?method).




.decl _ExceptionHandler(?handler:ExceptionHandler, ?method:Method, ?index:number, ?type:ReferenceType, ?begin:number, ?end:number)
.input _ExceptionHandler(filename="ExceptionHandler.facts")

isExceptionHandler(?handler),
isInstruction(?handler),
Instruction_Index(?handler, ?index),
Instruction_Method(?handler, ?method),
ExceptionHandler_Method(?handler, ?method),
ExceptionHandler_Index(?handler, ?index),
ExceptionHandler_Type(?handler, ?type),
ExceptionHandler_Begin(?handler, ?begin),
ExceptionHandler_End(?handler, ?end) :-
  _ExceptionHandler(?handler, ?method, ?index, ?type, ?begin, ?end).

.input ExceptionHandler_FormalParam(filename="ExceptionHandler-FormalParam.facts")



.decl _Method(?method:Method, ?simplename:symbol, ?descriptor:symbol, ?declaringType:ReferenceType, ?returnType:Type, ?jvmDescriptor:JVMDescriptor, ?arity:number)
.input _Method(filename="Method.facts")

isMethod(?method),
isJVMDescriptor(?jvmDescriptor),
Method_SimpleName(?method, ?simplename),
Method_ParamTypes(?method, ?params),
Method_DeclaringType(?method, ?declaringType),
Method_JVMDescriptor(?method, ?jvmDescriptor),
Method_Arity(?method, ?arity),
Method_ReturnType(?method, ?returnType) :-
  _Method(?method, ?simplename, ?params, ?declaringType, ?returnType, ?jvmDescriptor, ?arity).

isMethodDescriptor(?descriptor),
Method_Descriptor(?method, ?descriptor) :-
  Method_ReturnType(?method, ?returnType),
  Method_ParamTypes(?method, ?params),
  ?descriptor = cat(?returnType, cat("(", cat(?params, ")"))).



.decl _StoreInstanceField(?instruction:StoreInstanceField_Insn, ?index:number, ?from:Var, ?base:Var, ?signature:Field, ?method:Method)
.input _StoreInstanceField(filename="StoreInstanceField.facts")

isStoreInstanceField_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
FieldInstruction_Signature(?instruction, ?signature),
StoreInstanceField_Base(?instruction, ?base),
StoreInstanceField_From(?instruction, ?from) :-
  _StoreInstanceField(?instruction, ?index, ?from, ?base, ?signature, ?method).




.decl _LoadInstanceField(?instruction:LoadInstanceField_Insn, ?index:number, ?to:Var, ?base:Var, ?signature:Field, ?method:Method)
.input _LoadInstanceField(filename="LoadInstanceField.facts")

isLoadInstanceField_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
FieldInstruction_Signature(?instruction, ?signature),
LoadInstanceField_Base(?instruction, ?base),
LoadInstanceField_To(?instruction, ?to) :-
  _LoadInstanceField(?instruction, ?index, ?to, ?base, ?signature, ?method).




.decl _StoreStaticField(?instruction:StoreStaticField_Insn, ?index:number, ?from:Var, ?signature:Field, ?method:Method)
.input _StoreStaticField(filename="StoreStaticField.facts")

isStoreStaticField_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
FieldInstruction_Signature(?instruction, ?signature),
StoreStaticField_From(?instruction, ?from) :-
  _StoreStaticField(?instruction, ?index, ?from, ?signature, ?method).




.decl _LoadStaticField(?instruction:LoadStaticField_Insn, ?index:number, ?to:Var, ?signature:Field, ?method:Method)
.input _LoadStaticField(filename="LoadStaticField.facts")

isLoadStaticField_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
FieldInstruction_Signature(?instruction, ?signature),
LoadStaticField_To(?instruction, ?to) :-
  _LoadStaticField(?instruction, ?index, ?to, ?signature, ?method).




.decl _StoreArrayIndex(?instruction:StoreArrayIndex_Insn, ?index:number, ?from:Var, ?base:Var, ?method:Method)
.input _StoreArrayIndex(filename="StoreArrayIndex.facts")

isStoreArrayIndex_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
StoreArrayIndex_Base(?instruction, ?base),
StoreArrayIndex_From(?instruction, ?from) :-
  _StoreArrayIndex(?instruction, ?index, ?from, ?base, ?method).




.decl _LoadArrayIndex(?instruction:LoadArrayIndex_Insn, ?index:number, ?to:Var, ?base:Var, ?method:Method)
.input _LoadArrayIndex(filename="LoadArrayIndex.facts")

isLoadArrayIndex_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
LoadArrayIndex_Base(?instruction, ?base),
LoadArrayIndex_To(?instruction, ?to) :-
  _LoadArrayIndex(?instruction, ?index, ?to, ?base, ?method).




.decl _ArrayInsnIndex(?instruction:Instruction, ?index:Var)
.input _ArrayInsnIndex(filename="ArrayInsnIndex.facts")

ArrayInsnIndex(?instruction, ?index) :-
  _ArrayInsnIndex(?instruction, ?index).




.decl _ArrayNumIndex(?instruction:Instruction, ?index:number)
.input _ArrayNumIndex(filename="ArrayNumIndex.facts")

ArrayNumIndex(?instruction, ?index) :-
  _ArrayNumIndex(?instruction, ?index).




.decl _Goto(?instruction:Goto_Insn, ?index:number, ?to:number, ?method:Method)
.input _Goto(filename="Goto.facts")

isGoto_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
Goto_Target(?instruction, ?to) :-
  _Goto(?instruction, ?index, ?to, ?method).




.decl _If(?instruction:If_Insn, ?index:number, ?to:number, ?method:Method)
.input _If(filename="If.facts")

isIf_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
If_Target(?instruction, ?to) :-
  _If(?instruction, ?index, ?to, ?method).




.decl _TableSwitch(?instruction:TableSwitch_Insn, ?index:number, ?key:Var, ?method:Method)
.input _TableSwitch(filename="TableSwitch.facts")

isTableSwitch_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
Switch_Key(?instruction, ?key) :-
  _TableSwitch(?instruction, ?index, ?key, ?method).


.decl _LookupSwitch(?instruction:LookupSwitch_Insn, ?index:number, ?key:Var, ?method:Method)
.input _LookupSwitch(filename="LookupSwitch.facts")

isLookupSwitch_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
Switch_Key(?instruction, ?key) :-
  _LookupSwitch(?instruction, ?index, ?key, ?method).




.decl _TableSwitch_Target(?instruction:Switch_Insn, ?value:number, ?target:number)
.input _TableSwitch_Target(filename="TableSwitch-Target.facts")

Switch_Target(?instruction, ?value, ?target) :-
  _TableSwitch_Target(?instruction, ?value, ?target).


.decl _LookupSwitch_Target(?instruction:Switch_Insn, ?value:number, ?target:number)
.input _LookupSwitch_Target(filename="LookupSwitch-Target.facts")

Switch_Target(?instruction, ?value, ?target) :-
  _LookupSwitch_Target(?instruction, ?value, ?target).



.decl _TableSwitch_DefaultTarget(?instruction:Switch_Insn, ?target:number)
.input _TableSwitch_DefaultTarget(filename="TableSwitch-Default.facts")

Switch_DefaultTarget(?instruction, ?target) :-
  _TableSwitch_DefaultTarget(?instruction, ?target).


.decl _LookupSwitch_DefaultTarget(?instruction:Switch_Insn, ?target:number)
.input _LookupSwitch_DefaultTarget(filename="LookupSwitch-Default.facts")

Switch_DefaultTarget(?instruction, ?target) :-
  _LookupSwitch_DefaultTarget(?instruction, ?target).




.decl _Return(?instruction:ReturnNonvoid_Insn, ?index:number, ?var:Var, ?method:Method)
.input _Return(filename="Return.facts")

isReturnNonvoid_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
ReturnNonvoid_Var(?instruction, ?var) :-
  _Return(?instruction, ?index, ?var, ?method).




.decl _ReturnVoid(?instruction:ReturnVoid_Insn, ?index:number, ?method:Method)
.input _ReturnVoid(filename="ReturnVoid.facts")

isReturnVoid_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method) :-
  _ReturnVoid(?instruction, ?index, ?method).




.decl _AssignPhantomInvoke(?instruction:AssignPhantomInvoke, ?index:number, ?method:Method)
.input _AssignPhantomInvoke(filename="AssignPhantomInvoke.facts")

isAssignPhantomInvoke(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method) :-
  _AssignPhantomInvoke(?instruction, ?index, ?method).




.decl _BreakpointStmt(?instruction:BreakpointStmt, ?index:number, ?method:Method)
.input _BreakpointStmt(filename="BreakpointStmt.facts")

isBreakpointStmt(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method) :-
  _BreakpointStmt(?instruction, ?index, ?method).




.decl _UnsupportedInstruction(?instruction:UnsupportedInstruction, ?index:number, ?method:Method)
.input _UnsupportedInstruction(filename="UnsupportedInstruction.facts")

isUnsupportedInstruction(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method) :-
  _UnsupportedInstruction(?instruction, ?index, ?method).




isModifier(?x), Modifier_abstract(?x) :- ?x = "abstract".
isModifier(?x), Modifier_public(?x) :- ?x = "public".
isModifier(?x), Modifier_private(?x) :- ?x = "private".
isModifier(?x), Modifier_final(?x) :- ?x = "final".
isModifier(?x), Modifier_static(?x) :- ?x = "static".




isPrimitiveType(?t), Type_boolean(?t) :- ?t = "boolean".
isPrimitiveType(?t), Type_byte(?t) :- ?t = "byte".
isPrimitiveType(?t), Type_char(?t) :- ?t = "char".
isPrimitiveType(?t), Type_short(?t) :- ?t = "short".
isPrimitiveType(?t), Type_int(?t) :- ?t = "int".
isPrimitiveType(?t), Type_long(?t) :- ?t = "long".
isPrimitiveType(?t), Type_float(?t) :- ?t = "float".
isPrimitiveType(?t), Type_double(?t) :- ?t = "double".
isPrimitiveType(?t), Type_void(?t) :- ?t = "void".

isNullType(?t), Type_null(?t) :- ?t = "null_type".

isClassType(?t), Type_object(?t) :- ?t = "java.lang.Object".




.input Type_Annotation(filename="Type-Annotation.facts")

.input Method_Annotation(filename="Method-Annotation.facts")

.input Field_Annotation(filename="Field-Annotation.facts")

.input Param_Annotation(filename="Param-Annotation.facts")

isAnnotation(?annotation) :- isReferenceType(?annotation), Type_Annotation(_, ?annotation).
isAnnotation(?annotation) :- isReferenceType(?annotation), Method_Annotation(_, ?annotation).
isAnnotation(?annotation) :- isReferenceType(?annotation), Field_Annotation(_, ?annotation).
isAnnotation(?annotation) :- isReferenceType(?annotation), Param_Annotation(_, _, ?annotation).


.input AnnotationElement(filename="AnnotationElement.facts")


.decl PhantomType(?t:ReferenceType)
.input PhantomType(filename="PhantomType.facts")
.decl PhantomMethod(?m:Method)
.input PhantomMethod(filename="PhantomMethod.facts")
.decl PhantomBasedMethod(?m:Method)
.input PhantomBasedMethod(filename="PhantomBasedMethod.facts")


isHeapAllocation(?heap), isMethodHandleConstant(?heap), MethodHandleConstant_Method(?heap, ?method), HeapAllocation_Type(?heap, "java.lang.invoke.MethodHandle")  :-
  MethodHandleConstant_Method(?heap, ?method).

isHeapAllocation(?null), HeapAllocation_Type(?null, ?type) ,
HeapAllocation_Null(?null) :-
  ?null = "<<null pseudo heap>>",
  Type_null(?type).

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type) ,
MainMethodArgArray(?heap) :-
  ?heap = "<<main method array>>",
  ?type = "java.lang.String[]".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type) ,
MainMethodArgArrayContent(?heap) :-
  ?heap = "<<main method array content>>",
  ?type = "java.lang.String".

ApplicationField(?field) :-
  Field_DeclaringType(?field, ?type),
  ApplicationClass(?type).

ApplicationMethod(?method) :-
  Method_DeclaringType(?method, ?class),
  ApplicationClass(?class).

ApplicationVar(?var) :-
  Var_DeclaringMethod(?var, ?method),
  ApplicationMethod(?method).

ApplicationInvocation(?invocation) :-
  isMethodInvocation(?invocation),
  Instruction_Method(?invocation, ?method),
  ApplicationMethod(?method).

ApplicationAllocation(?heap) :-
  isAssignHeapAllocation_Insn(?insn),
  Instruction_Method(?insn, ?method),
  ApplicationMethod(?method),
  AssignHeapAllocation_Heap(?insn, ?heap).

ConcreteClass(?class) :-
  isClassType(?class),
  !ClassModifier("abstract", ?class).
isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>/new java.lang.String[]/0",
  ?type = "java.lang.String[]".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>/new java.lang.String/0",
  ?type = "java.lang.String".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<sun.misc.Perf: java.nio.ByteBuffer createLong(java.lang.String,int,int,long)>/new java.nio.DirectByteBuffer/0",
  ?type = "java.nio.DirectByteBuffer".


isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<string-constant>>",
  ?type = "java.lang.String".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<reflection-string-constant>>",
  ?type = "java.lang.String".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<string-buffer>>",
  ?type = "java.lang.StringBuffer".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<string-builder>>",
  ?type = "java.lang.StringBuilder".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<system-thread-group>>",
  ?type = "java.lang.ThreadGroup".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<main-thread-group>>",
  ?type = "java.lang.ThreadGroup".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<main-thread>>",
  ?type = "java.lang.Thread".





isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<initial-context>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<jvm-startup-context>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<jvm-startup-hcontext>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<clinit-context>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<immutable-context>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<immutable-hcontext>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<immutable>>",
  ?type = "java.lang.Object".



.decl CreateIntValue(?n:symbol, ?type:Type, ?declaringType:ReferenceType)

.decl NumConstantRaw(?const:symbol, ?type:Type)
.input NumConstantRaw(filename="NumConstantRaw.facts")


.decl XMLNode(?file:symbol, ?nodeId:symbol, ?parentNodeId:symbol, ?namespaceURI:symbol, ?localName:symbol, ?qName:symbol)
.input XMLNode(filename="XMLNode.facts")
.decl XMLNodeAttribute(?file:symbol, ?nodeId:symbol, ?index:symbol, ?localName:symbol, ?qName:symbol, ?value:symbol)
.input XMLNodeAttribute(filename="XMLNodeAttribute.facts")
.decl XMLNodeData(?file:symbol, ?nodeId:symbol, ?data:symbol)
.input XMLNodeData(filename="XMLNodeData.facts")


.output Instruction_Method
.output Goto_Target
.output If_Target
.output ExceptionHandler_Index
.output ExceptionHandler_Method
.output isIf_Insn
.output isThrow_Insn
.output isGoto_Insn
.output isSwitch_Insn
.output AssignInstruction_To
.output isAssignLocal_Insn
.output isReturnInstruction
.output isInstruction
.output Instruction_Index

.comp Basic {
.decl ExceptionHandler_InRange(?handler:ExceptionHandler, ?instruction:Instruction)
.decl ExceptionHandler_Before(?before:ExceptionHandler, ?handler:ExceptionHandler)

.decl ExceptionHandler_SameInsn_Repr(?insn:Instruction, ?repr:ExceptionHandler)
.decl ExceptionHandler_SameInsn_PartialOrder(?h1:ExceptionHandler, ?h2:ExceptionHandler, ?insn:Instruction)
.decl ExceptionHandler_SameBlock_Repr(?handler:ExceptionHandler, ?repr:ExceptionHandler)
.decl ExceptionHandler_SameBlock_PartialOrder(?repr:ExceptionHandler, ?handler:ExceptionHandler)
.decl ExceptionHandler_TypeIsCaught(?type:Type, ?block:ExceptionHandler)
.decl ExceptionHandler_Impossible(?type:Type, ?h2:ExceptionHandler, ?insn:Instruction)
ExceptionHandler_TypeIsCaught(?type, ?block) :-
	ExceptionHandler_InRange(?handler, ?insn),
	ExceptionHandler_SameInsn_Repr(?insn, ?repr),
	ExceptionHandler_SameBlock_Repr(?repr, ?block),
	ExceptionHandler_Type(?handler, ?handlerType),
	basic.SubtypeOf(?type, ?handlerType),
	ConcreteClass(?type).
ExceptionHandler_Impossible(?type, ?h2, ?insn) :-
	ExceptionHandler_InRange(?h1, ?insn),
	ExceptionHandler_InRange(?h2, ?insn),
	ExceptionHandler_Before(?h1, ?h2),
	ExceptionHandler_Type(?h1, ?h1Type),
	ExceptionHandler_Type(?h2, ?h2Type),
	basic.SubtypeOf(?type, ?h1Type),
	basic.SubtypeOf(?type, ?h2Type),
	ConcreteClass(?type).
ExceptionHandler_InRange(?handler, ?instruction) :-
	ExceptionHandler_Method(?handler, ?method),
	Instruction_Method(?instruction, ?method),
	Instruction_Index(?instruction, ?index),
	ExceptionHandler_Begin(?handler, ?beginIndex),
	?beginIndex <= ?index,
	ExceptionHandler_End(?handler, ?endIndex),
	?endIndex > ?index.

ExceptionHandler_Before(?previous, ?handler) :-
	ExceptionHandler_Previous(?handler, ?previous).

ExceptionHandler_Before(?before, ?handler) :-
	ExceptionHandler_Before(?middle, ?handler),
	ExceptionHandler_Previous(?middle, ?before).
ExceptionHandler_SameInsn_PartialOrder(?h1, ?h2, ?insn) :-
	ExceptionHandler_InRange(?h1, ?insn),
	ExceptionHandler_InRange(?h2, ?insn),
	ExceptionHandler_Before(?h1, ?h2).

ExceptionHandler_SameInsn_Repr(?insn, ?handler) :-
	ExceptionHandler_InRange(?handler, ?insn),
	!ExceptionHandler_SameInsn_PartialOrder(_, ?handler, ?insn).
ExceptionHandler_SameBlock_PartialOrder(?h1, ?h2) :-
	ExceptionHandler_Before(?h1, ?h2),
	ExceptionHandler_Index(?h1, ?h1Index),
	ExceptionHandler_Index(?h2, ?h2Index),
	?h1Index = ?h2Index.

ExceptionHandler_SameBlock_Repr(?handler, ?handler) :-
	isExceptionHandler(?handler),
	!ExceptionHandler_SameBlock_PartialOrder(_, ?handler).

ExceptionHandler_SameBlock_Repr(?handler, ?repr) :-
	ExceptionHandler_SameBlock_PartialOrder(?repr, ?handler),
	!ExceptionHandler_SameBlock_PartialOrder(_, ?repr).
.decl AllocatedObjectSupportsFinalize(?heap:HeapAllocation, ?inmethod:Method)
.decl OverridesFinalize(?class:Type)

AllocatedObjectSupportsFinalize(?heap, ?inmethod) :-
    AssignHeapAllocation(?heap, _, ?inmethod),
    HeapAllocation_Type(?heap, ?class),
    OverridesFinalize(?class).

OverridesFinalize(?class) :-
    MethodLookup("finalize", "void()", ?class, ?method),
    ?method != "<java.lang.Object: void finalize()>".
.decl MethodLookup(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method:Method)

.decl _MethodLookup_WithLen(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method:Method, ?len:number)
.decl _MethodLookup_MoreThanOne(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType)
.decl _MethodLookup_ClassResolution(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method:Method)
.decl _MethodLookup_ClosestInterface(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method:Method)
.decl _MethodLookup_MultiClosestInterfaces(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType)
.decl _MethodLookup_ImpossibleClosest(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method:Method)
MethodLookup(?simplename, ?descriptor, ?type, ?method) :-
    _MethodLookup_WithLen(?simplename, ?descriptor, ?type, ?method, _),
    !_MethodLookup_MoreThanOne(?simplename, ?descriptor, ?type).


MethodLookup(?simplename, ?descriptor, ?type, ?method) :-
    _MethodLookup_ClassResolution(?simplename, ?descriptor, ?type, ?method).


MethodLookup(?simplename, ?descriptor, ?type, ?method) :-
    _MethodLookup_ClosestInterface(?simplename, ?descriptor, ?type, ?method),
    !_MethodLookup_MultiClosestInterfaces(?simplename, ?descriptor, ?type).




MethodLookup(?simplename, ?descriptor, ?type, ?method) :-
    _MethodLookup_ClosestInterface(?simplename, ?descriptor, ?type, ?method),
    !_MethodLookup_ImpossibleClosest(?simplename, ?descriptor, ?type, ?method).


_MethodLookup_WithLen(?simplename, ?descriptor, ?type, ?method, 0) :-
    MethodImplemented(?simplename, ?descriptor, ?type, ?method).

_MethodLookup_WithLen(?simplename, ?descriptor, ?type, ?method, n + 1) :-
    DirectSuperclass(?type, ?supertype),
    _MethodLookup_WithLen(?simplename, ?descriptor, ?supertype, ?method, n),
    !MethodImplemented(?simplename, ?descriptor, ?type, _).

_MethodLookup_WithLen(?simplename, ?descriptor, ?type, ?method, n + 1) :-
    DirectSuperinterface(?type, ?supertype),
    _MethodLookup_WithLen(?simplename, ?descriptor, ?supertype, ?method, n),
    !MethodImplemented(?simplename, ?descriptor, ?type, _).

_MethodLookup_MoreThanOne(?simplename, ?descriptor, ?type) :-
    _MethodLookup_WithLen(?simplename, ?descriptor, ?type, ?method1, _),
    _MethodLookup_WithLen(?simplename, ?descriptor, ?type, ?method2, _),
    ?method1 != ?method2.

_MethodLookup_ClassResolution(?simplename, ?descriptor, ?type, ?method) :-
    _MethodLookup_MoreThanOne(?simplename, ?descriptor, ?type),
    _MethodLookup_WithLen(?simplename, ?descriptor, ?type, ?method, _),
    Method_DeclaringType(?method, ?supertype),
    isClassType(?supertype).

_MethodLookup_ClosestInterface(?simplename, ?descriptor, ?type, ?method) :-
    _MethodLookup_MoreThanOne(?simplename, ?descriptor, ?type),
    ?minLen = min ?len : { _MethodLookup_WithLen(?simplename, ?descriptor, ?type, _, ?len) },
    _MethodLookup_WithLen(?simplename, ?descriptor, ?type, ?method, ?minLen),
    !_MethodLookup_ClassResolution(?simplename, ?descriptor, ?type, _).

_MethodLookup_MultiClosestInterfaces(?simplename, ?descriptor, ?type) :-
    _MethodLookup_ClosestInterface(?simplename, ?descriptor, ?type, ?method1),
    _MethodLookup_ClosestInterface(?simplename, ?descriptor, ?type, ?method2),
    ?method1 != ?method2.

_MethodLookup_ImpossibleClosest(?simplename, ?descriptor, ?type, ?method2) :-
    _MethodLookup_ClosestInterface(?simplename, ?descriptor, ?type, ?method1),
    _MethodLookup_ClosestInterface(?simplename, ?descriptor, ?type, ?method2),
    Method_DeclaringType(?method1, ?type1),
    Method_DeclaringType(?method2, ?type2),
    SubtypeOf(?type1, ?type2),
    ?type1 != ?type2.
.decl MethodImplemented(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method:Method)
.decl MethodOverridesOther(?methodSub:Method, ?methodSuper:Method)
MethodOverridesOther(?methSub, ?methSuper) :-
  SubtypeOf(?subtype, ?supertype),
  Method_DeclaringType(?methSuper, ?supertype),
  Method_SimpleName(?methSuper, ?simplename),
  Method_Descriptor(?methSuper, ?descriptor),
  MethodLookup(?simplename, ?descriptor, ?subtype, ?methSub),
  ?methSub != ?methSuper.
MethodLookup(?simplename, ?descriptor, ?arraytype, ?method) :-
    isArrayType(?arraytype),
    isType(?objectType),
    MethodImplemented(?simplename, ?descriptor, ?objectType, ?method),
    ?objectType = "java.lang.Object".

MethodImplemented(?simplename, ?descriptor, ?type, ?method) :-
    Method_SimpleName(?method, ?simplename),
    Method_Descriptor(?method, ?descriptor),
    Method_DeclaringType(?method, ?type),
    ! Method_Modifier("abstract", ?method).








.decl _BridgeMethod(?bridge:Method, ?name:symbol, ?type:Type)
.decl MethodMightBeCovariantBridge(?bridge:Method, ?meth:Method)

_BridgeMethod(?bridge, ?name, ?type) :-
   Method_Modifier("bridge", ?bridge),
   Method_SimpleName(?bridge, ?name),
   Method_DeclaringType(?bridge, ?type),
   ?name != "<clinit>",
   ?name != "<init>".

MethodMightBeCovariantBridge(?bridge, ?meth) :-
   Method_SimpleName(?meth, ?name),
   _BridgeMethod(?bridge, ?name, ?bridgetype),
   Method_DeclaringType(?meth, ?bridgetype),
   !Method_Modifier("bridge", ?meth).
.decl MethodNotCovariantBridge(?meth1:Method, ?meth2:Method)



MethodNotCovariantBridge(?meth1, ?meth2) :-
   MethodMightBeCovariantBridge(?meth1, ?meth2),
   FormalParam(?sameIndex, ?meth1, ?formal1),
   _Var_Type(?formal1, ?type1),
   FormalParam(?sameIndex, ?meth2, ?formal2),
   _Var_Type(?formal2, ?type2),
   ?type1 != ?type2.

MethodNotCovariantBridge(?meth1, ?meth2) :-
   MethodMightBeCovariantBridge(?meth1, ?meth2),
   FormalParam(?sameIndex, ?meth1, _),
   !FormalParam(?sameIndex, ?meth2, _).

MethodNotCovariantBridge(?meth1, ?meth2) :-
   MethodMightBeCovariantBridge(?meth1, ?meth2),
   FormalParam(?sameIndex, ?meth2, _),
   !FormalParam(?sameIndex, ?meth1, _).

.decl Method_CovariantBridge(?bridge:Method, ?cometh:Method)

Method_CovariantBridge(?bridge, ?cometh) :-
   MethodMightBeCovariantBridge(?bridge, ?cometh),
   !MethodNotCovariantBridge(?bridge, ?cometh),
   Method_ReturnType(?bridge, ?retType),
   Method_ReturnType(?cometh, ?coRetType),
   SubtypeOfDifferent(?coRetType, ?retType).

.decl MethodImplementedModuloCovariance(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method:Method)


MethodImplementedModuloCovariance(?name, ?descriptor, ?type, ?method) :-
    MethodImplemented(?name, ?descriptor, ?type, ?method).
MethodImplementedModuloCovariance(?name, ?descriptor, ?type, ?comethod) :-
    MethodImplementedModuloCovariance(?name, _, ?type, ?comethod),
    Method_CovariantBridge(?method, ?comethod),
    Method_SimpleName(?method, ?name),
    Method_Descriptor(?method, ?descriptor).
.decl ResolveInvocation(?type:Type, ?invocation:MethodInvocation, ?tomethod:Method)



.decl VirtualMethodInvocation_BaseType(?invocation:MethodInvocation, ?type:Type)
VirtualMethodInvocation_BaseType(?invocation, ?basetype) :-
    VirtualMethodInvocation_Base(?invocation, ?base),
    Var_Type(?base, ?basetype).

ResolveInvocation(?type, ?invocation, ?tomethod) :-
    VirtualMethodInvocation_SimpleName(?invocation, ?simplename),
    VirtualMethodInvocation_Descriptor(?invocation, ?descriptor),
    VirtualMethodInvocation_BaseType(?invocation, ?basetype),
    SubtypeOf(?type, ?basetype),
    MethodLookup(?simplename, ?descriptor, ?type, ?tomethod).

ResolveInvocation(?basetype, ?invocation, ?tomethod) :-
    SuperMethodInvocation_SimpleName(?invocation, ?simplename),
    SuperMethodInvocation_Descriptor(?invocation, ?descriptor),
    SuperMethodInvocation_Base(?invocation, ?base),
    Var_Type(?base, ?basetype),
    DirectSuperclass(?basetype, ?supertype),
    MethodLookup(?simplename, ?descriptor, ?supertype, ?tomethod).


.decl ConcreteMethodDeclared(?meth:Method, ?class:ClassType)
ConcreteMethodDeclared(?meth, ?class) :-
  isClassType(?class),
  Method_DeclaringType(?meth, ?class),
  !Method_Modifier("abstract", ?meth).

.decl MethodDeclaredOrInherited(?meth:Method, ?class:ReferenceType)
MethodDeclaredOrInherited(?meth, ?class) :-

  Method_DeclaringType(?meth, ?class).



MethodDeclaredOrInherited(?meth, ?class) :-
  MethodDeclaredOrInherited(?meth, ?superClass),
  DirectSuperclass(?class, ?superClass).


MethodDeclaredOrInherited(?meth, ?class) :-
  MethodDeclaredOrInherited(?meth, ?superInterface),
  !Method_Modifier("abstract", ?meth),
  DirectSuperinterface(?class, ?superInterface).


.decl MethodsOfSameOrSuperType(?method1:Method, ?method2:Method)
MethodsOfSameOrSuperType(?method1, ?method2) :-
  MethodDeclaredOrInherited(?method1, ?class),
  MethodDeclaredOrInherited(?method2, ?class).

.decl MethodsOfSameNonSDKType(?method1:Method, ?method2:Method, ?class:Type)
MethodsOfSameNonSDKType(?method1, ?method2, ?class) :-
  Method_DeclaringType(?method1, ?class),
  !match("java.*", ?class),
  !match("sun.*", ?class),
  Method_DeclaringType(?method2, ?class).
.decl Superinterface(?k:InterfaceType, ?c:ReferenceType)
Superinterface(?k, ?c) :-
    DirectSuperinterface(?c, ?k).
Superinterface(?k, ?c) :-
    DirectSuperinterface(?c, ?j),
    Superinterface(?k, ?j).
Superinterface(?k, ?c) :-
    DirectSuperclass(?c, ?super),
    Superinterface(?k, ?super).
.decl DirectSubclass(?a:ClassType, ?c:ClassType)
.decl Subclass(?c:ClassType, ?a:ClassType)
.decl Superclass(?c:ClassType, ?a:ClassType)

DirectSubclass(?a, ?c) :-
    DirectSuperclass(?a, ?c).
Subclass(?c, ?a) :-
    DirectSubclass(?a, ?c).
Subclass(?c, ?a) :-
    Subclass(?b, ?a),
    DirectSubclass(?b, ?c).
Superclass(?c, ?a) :-
    Subclass(?a, ?c).


.decl SubtypeOf(?subtype:Type, ?type:Type)
.decl SupertypeOf(?supertype:Type, ?type:Type)
.decl Unsubclassable(?type:ReferenceType)
.decl Subclassable(?type:ReferenceType)
.decl SubtypeOfDifferent(?subtype:Type, ?type:Type)
.decl ClassConstructor(?method:Method, ?type:ClassType)
SupertypeOf(?s, ?t) :-
    SubtypeOf(?t, ?s).
SubtypeOf(?s, ?s) :-
    isClassType(?s).

SubtypeOf(?s, ?t) :-
    Subclass(?t, ?s).
SubtypeOf(?s, ?t) :-
    isClassType(?s),
    Superinterface(?t, ?s).
SubtypeOf(?s, ?t) :-
    isInterfaceType(?s),
    isType(?t),
    ?t = "java.lang.Object".
SubtypeOf(?s, ?s) :-
    isInterfaceType(?s).

SubtypeOf(?s, ?t) :-
    isInterfaceType(?s),
    Superinterface(?t, ?s).
SubtypeOf(?s, ?t) :-
    isArrayType(?s),
    isType(?t),
    ?t = "java.lang.Object".
SubtypeOf(?s, ?t) :-
    isArrayType(?s),
    isArrayType(?t),
    ComponentType(?s, ?sc),
    ComponentType(?t, ?sc),
    isPrimitiveType(?sc).
SubtypeOf(?s, ?t) :-
    ComponentType(?s, ?sc),
    ComponentType(?t, ?tc),
    isReferenceType(?sc),
    isReferenceType(?tc),
    SubtypeOf(?sc, ?tc).
SubtypeOf(?s, ?t) :-
    isArrayType(?s),
    isInterfaceType(?t),
    isType(?t),
    ?t = "java.lang.Cloneable".

SubtypeOf(?s, ?t) :-
    isArrayType(?s),
    isInterfaceType(?t),
    isType(?t),
    ?t = "java.io.Serializable".
SubtypeOf(?s, ?t) :-
    Type_null(?s),
    isReferenceType(?t),
    ?t != ?s.
SubtypeOf(?s, ?t) :-
    Type_float(?s),
    Type_double(?t).

SubtypeOf(?s, ?t) :-
    Type_long(?s),
    Type_float(?t).

SubtypeOf(?s, ?t) :-
    Type_int(?s),
    Type_long(?t).

SubtypeOf(?s, ?t) :-
    Type_char(?s),
    Type_int(?t).

SubtypeOf(?s, ?t) :-
    Type_short(?s),
    Type_int(?t).

SubtypeOf(?s, ?t) :-
    Type_byte(?s),
    Type_short(?t).
SubtypeOf(?t, ?t) :-
    isType(?t).




SubtypeOfDifferent(?s, ?t) :-
    SubtypeOf(?s, ?t),
    ?s != ?t.




Unsubclassable("java.lang.ClassLoader").
Unsubclassable("java.lang.SecurityManager").




Subclassable(?type) :-
    ClassModifier("public", ?type),
    ! ClassModifier("final", ?type),
    ClassConstructor(?method, ?type),
    Method_Modifier("public", ?method),
    ! Unsubclassable(?type).

Subclassable(?type) :-
    ClassModifier("public", ?type),
    ! ClassModifier("final", ?type),
    ClassConstructor(?method, ?type),
    Method_Modifier("protected", ?method),
    ! Unsubclassable(?type).

ClassConstructor(method, type) :-
    isClassType(type),
    MethodLookup(_, _, type, method),
    isMethod(method),
    match(".*<init>.*", method).


.decl Class_InterestingSubtype(?class:ReferenceType, ?subClass:ReferenceType)
.decl _Valid_Type(?type:ReferenceType)

Class_InterestingSubtype(?class, ?subClass) :-
  SubtypeOf(?subClass, ?class),
  _Valid_Type(?class),
  _Valid_Type(?subClass).

_Valid_Type(?type) :-
  isReferenceType(?type),
  (isClassType(?type) ; isInterfaceType(?type)).

isIntegerType(?type) :-
  Type_byte(?type) ; Type_short(?type) ; Type_int(?type) ; Type_long(?type).

.decl PossibleNativeCodeTargetMethod(?method:Method, ?function:symbol, ?file:symbol)


PossibleNativeCodeTargetMethod(?method, ?function, ?file) :-
  _NativeMethodTypeCandidate(?file, ?function, ?descriptor, _),
  _NativeNameCandidate(?file, ?function, ?name, _),
  Method_SimpleName(?method, ?name),
  Method_JVMDescriptor(?method, ?descriptor).






PossibleNativeCodeTargetMethod(?method, "<<UNKNOWN>>", ?file) :-
  _NativeMethodTypeCandidate(?file, ?function, ?descriptor, _),
  _NativeNameCandidate(?file, ?function, ?name, _),
  _NativeXRef(?descriptor, ?file, _, ?descriptorRefAddr),
  _NativeXRef(?name, ?file, _, ?nameRefAddr),
  Method_SimpleName(?method, ?name),
  Method_JVMDescriptor(?method, ?descriptor),
  (?nameRefAddr - ?descriptorRefAddr) <=  15 ,
  (?descriptorRefAddr - ?nameRefAddr) <=  15 .

.decl PossibleNativeCodeTargetMethodLocalized(?method:Method, ?function:symbol, ?file:symbol)

PossibleNativeCodeTargetMethodLocalized(?method, ?function, ?file) :-
  PossibleNativeCodeTargetMethod(?method, ?function, ?file),
  ?function != "-".

.decl OverloadedJNIMethod(?javaMethod:Method, ?type:ReferenceType, ?name:symbol, ?descriptor:symbol)

OverloadedJNIMethod(?javaMethod, ?type, ?name, ?descriptor) :-
  Method_Modifier("native", ?javaMethod),
  Method_SimpleName(?javaMethod, ?name),
  Method_Descriptor(?javaMethod, ?descriptor),
  Method_DeclaringType(?javaMethod, ?type),
  MethodLookup(?name, _, ?type, ?method1),
  MethodLookup(?name, _, ?type, ?method2),
  ?method1 != ?method2.






.decl JNIMethod_NativeId(?javaMethod:Method, ?nativeId:symbol)


JNIMethod_NativeId(?javaMethod, ?nativeId) :-
  _NativeMethodId(?javaMethod, ?nativeId),
  isMethod(?javaMethod).


JNIMethod_NativeId(?javaMethod, ?nativeId) :-
  OverloadedJNIMethod(?javaMethod, _, _, ?descriptor),
  _NativeMethodId(?javaMethod, ?nativeIdBase),
  ?nativeId = cat(?nativeIdBase, cat("__", ?descriptor)).

.decl AnyMainMethodDeclaration(?method:Method, ?type:ClassType)
AnyMainMethodDeclaration(?method, ?type) :-
   Method_DeclaringType(?method, ?type),
   Method_SimpleName(?method, "main"),
   Method_Descriptor(?method, "void(java.lang.String[])"),
   Method_Modifier("public", ?method),
   Method_Modifier("static", ?method).

.decl MainMethodDeclaration(?method:Method)

MainMethodDeclaration(?method) :-





  MainClass(?type),

  AnyMainMethodDeclaration(?method, ?type).
}

.init basic = Basic
.type Modifier = symbol
.decl isModifier(?m:Modifier)

.decl Modifier_abstract(?mod:Modifier)
.decl Modifier_final(?mod:Modifier)
.decl Modifier_public(?mod:Modifier)
.decl Modifier_private(?mod:Modifier)
.decl Modifier_static(?mod:Modifier)


.type Type = symbol
.type PrimitiveType = Type
.type ReferenceType = Type
.type NullType = ReferenceType
.type ArrayType = ReferenceType
.type ClassType = ReferenceType
.type InterfaceType = ReferenceType

.decl isType(?t:Type)
.decl isPrimitiveType(?t:PrimitiveType)
.decl isReferenceType(?t:ReferenceType)
.decl isNullType(?t:ReferenceType)
.decl isArrayType(?t:ArrayType)
.decl isClassType(?t:ClassType)
.decl isInterfaceType(?t:InterfaceType)



.decl DirectSuperclass(?class:ClassType, ?superclass:ClassType)
.decl DirectSuperinterface(?ref:ReferenceType, ?interface:InterfaceType)



.decl ConcreteClass(?ref:ClassType)
.decl MainClass(?class:ClassType)



.decl Type_boolean(?t:PrimitiveType)
.decl Type_byte(?t:PrimitiveType)
.decl Type_char(?t:PrimitiveType)
.decl Type_short(?t:PrimitiveType)
.decl Type_int(?t:PrimitiveType)
.decl Type_long(?t:PrimitiveType)
.decl Type_float(?t:PrimitiveType)
.decl Type_double(?t:PrimitiveType)
.decl Type_void(?t:Type)
.decl Type_null(?t:NullType)
.decl Type_object(?t:ReferenceType)

.decl isIntegerType(?type:Type)

.decl ClassModifier(?mod:Modifier, ?class:ReferenceType)



.type Field = symbol
.decl isField(?field:Field)

.decl Field_DeclaringType(?field:Field, ?declaringClass:ReferenceType)
.decl Field_SimpleName(?field:Field, ?simpleName:symbol)
.decl Field_Type(?field:Field, ?type:Type)
.decl Field_Modifier(?mod:Modifier, ?field:Field)




.type MethodDescriptor = symbol
.decl isMethodDescriptor(?md:MethodDescriptor)

.type Method = symbol
.decl isMethod(?m:Method)

.decl Method_DeclaringType(?method:Method, ?declaringType:ReferenceType)
.decl Method_ReturnType(?method:Method, ?returnType:Type)
.decl Method_SimpleName(?method:Method, ?simpleName:symbol)
.decl Method_ParamTypes(?method:Method, ?params:symbol)
.decl Method_Descriptor(?method:Method, ?descriptor:MethodDescriptor)
.decl Method_Arity(?method:Method, ?arity:number)

.type JVMDescriptor = symbol
.decl isJVMDescriptor(?jvmd:JVMDescriptor)


.decl Method_JVMDescriptor(?method:Method, ?descriptor:JVMDescriptor)

.decl Method_Modifier(?mod:Modifier, ?method:Method)




.decl Method_DeclaresException(?exceptionType:ReferenceType, ?method:Method)

.decl FormalParam(?index:number, ?method:Method, ?var:Var)

.decl ThisVar(?method:Method, ?var:Var)



.type Var = symbol
.decl isVar(v:Var)

.decl Var_Type(?var:Var, ?type:Type)
.decl Var_DeclaringMethod(?var:Var, ?method:Method)
.decl Var_SimpleName(?var:Var, ?simplename:symbol)






.type Value = symbol

.decl isValue(?value:Value)





.type NumConstant = Value

.decl isNumConstant(?n:NumConstant)





.type HeapAllocation = Value
.type NormalHeap = HeapAllocation
.type StringConstant = HeapAllocation
.type ClassHeap = HeapAllocation
.type MethodHandleConstant = HeapAllocation
.type MethodTypeConstant = HeapAllocation

.decl isHeapAllocation(?h:HeapAllocation)
.decl isNormalHeap(?h:NormalHeap)
.decl isStringConstant(?h:StringConstant)
.decl isClassHeap(?h:ClassHeap)
.decl isMethodHandleConstant(?h:MethodHandleConstant)
.decl isMethodTypeConstant(?h:MethodTypeConstant)
.decl isStringRaw(?id:symbol)

.decl HeapAllocation_Type(?heap:HeapAllocation, ?type:ReferenceType)
.decl OriginalHeapAllocation_Type(?heap:HeapAllocation, ?type:ReferenceType)


.decl HeapAllocation_EmptyArray(?heap:HeapAllocation)
.decl HeapAllocation_Null(?null:HeapAllocation)
.decl MainMethodArgArray(?heap:HeapAllocation)
.decl MainMethodArgArrayContent(?heap:HeapAllocation)

.decl ClassHeap_InstanceType(?classHeap:ClassHeap, ?instanceType:ReferenceType)
.decl MethodHandleConstant_Method(?heap:MethodHandleConstant, ?method:Method)
.decl MethodHandleConstant_ReturnType(?heap:MethodHandleConstant, ?retType:Type)
.decl MethodHandleConstant_ParamTypes(?heap:MethodHandleConstant, ?paramTypes:symbol)
.decl MethodHandleConstant_Arity(?heap:MethodHandleConstant, ?arity:number)
.decl MethodTypeConstant_Arity(?heap:MethodTypeConstant, ?arity:number)
.decl MethodTypeConstant_ReturnType(?heap:MethodTypeConstant, ?retType:Type)
.decl MethodTypeConstant_ParamTypes(?heap:MethodTypeConstant, ?paramTypes:symbol)





.type Instruction = symbol
.decl isInstruction(?insn:Instruction)

.decl Instruction_Index(?insn:Instruction, ?index:number)
.decl Instruction_Line(?insn:Instruction, ?index:number)
.decl Instruction_Method(?insn:Instruction, ?inMethod:Method)
.output Instruction_Method

.type Throw_Insn = Instruction
.type ThrowNull_Insn = Throw_Insn
.type Goto_Insn = Instruction
.type If_Insn = Instruction
.type Switch_Insn = Instruction
.type TableSwitch_Insn = Switch_Insn
.type LookupSwitch_Insn = Switch_Insn
.type MonitorInstruction = Instruction
.type EnterMonitor_Insn = MonitorInstruction
.type ExitMonitor_Insn = MonitorInstruction
.type FieldInstruction = Instruction
.type LoadInstanceField_Insn = FieldInstruction
.type StoreInstanceField_Insn = FieldInstruction
.type LoadStaticField_Insn = FieldInstruction
.type StoreStaticField_Insn = FieldInstruction
.type ArrayInstruction = Instruction
.type LoadArrayIndex_Insn = ArrayInstruction
.type StoreArrayIndex_Insn = ArrayInstruction

.decl isThrow_Insn(?insn:Throw_Insn)
.decl isThrowNull_Insn(?insn:ThrowNull_Insn)
.decl isGoto_Insn(?insn:Goto_Insn)
.decl isIf_Insn(?insn:If_Insn)
.decl isSwitch_Insn(?insn:Switch_Insn)
.decl isTableSwitch_Insn(?insn:TableSwitch_Insn)
.decl isLookupSwitch_Insn(?insn:LookupSwitch_Insn)
.decl isMonitorInstruction(?insn:MonitorInstruction)
.decl isEnterMonitor_Insn(?insn:EnterMonitor_Insn)
.decl isExitMonitor_Insn(?insn:ExitMonitor_Insn)
.decl isFieldInstruction(?insn:FieldInstruction)
.decl isLoadInstanceField_Insn(?insn:LoadInstanceField_Insn)
.decl isStoreInstanceField_Insn(?insn:StoreInstanceField_Insn)
.decl isLoadStaticField_Insn(?insn:LoadStaticField_Insn)
.decl isStoreStaticField_Insn(?insn:StoreStaticField_Insn)
.decl isArrayInstruction(?insn:ArrayInstruction)
.decl isLoadArrayIndex_Insn(?insn:LoadArrayIndex_Insn)
.decl isStoreArrayIndex_Insn(?insn:StoreArrayIndex_Insn)

.type AssignInstruction = Instruction
.type AssignOper_Insn = AssignInstruction
.type AssignBinop_Insn = AssignOper_Insn
.type AssignUnop_Insn = AssignOper_Insn
.type AssignLocal_Insn = AssignOper_Insn
.type AssignInstanceOf_Insn = AssignInstruction
.type AssignNull_Insn = AssignInstruction
.type AssignNumConstant_Insn = AssignInstruction
.type AssignCast_Insn = AssignInstruction
.type AssignCastNull_Insn = AssignCast_Insn
.type AssignCastNumConstant_Insn = AssignCast_Insn
.type AssignHeapAllocation_Insn = AssignInstruction
.type ReturnInstruction = Instruction
.type ReturnVoid_Insn = ReturnInstruction
.type ReturnNonvoid_Insn = ReturnInstruction

.decl isAssignInstruction(?insn:AssignInstruction)
.decl isAssignOper_Insn(?insn:AssignOper_Insn)
.decl isAssignBinop_Insn(?insn:AssignBinop_Insn)
.decl isAssignUnop_Insn(?insn:AssignUnop_Insn)
.decl isAssignLocal_Insn(?insn:AssignLocal_Insn)
.decl isAssignInstanceOf_Insn(?insn:AssignInstanceOf_Insn)
.decl isAssignNull_Insn(?insn:AssignNull_Insn)
.decl isAssignNumConstant_Insn(?insn:AssignNumConstant_Insn)
.decl isAssignCast_Insn(?insn:AssignCast_Insn)
.decl isAssignCastNull_Insn(?insn:AssignCastNull_Insn)
.decl isAssignCastNumConstant_Insn(?insn:AssignCastNumConstant_Insn)
.decl isAssignHeapAllocation_Insn(?insn:AssignHeapAllocation_Insn)
.decl isReturnInstruction(?insn:ReturnInstruction)
.decl isReturnVoid_Insn(?insn:ReturnVoid_Insn)
.decl isReturnNonvoid_Insn(?insn:ReturnNonvoid_Insn)

.type MethodInvocation = Instruction
.type VirtualMethodInvocation_Insn = MethodInvocation
.type SpecialMethodInvocation_Insn = MethodInvocation
.type StaticMethodInvocation_Insn = MethodInvocation
.type SuperMethodInvocation_Insn = MethodInvocation
.type DynamicMethodInvocation_Insn = MethodInvocation

.decl isMethodInvocation(?insn:MethodInvocation)
.decl isVirtualMethodInvocation_Insn(?insn:VirtualMethodInvocation_Insn)
.decl isSpecialMethodInvocation_Insn(?insn:SpecialMethodInvocation_Insn)
.decl isStaticMethodInvocation_Insn(?insn:StaticMethodInvocation_Insn)
.decl isSuperMethodInvocation_Insn(?insn:SuperMethodInvocation_Insn)
.decl isDynamicMethodInvocation_Insn(?insn:DynamicMethodInvocation_Insn)

.type UnsupportedInstruction = Instruction
.type AssignPhantomInvoke = UnsupportedInstruction
.type BreakpointStmt = UnsupportedInstruction

.decl isUnsupportedInstruction(?insn:UnsupportedInstruction)
.decl isAssignPhantomInvoke(?insn:AssignPhantomInvoke)
.decl isBreakpointStmt(?insn:BreakpointStmt)



.decl DummyIf_Var(?insn:If_Insn, ?Var:Var)
.decl If_Var(?insn:If_Insn, ?pos:number, ?var:Var)
.decl If_Constant(?insn:If_Insn, ?pos: number, ?cons: NumConstant)
.decl Throw_Var(?insn:Throw_Insn, ?var:Var)
.decl Goto_Target(?insn:Goto_Insn, ?index:number)
.decl If_Target(?insn:If_Insn, ?index:number)
.decl Switch_Key(?insn:Switch_Insn, ?key:Var)
.decl Switch_Target(?insn:Switch_Insn, ?value:number, ?index:number)
.decl Switch_DefaultTarget(?insn:Switch_Insn, ?index:number)
.decl EnterMonitor_Var(?insn:EnterMonitor_Insn, ?var:Var)
.decl ExitMonitor_Var(?insn:ExitMonitor_Insn, ?var:Var)









.decl FieldInstruction_Signature(?insn:FieldInstruction, ?sign:Field)
.decl LoadInstanceField_Base(?insn:LoadInstanceField_Insn, ?var:Var)
.decl LoadInstanceField_To(?insn:LoadInstanceField_Insn, ?var:Var)
.decl StoreInstanceField_From(?insn:StoreInstanceField_Insn, ?var:Var)
.decl StoreInstanceField_Base(?insn:StoreInstanceField_Insn, ?var:Var)
.decl LoadStaticField_To(?insn:LoadStaticField_Insn, ?var:Var)










.decl StoreStaticField_From(?insn:StoreStaticField_Insn, ?var:Var)






.decl ArrayInsnIndex(?insn:Instruction, ?index:Var)
.decl ArrayNumIndex(?insn:Instruction, ?index:number)

.decl ComponentType(?arrayType:ArrayType, ?componentType:Type)

.decl LoadArrayIndex_Base(?insn:LoadArrayIndex_Insn, ?var:Var)
.decl LoadArrayIndex_To(?insn:LoadArrayIndex_Insn, var:Var)

.decl StoreArrayIndex_From(?insn:StoreArrayIndex_Insn, ?var:Var)
.decl StoreArrayIndex_Base(?insn:StoreArrayIndex_Insn, ?var:Var)

.decl ArrayAllocation(?insn:Instruction, ?pos:number, ?sizeVar:Var)







.decl AssignInstruction_To(?insn:AssignInstruction, ?to:Var)


.decl AssignNumConstant_Id(?insn:AssignNumConstant_Insn, ?const:symbol)


.decl AssignCast_From(?insn:AssignCast_Insn, ?from:Var)

.decl AssignCast_Type(?insn:AssignCast_Insn, ?type:Type)


.decl AssignCastNumConstant_Id(?insn:AssignCastNumConstant_Insn, ?const:symbol)


.decl AssignLocal_From(?insn:AssignLocal_Insn, ?from:Var)


.decl AssignInstanceOf_From(?insn:AssignInstanceOf_Insn, ?from:Var)

.decl AssignInstanceOf_Type(?insn:AssignInstanceOf_Insn, ?type:Type)


.decl AssignOper_From(?insn:AssignOper_Insn, ?pos:number, ?from:Var)


.decl AssignOper_FromConstant(?insn:AssignOper_Insn, ?pos: number, ?from:NumConstant)


.decl AssignHeapAllocation_Heap(?insn:AssignHeapAllocation_Insn, ?heap:HeapAllocation)






.decl ReturnNonvoid_Var(?return:ReturnNonvoid_Insn, ?var:Var)







.decl MethodInvocation_Line(?invocation:MethodInvocation, ?line:number)


.decl MethodInvocation_Method(?invocation:MethodInvocation, ?signature:Method)


.decl AssignReturnValue(?invocation:MethodInvocation, ?to:Var)



.decl ActualParam(?index:number, ?invocation:MethodInvocation, ?var:Var)


.decl VirtualMethodInvocation_Base(?invocation:VirtualMethodInvocation_Insn, ?base:Var)
.decl VirtualMethodInvocation_SimpleName(?invocation:MethodInvocation, ?simplename:symbol)
.decl VirtualMethodInvocation_Descriptor(?invocation:MethodInvocation, ?descriptor:MethodDescriptor)


.decl SuperMethodInvocation_Base(?invocation:SuperMethodInvocation_Insn, ?base:Var)
.decl SuperMethodInvocation_SimpleName(?invocation:MethodInvocation, ?simplename:symbol)
.decl SuperMethodInvocation_Descriptor(?invocation:MethodInvocation, ?descriptor:MethodDescriptor)


.decl DynamicMethodInvocation_Bootstrap(?invocation:DynamicMethodInvocation_Insn, ?bootSignature:Method)



.decl DynamicMethodInvocation_DynName(?invocation:DynamicMethodInvocation_Insn, ?dynName:symbol)
.decl DynamicMethodInvocation_DynReturnType(?invocation:DynamicMethodInvocation_Insn, ?dynRetType:Type)
.decl DynamicMethodInvocation_DynParamTypes(?invocation:DynamicMethodInvocation_Insn, ?dynParamTypes:symbol)

.decl DynamicMethodInvocation_DynArity(?invocation:DynamicMethodInvocation_Insn, ?dynArity:number)

.decl DynamicMethodInvocation_HandleTag(?instruction:DynamicMethodInvocation_Insn, ?tag:number)


.decl BootstrapParam(?index:number, ?invocation:DynamicMethodInvocation_Insn, ?var:Var)


.decl StaticMethodInvocation_SimpleName(?invocation:MethodInvocation, ?simplename:symbol)
.decl StaticMethodInvocation_Descriptor(?invocation:MethodInvocation, ?descriptor:MethodDescriptor)


.decl SpecialMethodInvocation_Base(?invocation:SpecialMethodInvocation_Insn, ?base:Var)
.decl SpecialMethodInvocation_SimpleName(?invocation:MethodInvocation, ?simplename:symbol)
.decl SpecialMethodInvocation_Descriptor(?invocation:MethodInvocation, ?descriptor:MethodDescriptor)

.decl MethodInvocation_Base(?invocation:MethodInvocation, ?base:Var)






.type ExceptionHandler = Instruction
.decl isExceptionHandler(?handler:ExceptionHandler)

.decl ExceptionHandler_Method(?handler:ExceptionHandler, ?inmethod:Method)


.decl ExceptionHandler_Index(?handler:ExceptionHandler, ?index:number)
.decl ExceptionHandler_Type(?handler:ExceptionHandler, ?type:Type)


.decl ExceptionHandler_FormalParam(?handler:ExceptionHandler, ?var:Var)


.decl ExceptionHandler_Begin(?handler:ExceptionHandler, ?index:number)



.decl ExceptionHandler_End(?handler:ExceptionHandler, ?index:number)


.decl ExceptionHandler_Previous(?handler:ExceptionHandler, ?previous:ExceptionHandler)


.decl ApplicationClass(?ref:ReferenceType)
.decl ApplicationField(?field:Field)
.decl ApplicationMethod(?method:Method)
.decl ApplicationVar(?var:Var)
.decl ApplicationInvocation(?invocation:MethodInvocation)
.decl ApplicationAllocation(?allocation:HeapAllocation)







.decl Properties(?path:StringConstant, ?key:StringConstant, ?value:StringConstant)


.decl NativeReturnVar(?var:Var, ?method:Method)


.type Annotation = ReferenceType
.decl isAnnotation(?a:Annotation)
.decl Type_Annotation(?type:ReferenceType, ?annotation:Annotation)
.decl Method_Annotation(?method:Method, ?annotation:Annotation)
.decl Field_Annotation(?fld:Field, ?annotation:Annotation)
.decl Param_Annotation(?method:Method, ?index:number, ?annotation:Annotation)
.decl AnnotationElement(?annotationKind:symbol, ?element:symbol, ?parentId:symbol, ?id:symbol, ?name:symbol, ?value1:symbol, ?value2:symbol)


.decl isOpaqueMethod(?m:Method)



.decl Stats_Metrics(order:symbol, msg:symbol, c:number)





.decl MockObject(?value:Value, ?class:ReferenceType)
.output MockObject
.decl MockObjFromOpenProgramEntryPointReceiver(?value:Value)
.decl ExercisedEntryPointMethod(?class:Type, ?method:Method)
.decl MockObjFromOpenProgramEntryPointArg(?value:Value)
.decl UnmockableFormalOfForcedReachableContext(?formal:Var, ?formalType:Type)
.decl Throw(?insn:Throw_Insn, ?var:Var)

.decl LoadInstanceField(?base:Var, ?sig:Field, ?to:Var, ?inmethod:Method)

.decl StoreInstanceField(?from:Var, ?base:Var, ?signature:Field, ?inmethod:Method)

.decl LoadStaticField(?sig:Field, ?to:Var, ?inmethod:Method)

.decl StoreStaticField(?from:Var, ?signature:Field, ?inmethod:Method)

.decl LoadArrayIndex(?base:Var, ?to:Var, ?inmethod:Method)

.decl StoreArrayIndex(?from:Var, ?base:Var, ?inmethod:Method)

.decl AssignCast(?type:Type, ?from:Var, ?to:Var, ?inmethod:Method)

.decl AssignLocal(?from:Var, ?to:Var, ?inmethod:Method)

.decl AssignNull(?to:Var, ?inmethod:Method)

.decl AssignHeapAllocation(?heap:HeapAllocation, ?to:Var, ?inmethod:Method)


.decl ReturnVar(?var:Var, ?method:Method)

.decl VirtualMethodInvocation(?invocation:MethodInvocation, ?signature:Method, ?inmethod:Method)

.decl SuperMethodInvocation(?invocation:MethodInvocation, ?signature:Method, ?inmethod:Method)

.decl StaticMethodInvocation(?invocation:MethodInvocation, ?signature:Method, ?inmethod:Method)


Throw(?insn, ?var) :-
	isThrow_Insn(?insn),
	Throw_Var(?insn, ?var).

LoadInstanceField(?base, ?sig, ?to, ?inmethod) :-
	isLoadInstanceField_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	LoadInstanceField_Base(?insn, ?base),
	FieldInstruction_Signature(?insn, ?sig),
	LoadInstanceField_To(?insn, ?to).

StoreInstanceField(?from, ?base, ?sig, ?inmethod) :-
	isStoreInstanceField_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	StoreInstanceField_From(?insn, ?from),
	StoreInstanceField_Base(?insn, ?base),
	FieldInstruction_Signature(?insn, ?sig).

LoadStaticField(?sig, ?to, ?inmethod) :-
	isLoadStaticField_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	FieldInstruction_Signature(?insn, ?sig),
	LoadStaticField_To(?insn, ?to).

StoreStaticField(?from, ?sig, ?inmethod) :-
	isStoreStaticField_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	StoreStaticField_From(?insn, ?from),
	FieldInstruction_Signature(?insn, ?sig).

LoadArrayIndex(?base, ?to, ?inmethod) :-
	isLoadArrayIndex_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	LoadArrayIndex_Base(?insn, ?base),
	LoadArrayIndex_To(?insn, ?to).

StoreArrayIndex(?from, ?base, ?inmethod) :-
	isStoreArrayIndex_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	StoreArrayIndex_From(?insn, ?from),
	StoreArrayIndex_Base(?insn, ?base).

AssignCast(?type, ?from, ?to, ?inmethod) :-
	isAssignCast_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	AssignCast_From(?insn, ?from),
	AssignInstruction_To(?insn, ?to),
	AssignCast_Type(?insn, ?type).

AssignLocal(?from, ?to, ?inmethod) :-
	isAssignLocal_Insn(?insn),
	AssignInstruction_To(?insn, ?to),
	Instruction_Method(?insn, ?inmethod),
	AssignLocal_From(?insn, ?from).

AssignNull(?to, ?inmethod) :-
	isAssignNull_Insn(?insn),
	AssignInstruction_To(?insn, ?to),
	Instruction_Method(?insn, ?inmethod).

AssignHeapAllocation(?heap, ?to, ?inmethod) :-
	isAssignHeapAllocation_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	AssignHeapAllocation_Heap(?insn, ?heap),
	AssignInstruction_To(?insn, ?to).

ReturnVar(?var, ?method) :-
	isReturnNonvoid_Insn(?insn),
	Instruction_Method(?insn, ?method),
	ReturnNonvoid_Var(?insn, ?var).

ReturnVar(?var, ?method) :-
	NativeReturnVar(?var, ?method).

VirtualMethodInvocation(?invocation, ?signature, ?inmethod) :-
	isVirtualMethodInvocation_Insn(?invocation),
	Instruction_Method(?invocation, ?inmethod),
	MethodInvocation_Method(?invocation, ?signature).

StaticMethodInvocation(?invocation, ?signature, ?inmethod) :-
	isStaticMethodInvocation_Insn(?invocation),
	Instruction_Method(?invocation, ?inmethod),
	MethodInvocation_Method(?invocation, ?signature).

SuperMethodInvocation(?invocation, ?signature, ?inmethod) :-
	isSuperMethodInvocation_Insn(?invocation),
	Instruction_Method(?invocation, ?inmethod),
	MethodInvocation_Method(?invocation, ?signature).

VirtualMethodInvocation_SimpleName(?invocation, ?simplename),
VirtualMethodInvocation_Descriptor(?invocation, ?descriptor) :-
	isVirtualMethodInvocation_Insn(?invocation),
	MethodInvocation_Method(?invocation, ?signature),
	Method_SimpleName(?signature, ?simplename),
	Method_Descriptor(?signature, ?descriptor).

StaticMethodInvocation_SimpleName(?invocation, ?simplename),
StaticMethodInvocation_Descriptor(?invocation, ?descriptor) :-
	isStaticMethodInvocation_Insn(?invocation),
	MethodInvocation_Method(?invocation, ?signature),
	Method_SimpleName(?signature, ?simplename),
	Method_Descriptor(?signature, ?descriptor).

SpecialMethodInvocation_SimpleName(?invocation, ?simplename),
SpecialMethodInvocation_Descriptor(?invocation, ?descriptor) :-
	isSpecialMethodInvocation_Insn(?invocation),
	MethodInvocation_Method(?invocation, ?signature),
	Method_SimpleName(?signature, ?simplename),
	Method_Descriptor(?signature, ?descriptor).

SuperMethodInvocation_SimpleName(?invocation, ?simplename),
SuperMethodInvocation_Descriptor(?invocation, ?descriptor) :-
	isSuperMethodInvocation_Insn(?invocation),
	MethodInvocation_Method(?invocation, ?signature),
	Method_SimpleName(?signature, ?simplename),
	Method_Descriptor(?signature, ?descriptor).

.decl MethodInvocation_SimpleName(?invocation:Instruction, ?simpleName:symbol)

MethodInvocation_SimpleName(?invocation, ?simplename) :-
	VirtualMethodInvocation_SimpleName(?invocation, ?simplename).
MethodInvocation_SimpleName(?invocation, ?simplename) :-
	SpecialMethodInvocation_SimpleName(?invocation, ?simplename).
MethodInvocation_SimpleName(?invocation, ?simplename) :-
	StaticMethodInvocation_SimpleName(?invocation, ?simplename).
MethodInvocation_SimpleName(?invocation, ?simplename) :-
	SuperMethodInvocation_SimpleName(?invocation, ?simplename).

.decl KeepMethod(?m:Method)
.decl KeepClassMembers(?m:Method)
.decl KeepClassesWithMembers(?m:Method)
.decl KeepClass(?c:ReferenceType)
.decl RootCodeElement(?id:symbol)

.input KeepMethod(filename="KeepMethod.facts")
.input KeepClassMembers(filename="KeepClassMembers.facts")
.input KeepClassesWithMembers(filename="KeepClassesWithMembers.facts")
.input KeepClass(filename="KeepClass.facts")
.input RootCodeElement(filename="RootCodeElement.facts")
.type OpaqueInstruction = Instruction

.decl isOpaqueInstruction(?insn:OpaqueInstruction)
.output isOpaqueInstruction



isOpaqueInstruction(?instruction) :-
   _StaticMethodInvocation(?instruction, _, ?signature, _),
   isOpaqueMethod(?signature).
isOpaqueInstruction(?instruction) :-
   _SpecialMethodInvocation(?instruction, _, ?signature, _, _),
   isOpaqueMethod(?signature).
isOpaqueInstruction(?instruction) :-
   _VirtualMethodInvocation(?instruction, _, ?signature, _, _),
   isOpaqueMethod(?signature).
isOpaqueMethod(m) :- isMethod(m), m = "<sun.misc.ProxyGenerator: byte[] generateClassFile()>" .
isType(?t) :- isPrimitiveType(?t) ; isReferenceType(?t).

isReferenceType(?t) :-
  isNullType(?t) ; isArrayType(?t) ; isClassType(?t) ; isInterfaceType(?t) ; isAnnotation(?t).

isHeapAllocation(?h) :-
  isNormalHeap(?h) ; isStringConstant(?h) ; isClassHeap(?h) ; isMethodHandleConstant(?h) ; isMethodTypeConstant(?h).


isInstruction(?i) :-
  isThrow_Insn(?i) ; isGoto_Insn(?i) ; isIf_Insn(?i) ; isSwitch_Insn(?i) ; isMonitorInstruction(?i) ;
  isFieldInstruction(?i) ; isArrayInstruction(?i) ; isAssignInstruction(?i) ;
  isReturnInstruction(?i) ; isMethodInvocation(?i) ; isUnsupportedInstruction(?i).

isThrowNull_Insn(?i) :- isThrow_Insn(?i).

isSwitch_Insn(?i) :- isTableSwitch_Insn(?i) ; isLookupSwitch_Insn(?i).

isMonitorInstruction(?i) :- isEnterMonitor_Insn(?i) ; isExitMonitor_Insn(?i).

isFieldInstruction(?i) :-
  isLoadInstanceField_Insn(?i) ; isStoreInstanceField_Insn(?i) ;
  isLoadStaticField_Insn(?i) ; isStoreStaticField_Insn(?i).

isArrayInstruction(?i) :- isLoadArrayIndex_Insn(?i) ; isStoreArrayIndex_Insn(?i).

isAssignInstruction(?i) :-
  isAssignOper_Insn(?i) ; isAssignInstanceOf_Insn(?i) ; isAssignNull_Insn(?i) ;
  isAssignNumConstant_Insn(?i) ; isAssignCast_Insn(?i) ; isAssignHeapAllocation_Insn(?i).

isAssignOper_Insn(?i) :-
  isAssignBinop_Insn(?i) ; isAssignUnop_Insn(?i) ; isAssignLocal_Insn(?i).

isAssignCast_Insn(?i) :- isAssignCastNumConstant_Insn(?i) ; isAssignCastNull_Insn(?i).

isReturnInstruction(?i) :- isReturnVoid_Insn(?i) ; isReturnNonvoid_Insn(?i).

isMethodInvocation(?i) :-
  isVirtualMethodInvocation_Insn(?i) ; isSpecialMethodInvocation_Insn(?i) ; isStaticMethodInvocation_Insn(?i) ;
  isSuperMethodInvocation_Insn(?i) ; isDynamicMethodInvocation_Insn(?i).

isUnsupportedInstruction(?i) :- isAssignPhantomInvoke(?i) ; isBreakpointStmt(?i).





.decl _ClassType(?class:ClassType)
.input _ClassType(filename="ClassType.facts")

isClassType(?class) :- _ClassType(?class).




.decl _ArrayType(?arrayType:ArrayType)
.input _ArrayType(filename="ArrayType.facts")

isArrayType(?arrayType) :- _ArrayType(?arrayType).




.decl _InterfaceType(?interface:InterfaceType)
.input _InterfaceType(filename="InterfaceType.facts")

isInterfaceType(?interface) :- _InterfaceType(?interface).




.decl _ComponentType(?arrayType:ArrayType, ?componentType:Type)
.input _ComponentType(filename="ComponentType.facts")

isArrayType(?arrayType),
isType(?componentType),
ComponentType(?arrayType, ?componentType) :-
  _ComponentType(?arrayType, ?componentType).




.decl _ActualParam(?index:number, ?invocation:MethodInvocation, ?var:Var)
.input _ActualParam(filename="ActualParam.facts")

isMethodInvocation(?invocation),
isVar(?var),
ActualParam(?index, ?invocation, ?var) :-
  _ActualParam(?index, ?invocation, ?var).



.decl _BootstrapParam(?index:number, ?invocation:MethodInvocation, ?var:Var)
.input _BootstrapParam(filename="BootstrapParam.facts")

isDynamicMethodInvocation_Insn(?invocation),
isVar(?var),
BootstrapParam(?index, ?invocation, ?var) :-
  _BootstrapParam(?index, ?invocation, ?var).



.decl _DirectSuperinterface(?class:ReferenceType, ?interface:InterfaceType)
.input _DirectSuperinterface(filename="DirectSuperinterface.facts")

isReferenceType(?class),
isInterfaceType(?interface),
DirectSuperinterface(?class, ?interface) :-
  _DirectSuperinterface(?class, ?interface).




.decl _DirectSuperclass(?class:ClassType, ?superclass:ClassType)
.input _DirectSuperclass(filename="DirectSuperclass.facts")

isClassType(?class),
isClassType(?superclass),
DirectSuperclass(?class, ?superclass) :-
  _DirectSuperclass(?class, ?superclass).




.decl _Field_Modifier(?modifier:Modifier, ?field:Field)
.input _Field_Modifier(filename="Field-Modifier.facts")

isModifier(?modifier),
isField(?field),
Field_Modifier(?modifier, ?field) :-
  _Field_Modifier(?modifier, ?field).




.decl _ClassModifier(?modifier:Modifier, ?class:ReferenceType)
.input _ClassModifier(filename="ClassModifier.facts")

ClassModifier(?modifier, ?class) :-
  _ClassModifier(?modifier, ?class).




.decl _FormalParam(?index:number, ?method:Method, ?var:Var)
.input _FormalParam(filename="FormalParam.facts")

isMethod(?method),
isVar(?var),
FormalParam(?index, ?method, ?var) :-
  _FormalParam(?index, ?method, ?var).




.decl _Method_DeclaresException(?exceptionType:ReferenceType, ?method:Method)
.input _Method_DeclaresException(filename="Method-DeclaresException.facts")

isReferenceType(?exceptionType),
isMethod(?method),
Method_DeclaresException(?exceptionType, ?method) :-
  _Method_DeclaresException(?exceptionType, ?method).




.decl _Method_Modifier(?mod:Modifier, ?method:Method)
.input _Method_Modifier(filename="Method-Modifier.facts")

isModifier(?mod),
isMethod(?method),
Method_Modifier(?mod, ?method) :-
  _Method_Modifier(?mod, ?method).




.decl _NativeReturnVar(?var:Var, ?method:Method)
.input _NativeReturnVar(filename="NativeReturnVar.facts")

isVar(?var),
isMethod(?method),
NativeReturnVar(?var, ?method) :-
  _NativeReturnVar(?var, ?method).




.decl _Var_Type(?var:Var, ?type:Type)
.input _Var_Type(filename="Var-Type.facts")

isVar(?var),
isType(?type),
Var_Type(?var, ?type) :-
  _Var_Type(?var, ?type).




.decl _Var_DeclaringMethod(?var:Var, ?method:Method)
.input _Var_DeclaringMethod(filename="Var-DeclaringMethod.facts")

isVar(?var),
isMethod(?method),
Var_DeclaringMethod(?var, ?method) :-
  _Var_DeclaringMethod(?var, ?method).




.decl _Var_SimpleName(?var:Var, ?simplename:symbol)
.input _Var_SimpleName(filename="Var-SimpleName.facts")

isVar(?var),
Var_SimpleName(?var, ?simplename) :-
  _Var_SimpleName(?var, ?simplename).




.decl _ApplicationClass(?type:ReferenceType)
.input _ApplicationClass(filename="ApplicationClass.facts")

isReferenceType(?type),
ApplicationClass(?type) :-
  _ApplicationClass(?type).




.decl _ApplicationPackage(?package:symbol)
.input _ApplicationPackage(filename="ApplicationPackage.facts")




.decl _ThisVar(?method:Method, ?var:Var)
.input _ThisVar(filename="ThisVar.facts")

isMethod(?method),
isVar(?var),
ThisVar(?method, ?var) :-
  _ThisVar(?method, ?var).




.decl _ExceptionHandler_Previous(?handler:ExceptionHandler, ?previous:ExceptionHandler)
.input _ExceptionHandler_Previous(filename="ExceptionHandler-Previous.facts")

isExceptionHandler(?handler),
isExceptionHandler(?previous),
ExceptionHandler_Previous(?handler, ?previous) :-
  _ExceptionHandler_Previous(?handler, ?previous).




.decl _AssignReturnValue(?invocation:MethodInvocation, ?to:Var)
.input _AssignReturnValue(filename="AssignReturnValue.facts")

isMethodInvocation(?invocation),
isVar(?to),
AssignReturnValue(?invocation, ?to) :-
  _AssignReturnValue(?invocation, ?to).



.input Properties


.decl _OperatorAt(?instruction:Instruction, ?operator:symbol)
.input _OperatorAt(filename="OperatorAt.facts")


.input MainClass

MainClass(?b):-
  MainClass(?a),
  ?l1 = strlen(?a),
  ?l2 = strlen("Example"),
  ?b = substr(?a, ?l1 - ?l2, ?l2),
  match(".*Example",?a).



.decl _ClassArtifact(?artifact:symbol, ?className:ReferenceType, ?subArtifact:symbol, ?size:number)
.input _ClassArtifact(filename="Class-Artifact.facts")



.decl _NormalHeap(?id:NormalHeap, ?type:ReferenceType)
.input _NormalHeap(filename="NormalHeap.facts")

isType(?type),
isNormalHeap(?id),
OriginalHeapAllocation_Type(?id, ?type),
HeapAllocation_Type(?id, ?type) :-
  _NormalHeap(?id, ?type).

isClassType("java.lang.String").




.decl _StringConstant(?id:StringConstant)
.input _StringConstant(filename="StringConstant.facts")

isStringConstant(?id),
OriginalHeapAllocation_Type(?id, "java.lang.String"),
HeapAllocation_Type(?id, "java.lang.String") :-
  _StringConstant(?id).




.decl _StringRaw(?id:symbol, ?rawId:symbol)
.input _StringRaw(filename="StringRaw.facts")

.decl String_toRaw(?id:symbol, ?rawId:symbol)

isStringRaw(?id),
String_toRaw(?id, ?rawId) :-
  _StringRaw(?id, ?rawId).




.decl _ClassHeap(?id:ClassHeap, ?instanceType:ReferenceType)
.input _ClassHeap(filename="ClassHeap.facts")

isType(?instanceType),
isClassHeap(?id),
ClassHeap_InstanceType(?id, ?instanceType),
OriginalHeapAllocation_Type(?id, "java.lang.Class"),
HeapAllocation_Type(?id, "java.lang.Class") :-
  _ClassHeap(?id, ?instanceType).



.decl _MethodHandleConstant(?id:MethodHandleConstant, ?method:Method, ?retType:Type, ?paramTypes:symbol, ?arity:number)
.input _MethodHandleConstant(filename="MethodHandleConstant.facts")

isType("java.lang.invoke.MethodHandle").
isReferenceType("java.lang.invoke.MethodHandle").
isClassType("java.lang.invoke.MethodHandle").

isMethodHandleConstant(?id),
OriginalHeapAllocation_Type(?id, "java.lang.invoke.MethodHandle"),
MethodHandleConstant_Method(?id, ?method),
MethodHandleConstant_Arity(?id, ?arity),
MethodHandleConstant_ReturnType(?id, ?retType),
MethodHandleConstant_ParamTypes(?id, ?paramTypes),
HeapAllocation_Type(?id, "java.lang.invoke.MethodHandle") :-
  _MethodHandleConstant(?id, ?method, ?retType, ?paramTypes, ?arity).



.decl _MethodTypeConstant(?id:MethodTypeConstant, ?arity:number, ?retType:Type, ?paramTypes:symbol)
.input _MethodTypeConstant(filename="MethodTypeConstant.facts")

isMethodTypeConstant(?id),
HeapAllocation_Type(?id, "java.lang.invoke.MethodType"),
MethodTypeConstant_Arity(?id, ?arity),
MethodTypeConstant_ReturnType(?id, ?retType),
MethodTypeConstant_ParamTypes(?id, ?paramTypes),
OriginalHeapAllocation_Type(?id, "java.lang.invoke.MethodType") :-
  _MethodTypeConstant(?id, ?arity, ?retType, ?paramTypes).

.decl _MethodTypeConstantParam(?id:MethodTypeConstant, ?idx:number, ?type:Type)
.input _MethodTypeConstantParam(filename="MethodTypeConstantParam.facts")



.decl _NativeLibEntryPoint(?lib:symbol, ?function:symbol, ?addr:symbol)
.input _NativeLibEntryPoint(filename="NativeLibEntryPoint.facts")

.decl _NativeMethodTypeCandidate(?lib:symbol, ?function:symbol, ?descriptor:symbol, ?offset2:number)
.input _NativeMethodTypeCandidate(filename="NativeMethodTypeCandidate.facts")

.decl _NativeNameCandidate(?lib:symbol, ?function:symbol, ?name:symbol, ?offset1:number)
.input _NativeNameCandidate(filename="NativeNameCandidate.facts")

.decl _NativeMethodId(?javaMethod:Method, ?nativeId:symbol)
.input _NativeMethodId(filename="NativeMethodId.facts")

.decl _NativeXRef(?string:symbol, ?lib:symbol, ?function:symbol, ?dataAddr:number)
.input _NativeXRef(filename="NativeXRef.facts")



.decl _EmptyArray(?id:HeapAllocation)
.input _EmptyArray(filename="EmptyArray.facts")

HeapAllocation_EmptyArray(?id) :-
  _EmptyArray(?id).



.decl _ArrayAllocation(?instruction:Instruction, ?pos:number, ?sizeVar:Var)
.input _ArrayAllocation(filename="ArrayAllocation.facts")

ArrayAllocation(?insn, ?pos, ?sizeVar) :-
  _ArrayAllocation(?insn, ?pos, ?sizeVar).




.decl _AssignHeapAllocation(?instruction:AssignHeapAllocation_Insn, ?index:number, ?heap:HeapAllocation, ?to:Var, ?inmethod:Method, ?linenumber:number)
.input _AssignHeapAllocation(filename="AssignHeapAllocation.facts")

isAssignHeapAllocation_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Line(?instruction, ?linenumber),
Instruction_Method(?instruction, ?method),
AssignInstruction_To(?instruction, ?to),
AssignHeapAllocation_Heap(?instruction, ?heap) :-
  _AssignHeapAllocation(?instruction, ?index, ?heap, ?to, ?method, ?linenumber).




.decl _AssignLocal(?instruction:AssignLocal_Insn, ?index:number, ?from:Var, ?to:Var, ?inmethod:Method)
.input _AssignLocal(filename="AssignLocal.facts")

isAssignLocal_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignLocal_From(?instruction, ?from),
AssignInstruction_To(?instruction, ?to) :-
  _AssignLocal(?instruction, ?index, ?from, ?to, ?method).




.decl _AssignBinop(?instruction:AssignBinop_Insn, ?index:number, ?to:Var, ?inmethod:Method)
.input _AssignBinop(filename="AssignBinop.facts")

isAssignBinop_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignInstruction_To(?instruction, ?to) :-
  _AssignBinop(?instruction, ?index, ?to, ?method).




.decl _AssignUnop(?instruction:AssignUnop_Insn, ?index:number, ?to:Var, ?inmethod:Method)
.input _AssignUnop(filename="AssignUnop.facts")

isAssignUnop_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignInstruction_To(?instruction, ?to) :-
  _AssignUnop(?instruction, ?index, ?to, ?method).




.decl _AssignOperFrom(?instruction:AssignOper_Insn, ?pos: number, ?from:Var)
.input _AssignOperFrom(filename="AssignOperFrom.facts")

AssignOper_From(?instruction, ?pos, ?from) :-
  _AssignOperFrom(?instruction, ?pos, ?from).



.decl _AssignOperFromConstant(?instruction:AssignOper_Insn, ?pos: number, ?from:NumConstant)
.input _AssignOperFromConstant(filename="AssignOperFromConstant.facts")

AssignOper_FromConstant(?instruction, ?pos, ?from) :-
  _AssignOperFromConstant(?instruction, ?pos, ?from).



.decl _IfConstant(?instruction:If_Insn, ?pos:number, ?cons:NumConstant)
.input _IfConstant(filename="IfConstant.facts")

If_Constant(?instruction, ?pos, ?cons) :-
  _IfConstant(?instruction, ?pos, ?cons).




.decl _IfVar(?instruction:If_Insn, ?pos:number, ?var:Var)
.input _IfVar(filename="IfVar.facts")

If_Var(?instruction, ?pos, ?var) :-
  _IfVar(?instruction, ?pos, ?var).



.decl _DummyIfVar(?instruction:If_Insn, ?var:Var)
.input _DummyIfVar(filename="DummyIfVar.facts")

DummyIf_Var(?instruction, ?var) :-
  _DummyIfVar(?instruction, ?var).



.decl _AssignCast(?instruction:AssignCast_Insn, ?index:number, ?from:Var, ?to:Var, ?type:Type, ?inmethod:Method)
.input _AssignCast(filename="AssignCast.facts")

isAssignCast_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignCast_Type(?instruction, ?type),
AssignCast_From(?instruction, ?from),
AssignInstruction_To(?instruction, ?to) :-
  _AssignCast(?instruction, ?index, ?from, ?to, ?type, ?method).




.decl _AssignCastNumConstant(?instruction:AssignCastNumConstant_Insn, ?index:number, ?const:symbol, ?to:Var, ?type:Type, ?inmethod:Method)
.input _AssignCastNumConstant(filename="AssignCastNumConstant.facts")

isAssignCastNumConstant_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignCast_Type(?instruction, ?type),
AssignCastNumConstant_Id(?instruction, ?const),
AssignInstruction_To(?instruction, ?to) :-
  _AssignCastNumConstant(?instruction, ?index, ?const, ?to, ?type, ?method).




.decl _AssignCastNull(?instruction:AssignCastNull_Insn, ?index:number, ?to:Var, ?type:Type, ?method:Method)
.input _AssignCastNull(filename="AssignCastNull.facts")

isAssignCastNull_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignCast_Type(?instruction, ?type),
AssignInstruction_To(?instruction, ?to) :-
  _AssignCastNull(?instruction, ?index, ?to, ?type, ?method).




.decl _AssignNumConstant(?instruction:AssignNumConstant_Insn, ?index:number, ?const:NumConstant, ?to:Var, ?inmethod:Method)
.input _AssignNumConstant(filename="AssignNumConstant.facts")

isNumConstant(?const),
isAssignNumConstant_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignNumConstant_Id(?instruction, ?const),
AssignInstruction_To(?instruction, ?to) :-
  _AssignNumConstant(?instruction, ?index, ?const, ?to, ?method).




.decl _AssignNull(?instruction:AssignNull_Insn, ?index:number, ?to:Var, ?method:Method)
.input _AssignNull(filename="AssignNull.facts")

isAssignNull_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignInstruction_To(?instruction, ?to) :-
  _AssignNull(?instruction, ?index, ?to, ?method).




.decl _AssignInstanceOf(?instruction:AssignInstanceOf_Insn, ?index:number, ?from:Var, ?to:Var, ?type:Type, ?inmethod:Method)
.input _AssignInstanceOf(filename="AssignInstanceOf.facts")

isAssignInstanceOf_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignInstanceOf_From(?instruction, ?from),
AssignInstanceOf_Type(?instruction, ?type),
AssignInstruction_To(?instruction, ?to) :-
  _AssignInstanceOf(?instruction, ?index, ?from, ?to, ?type, ?method).




.decl _Field(?signature:Field, ?declaringClass:ReferenceType, ?simplename:symbol, ?type:Type)
.input _Field(filename="Field.facts")

isField(?signature),
Field_DeclaringType(?signature, ?declaringType),
Field_SimpleName(?signature, ?simplename),
Field_Type(?signature, ?type) :-
  _Field(?signature, ?declaringType, ?simplename, ?type).



.decl _EnterMonitor(?instruction:EnterMonitor_Insn, ?index:number, ?var:Var, ?method:Method)
.input _EnterMonitor(filename="EnterMonitor.facts")

isEnterMonitor_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
EnterMonitor_Var(?instruction, ?var) :-
  _EnterMonitor(?instruction, ?index, ?var, ?method).




.decl _ExitMonitor(?instruction:ExitMonitor_Insn, ?index:number, ?var:Var, ?method:Method)
.input _ExitMonitor(filename="ExitMonitor.facts")

isExitMonitor_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
ExitMonitor_Var(?instruction, ?var) :-
  _ExitMonitor(?instruction, ?index, ?var, ?method).




.decl _MethodInvocation_Line(?instruction:MethodInvocation, line:number)
.input _MethodInvocation_Line(filename="MethodInvocation-Line.facts")

isMethodInvocation(?instruction),
MethodInvocation_Line(?instruction, ?line) :-
  _MethodInvocation_Line(?instruction, ?line).

MethodInvocation_Base(?invocation, ?base) :-
  VirtualMethodInvocation_Base(?invocation, ?base).
MethodInvocation_Base(?invocation, ?base) :-
  SpecialMethodInvocation_Base(?invocation, ?base).




.decl _StaticMethodInvocation(?instruction:StaticMethodInvocation_Insn, ?index:number, ?signature:Method, ?method:Method)
.input _StaticMethodInvocation(filename="StaticMethodInvocation.facts")

isMethod(?signature),
isMethodInvocation(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
MethodInvocation_Method(?instruction, ?signature) :-
  _StaticMethodInvocation(?instruction, ?index, ?signature, ?method).

isStaticMethodInvocation_Insn(?instruction) :-
  _StaticMethodInvocation(?instruction, _, ?signature, _),
  !isOpaqueMethod(?signature).



.decl _SpecialMethodInvocation(?instruction:SpecialMethodInvocation_Insn, ?index:number, ?signature:Method, ?base:Var, ?method:Method)
.input _SpecialMethodInvocation(filename="SpecialMethodInvocation.facts")

isMethod(?signature),
isMethodInvocation(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
MethodInvocation_Method(?instruction, ?signature) :-
  _SpecialMethodInvocation(?instruction, ?index, ?signature, _, ?method).

isSpecialMethodInvocation_Insn(?instruction),
SpecialMethodInvocation_Base(?instruction, ?base) :-
  _SpecialMethodInvocation(?instruction, _, ?signature, ?base, _),
  !isOpaqueMethod(?signature).



.decl _VirtualMethodInvocation(?instruction:VirtualMethodInvocation_Insn, ?index:number, ?signature:Method, ?base:Var, ?method:Method)
.input _VirtualMethodInvocation(filename="VirtualMethodInvocation.facts")

isMethod(?signature),
isMethodInvocation(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
MethodInvocation_Method(?instruction, ?signature) :-
  _VirtualMethodInvocation(?instruction, ?index, ?signature, _, ?method).

isVirtualMethodInvocation_Insn(?instruction),
VirtualMethodInvocation_Base(?instruction, ?base) :-
  _VirtualMethodInvocation(?instruction, _, ?signature, ?base, _),
  !isOpaqueMethod(?signature).



.decl _SuperMethodInvocation(?instruction:SuperMethodInvocation_Insn, ?index:number, ?signature:Method, ?base:Var, ?method:Method)
.input _SuperMethodInvocation(filename="SuperMethodInvocation.facts")

isMethod(?signature),
isMethodInvocation(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
MethodInvocation_Method(?instruction, ?signature),
isSuperMethodInvocation_Insn(?instruction),
SuperMethodInvocation_Base(?instruction, ?base) :-
  _SuperMethodInvocation(?instruction, ?index, ?signature, ?base, ?method).



.decl _DynamicMethodInvocation(?instruction:DynamicMethodInvocation_Insn, ?index:number, ?bootSignature:Method, ?dynName:symbol, ?dynRetType:Type, ?dynArity:number, ?dynParamTypes:symbol, ?tag:number, ?method:Method)
.input _DynamicMethodInvocation(filename="DynamicMethodInvocation.facts")

isDynamicMethodInvocation_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
DynamicMethodInvocation_Bootstrap(?instruction, ?bootSignature),
DynamicMethodInvocation_DynName(?instruction, ?dynName),
DynamicMethodInvocation_DynReturnType(?instruction, ?dynRetType),
DynamicMethodInvocation_DynParamTypes(?instruction, ?dynParamTypes),
DynamicMethodInvocation_HandleTag(?instruction, ?tag),
DynamicMethodInvocation_DynArity(?instruction, ?dynArity) :-
  _DynamicMethodInvocation(?instruction, ?index, ?bootSignature, ?dynName, ?dynRetType, ?dynArity, ?dynParamTypes, ?tag, ?method).

.decl _DynamicMethodInvocation_DynParamType(?invocation:DynamicMethodInvocation_Insn, ?idx:number, ?pType:Type)
.input _DynamicMethodInvocation_DynParamType(filename="DynamicMethodInvocation-ParamType.facts")




.decl _PolymorphicInvocation(?invocation:MethodInvocation, ?simpleName:symbol)
.input _PolymorphicInvocation(filename="PolymorphicInvocation.facts")



.decl _Throw(?instruction:Throw_Insn, ?index:number, ?var:Var, ?method:Method)
.input _Throw(filename="Throw.facts")

isThrow_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
Throw(?instruction, ?var),
Throw_Var(?instruction, ?var) :-
  _Throw(?instruction, ?index, ?var, ?method).




.decl _ThrowNull(?instruction:ThrowNull_Insn, ?index:number, ?method:Method)
.input _ThrowNull(filename="ThrowNull.facts")

isThrowNull_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method) :-
  _ThrowNull(?instruction, ?index, ?method).




.decl _ExceptionHandler(?handler:ExceptionHandler, ?method:Method, ?index:number, ?type:ReferenceType, ?begin:number, ?end:number)
.input _ExceptionHandler(filename="ExceptionHandler.facts")

isExceptionHandler(?handler),
isInstruction(?handler),
Instruction_Index(?handler, ?index),
Instruction_Method(?handler, ?method),
ExceptionHandler_Method(?handler, ?method),
ExceptionHandler_Index(?handler, ?index),
ExceptionHandler_Type(?handler, ?type),
ExceptionHandler_Begin(?handler, ?begin),
ExceptionHandler_End(?handler, ?end) :-
  _ExceptionHandler(?handler, ?method, ?index, ?type, ?begin, ?end).

.input ExceptionHandler_FormalParam(filename="ExceptionHandler-FormalParam.facts")



.decl _Method(?method:Method, ?simplename:symbol, ?descriptor:symbol, ?declaringType:ReferenceType, ?returnType:Type, ?jvmDescriptor:JVMDescriptor, ?arity:number)
.input _Method(filename="Method.facts")

isMethod(?method),
isJVMDescriptor(?jvmDescriptor),
Method_SimpleName(?method, ?simplename),
Method_ParamTypes(?method, ?params),
Method_DeclaringType(?method, ?declaringType),
Method_JVMDescriptor(?method, ?jvmDescriptor),
Method_Arity(?method, ?arity),
Method_ReturnType(?method, ?returnType) :-
  _Method(?method, ?simplename, ?params, ?declaringType, ?returnType, ?jvmDescriptor, ?arity).

isMethodDescriptor(?descriptor),
Method_Descriptor(?method, ?descriptor) :-
  Method_ReturnType(?method, ?returnType),
  Method_ParamTypes(?method, ?params),
  ?descriptor = cat(?returnType, cat("(", cat(?params, ")"))).



.decl _StoreInstanceField(?instruction:StoreInstanceField_Insn, ?index:number, ?from:Var, ?base:Var, ?signature:Field, ?method:Method)
.input _StoreInstanceField(filename="StoreInstanceField.facts")

isStoreInstanceField_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
FieldInstruction_Signature(?instruction, ?signature),
StoreInstanceField_Base(?instruction, ?base),
StoreInstanceField_From(?instruction, ?from) :-
  _StoreInstanceField(?instruction, ?index, ?from, ?base, ?signature, ?method).




.decl _LoadInstanceField(?instruction:LoadInstanceField_Insn, ?index:number, ?to:Var, ?base:Var, ?signature:Field, ?method:Method)
.input _LoadInstanceField(filename="LoadInstanceField.facts")

isLoadInstanceField_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
FieldInstruction_Signature(?instruction, ?signature),
LoadInstanceField_Base(?instruction, ?base),
LoadInstanceField_To(?instruction, ?to) :-
  _LoadInstanceField(?instruction, ?index, ?to, ?base, ?signature, ?method).




.decl _StoreStaticField(?instruction:StoreStaticField_Insn, ?index:number, ?from:Var, ?signature:Field, ?method:Method)
.input _StoreStaticField(filename="StoreStaticField.facts")

isStoreStaticField_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
FieldInstruction_Signature(?instruction, ?signature),
StoreStaticField_From(?instruction, ?from) :-
  _StoreStaticField(?instruction, ?index, ?from, ?signature, ?method).




.decl _LoadStaticField(?instruction:LoadStaticField_Insn, ?index:number, ?to:Var, ?signature:Field, ?method:Method)
.input _LoadStaticField(filename="LoadStaticField.facts")

isLoadStaticField_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
FieldInstruction_Signature(?instruction, ?signature),
LoadStaticField_To(?instruction, ?to) :-
  _LoadStaticField(?instruction, ?index, ?to, ?signature, ?method).




.decl _StoreArrayIndex(?instruction:StoreArrayIndex_Insn, ?index:number, ?from:Var, ?base:Var, ?method:Method)
.input _StoreArrayIndex(filename="StoreArrayIndex.facts")

isStoreArrayIndex_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
StoreArrayIndex_Base(?instruction, ?base),
StoreArrayIndex_From(?instruction, ?from) :-
  _StoreArrayIndex(?instruction, ?index, ?from, ?base, ?method).




.decl _LoadArrayIndex(?instruction:LoadArrayIndex_Insn, ?index:number, ?to:Var, ?base:Var, ?method:Method)
.input _LoadArrayIndex(filename="LoadArrayIndex.facts")

isLoadArrayIndex_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
LoadArrayIndex_Base(?instruction, ?base),
LoadArrayIndex_To(?instruction, ?to) :-
  _LoadArrayIndex(?instruction, ?index, ?to, ?base, ?method).




.decl _ArrayInsnIndex(?instruction:Instruction, ?index:Var)
.input _ArrayInsnIndex(filename="ArrayInsnIndex.facts")

ArrayInsnIndex(?instruction, ?index) :-
  _ArrayInsnIndex(?instruction, ?index).




.decl _ArrayNumIndex(?instruction:Instruction, ?index:number)
.input _ArrayNumIndex(filename="ArrayNumIndex.facts")

ArrayNumIndex(?instruction, ?index) :-
  _ArrayNumIndex(?instruction, ?index).




.decl _Goto(?instruction:Goto_Insn, ?index:number, ?to:number, ?method:Method)
.input _Goto(filename="Goto.facts")

isGoto_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
Goto_Target(?instruction, ?to) :-
  _Goto(?instruction, ?index, ?to, ?method).




.decl _If(?instruction:If_Insn, ?index:number, ?to:number, ?method:Method)
.input _If(filename="If.facts")

isIf_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
If_Target(?instruction, ?to) :-
  _If(?instruction, ?index, ?to, ?method).




.decl _TableSwitch(?instruction:TableSwitch_Insn, ?index:number, ?key:Var, ?method:Method)
.input _TableSwitch(filename="TableSwitch.facts")

isTableSwitch_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
Switch_Key(?instruction, ?key) :-
  _TableSwitch(?instruction, ?index, ?key, ?method).


.decl _LookupSwitch(?instruction:LookupSwitch_Insn, ?index:number, ?key:Var, ?method:Method)
.input _LookupSwitch(filename="LookupSwitch.facts")

isLookupSwitch_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
Switch_Key(?instruction, ?key) :-
  _LookupSwitch(?instruction, ?index, ?key, ?method).




.decl _TableSwitch_Target(?instruction:Switch_Insn, ?value:number, ?target:number)
.input _TableSwitch_Target(filename="TableSwitch-Target.facts")

Switch_Target(?instruction, ?value, ?target) :-
  _TableSwitch_Target(?instruction, ?value, ?target).


.decl _LookupSwitch_Target(?instruction:Switch_Insn, ?value:number, ?target:number)
.input _LookupSwitch_Target(filename="LookupSwitch-Target.facts")

Switch_Target(?instruction, ?value, ?target) :-
  _LookupSwitch_Target(?instruction, ?value, ?target).



.decl _TableSwitch_DefaultTarget(?instruction:Switch_Insn, ?target:number)
.input _TableSwitch_DefaultTarget(filename="TableSwitch-Default.facts")

Switch_DefaultTarget(?instruction, ?target) :-
  _TableSwitch_DefaultTarget(?instruction, ?target).


.decl _LookupSwitch_DefaultTarget(?instruction:Switch_Insn, ?target:number)
.input _LookupSwitch_DefaultTarget(filename="LookupSwitch-Default.facts")

Switch_DefaultTarget(?instruction, ?target) :-
  _LookupSwitch_DefaultTarget(?instruction, ?target).




.decl _Return(?instruction:ReturnNonvoid_Insn, ?index:number, ?var:Var, ?method:Method)
.input _Return(filename="Return.facts")

isReturnNonvoid_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
ReturnNonvoid_Var(?instruction, ?var) :-
  _Return(?instruction, ?index, ?var, ?method).




.decl _ReturnVoid(?instruction:ReturnVoid_Insn, ?index:number, ?method:Method)
.input _ReturnVoid(filename="ReturnVoid.facts")

isReturnVoid_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method) :-
  _ReturnVoid(?instruction, ?index, ?method).




.decl _AssignPhantomInvoke(?instruction:AssignPhantomInvoke, ?index:number, ?method:Method)
.input _AssignPhantomInvoke(filename="AssignPhantomInvoke.facts")

isAssignPhantomInvoke(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method) :-
  _AssignPhantomInvoke(?instruction, ?index, ?method).




.decl _BreakpointStmt(?instruction:BreakpointStmt, ?index:number, ?method:Method)
.input _BreakpointStmt(filename="BreakpointStmt.facts")

isBreakpointStmt(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method) :-
  _BreakpointStmt(?instruction, ?index, ?method).




.decl _UnsupportedInstruction(?instruction:UnsupportedInstruction, ?index:number, ?method:Method)
.input _UnsupportedInstruction(filename="UnsupportedInstruction.facts")

isUnsupportedInstruction(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method) :-
  _UnsupportedInstruction(?instruction, ?index, ?method).




isModifier(?x), Modifier_abstract(?x) :- ?x = "abstract".
isModifier(?x), Modifier_public(?x) :- ?x = "public".
isModifier(?x), Modifier_private(?x) :- ?x = "private".
isModifier(?x), Modifier_final(?x) :- ?x = "final".
isModifier(?x), Modifier_static(?x) :- ?x = "static".




isPrimitiveType(?t), Type_boolean(?t) :- ?t = "boolean".
isPrimitiveType(?t), Type_byte(?t) :- ?t = "byte".
isPrimitiveType(?t), Type_char(?t) :- ?t = "char".
isPrimitiveType(?t), Type_short(?t) :- ?t = "short".
isPrimitiveType(?t), Type_int(?t) :- ?t = "int".
isPrimitiveType(?t), Type_long(?t) :- ?t = "long".
isPrimitiveType(?t), Type_float(?t) :- ?t = "float".
isPrimitiveType(?t), Type_double(?t) :- ?t = "double".
isPrimitiveType(?t), Type_void(?t) :- ?t = "void".

isNullType(?t), Type_null(?t) :- ?t = "null_type".

isClassType(?t), Type_object(?t) :- ?t = "java.lang.Object".




.input Type_Annotation(filename="Type-Annotation.facts")

.input Method_Annotation(filename="Method-Annotation.facts")

.input Field_Annotation(filename="Field-Annotation.facts")

.input Param_Annotation(filename="Param-Annotation.facts")

isAnnotation(?annotation) :- isReferenceType(?annotation), Type_Annotation(_, ?annotation).
isAnnotation(?annotation) :- isReferenceType(?annotation), Method_Annotation(_, ?annotation).
isAnnotation(?annotation) :- isReferenceType(?annotation), Field_Annotation(_, ?annotation).
isAnnotation(?annotation) :- isReferenceType(?annotation), Param_Annotation(_, _, ?annotation).


.input AnnotationElement(filename="AnnotationElement.facts")


.decl PhantomType(?t:ReferenceType)
.input PhantomType(filename="PhantomType.facts")
.decl PhantomMethod(?m:Method)
.input PhantomMethod(filename="PhantomMethod.facts")
.decl PhantomBasedMethod(?m:Method)
.input PhantomBasedMethod(filename="PhantomBasedMethod.facts")


isHeapAllocation(?heap), isMethodHandleConstant(?heap), MethodHandleConstant_Method(?heap, ?method), HeapAllocation_Type(?heap, "java.lang.invoke.MethodHandle")  :-
  MethodHandleConstant_Method(?heap, ?method).

isHeapAllocation(?null), HeapAllocation_Type(?null, ?type) ,
HeapAllocation_Null(?null) :-
  ?null = "<<null pseudo heap>>",
  Type_null(?type).

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type) ,
MainMethodArgArray(?heap) :-
  ?heap = "<<main method array>>",
  ?type = "java.lang.String[]".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type) ,
MainMethodArgArrayContent(?heap) :-
  ?heap = "<<main method array content>>",
  ?type = "java.lang.String".

ApplicationField(?field) :-
  Field_DeclaringType(?field, ?type),
  ApplicationClass(?type).

ApplicationMethod(?method) :-
  Method_DeclaringType(?method, ?class),
  ApplicationClass(?class).

ApplicationVar(?var) :-
  Var_DeclaringMethod(?var, ?method),
  ApplicationMethod(?method).

ApplicationInvocation(?invocation) :-
  isMethodInvocation(?invocation),
  Instruction_Method(?invocation, ?method),
  ApplicationMethod(?method).

ApplicationAllocation(?heap) :-
  isAssignHeapAllocation_Insn(?insn),
  Instruction_Method(?insn, ?method),
  ApplicationMethod(?method),
  AssignHeapAllocation_Heap(?insn, ?heap).

ConcreteClass(?class) :-
  isClassType(?class),
  !ClassModifier("abstract", ?class).
isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>/new java.lang.String[]/0",
  ?type = "java.lang.String[]".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>/new java.lang.String/0",
  ?type = "java.lang.String".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<sun.misc.Perf: java.nio.ByteBuffer createLong(java.lang.String,int,int,long)>/new java.nio.DirectByteBuffer/0",
  ?type = "java.nio.DirectByteBuffer".


isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<string-constant>>",
  ?type = "java.lang.String".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<reflection-string-constant>>",
  ?type = "java.lang.String".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<string-buffer>>",
  ?type = "java.lang.StringBuffer".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<string-builder>>",
  ?type = "java.lang.StringBuilder".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<system-thread-group>>",
  ?type = "java.lang.ThreadGroup".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<main-thread-group>>",
  ?type = "java.lang.ThreadGroup".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<main-thread>>",
  ?type = "java.lang.Thread".





isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<initial-context>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<jvm-startup-context>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<jvm-startup-hcontext>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<clinit-context>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<immutable-context>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<immutable-hcontext>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<immutable>>",
  ?type = "java.lang.Object".



.decl CreateIntValue(?n:symbol, ?type:Type, ?declaringType:ReferenceType)

.decl NumConstantRaw(?const:symbol, ?type:Type)
.input NumConstantRaw(filename="NumConstantRaw.facts")


.decl XMLNode(?file:symbol, ?nodeId:symbol, ?parentNodeId:symbol, ?namespaceURI:symbol, ?localName:symbol, ?qName:symbol)
.input XMLNode(filename="XMLNode.facts")
.decl XMLNodeAttribute(?file:symbol, ?nodeId:symbol, ?index:symbol, ?localName:symbol, ?qName:symbol, ?value:symbol)
.input XMLNodeAttribute(filename="XMLNodeAttribute.facts")
.decl XMLNodeData(?file:symbol, ?nodeId:symbol, ?data:symbol)
.input XMLNodeData(filename="XMLNodeData.facts")


.output Instruction_Method
.output Goto_Target
.output If_Target
.output ExceptionHandler_Index
.output ExceptionHandler_Method
.output isIf_Insn
.output isThrow_Insn
.output isGoto_Insn
.output isSwitch_Insn
.output AssignInstruction_To
.output isAssignLocal_Insn
.output isReturnInstruction
.output isInstruction
.output Instruction_Index
.decl Method_FirstInstruction(?method:Method, ?insn:Instruction)
.decl OptInstructionFromMethodIndex(?method:Method, ?index:number, ?insn:Instruction)
.decl Instruction_Next(?i:Instruction, ?next:Instruction)
.decl Instruction_Prev(?i:Instruction, ?prev:Instruction)
.decl JumpTarget(?insn:Instruction, ?prev:Instruction)


.decl IsJumpTarget(?insn:Instruction)
.decl ExceptionHandlerFirstInstruction(?insn:Instruction)
.decl FallThrough(?insn:Instruction)
.decl BasicBlockBegin(?insn:Instruction)
.decl BasicBlockHead(?insn:Instruction, ?headInsn:Instruction)
.decl BasicBlockTail(?headInsn:Instruction, ?tailInsn:Instruction)
.decl BasicBlockEnd(?insn:Instruction)
.decl UnconditionalControlTransfer(?insn:Instruction)






.decl MaySuccessorModuloThrow(?next:Instruction, ?prev:Instruction)
.decl MayPredecessorModuloThrow(?prev:Instruction, ?next:Instruction)



.decl MaySuccessorBBModuloThrow(?next:Instruction, ?prev:Instruction)
.decl MayPredecessorBBModuloThrow(?prev:Instruction, ?next:Instruction)







.decl Dominates(?dominator:Instruction, ?insn:Instruction)



.decl DominatesItsPredecessorInstruction(?prevInsn:Instruction, ?insn:Instruction)



.decl DominatesItsSuccessorInstruction(?insn:Instruction, ?prevInsn:Instruction)




.decl NextInSamePhiNode(?insn1:Instruction, ?insn2:Instruction)
.decl PhiNodeHead(?insn:Instruction, ?headInsn:Instruction)



.decl InstructionInPhiNode(?insn:Instruction, ?headInsn:Instruction)




.decl NextReturn(?insn1:Instruction, ?insn2:Instruction)





Method_FirstInstruction(?method, ?insn) :-
   Instruction_Method(?insn, ?method),
   !Instruction_Prev(?insn, _),
   !IsJumpTarget(?insn),
   !_Throw(?insn, _, _, ?method).

OptInstructionFromMethodIndex(?method, ?index, ?insn) :-
   Instruction_Method(?insn, ?method),
   Instruction_Index(?insn, ?index).

Instruction_Next(?insn, ?next) :-
   Instruction_Method(?insn, ?inMethod),
   Instruction_Index(?insn, ?i),
   OptInstructionFromMethodIndex(?inMethod, ?i + 1, ?next).

Instruction_Prev(?insn, ?prev) :-
   Instruction_Method(?insn, ?inMethod),
   Instruction_Index(?insn, ?i),
   OptInstructionFromMethodIndex(?inMethod, ?i - 1, ?prev).

JumpTarget(?insn, ?goto) :-
   Goto_Target(?goto, ?targetIndex),
   Instruction_Method(?goto, ?gotoMethod),
   OptInstructionFromMethodIndex(?gotoMethod, ?targetIndex, ?insn).
JumpTarget(?insn, ?if) :-
   If_Target(?if, ?targetIndex),
   Instruction_Method(?if, ?method),
   OptInstructionFromMethodIndex(?method, ?targetIndex, ?insn).
JumpTarget(?insn, ?sw) :-
   (Switch_Target(?sw, _, ?targetIndex) ; Switch_DefaultTarget(?sw, ?targetIndex)),
   Instruction_Method(?sw, ?method),
   OptInstructionFromMethodIndex(?method, ?targetIndex, ?insn).

IsJumpTarget(?insn) :-
   JumpTarget(?insn, _).

ExceptionHandlerFirstInstruction(?insn) :-
   ExceptionHandler_Index(?handler, ?index),
   ExceptionHandler_Method(?handler, ?method),
   OptInstructionFromMethodIndex(?method, ?index, ?insn).

FallThrough(?insn) :-
   isIf_Insn(?if),
   Instruction_Next(?if, ?insn).





FallThrough(?insn) :-
   isReturnInstruction(?ret),
   Instruction_Next(?ret, ?insn).
FallThrough(?insn) :-
   isThrow_Insn(?throw),
   Instruction_Next(?throw, ?insn).



BasicBlockBegin(?insn) :-
   OptInstructionFromMethodIndex(_, 1, ?insn).
BasicBlockBegin(?insn) :-
   ExceptionHandlerFirstInstruction(?insn).
BasicBlockBegin(?insn) :-
   JumpTarget(?insn, _).
BasicBlockBegin(?insn) :-
   FallThrough(?insn).

.decl NextInSameBasicBlock(?insn:Instruction, ?next:Instruction)
NextInSameBasicBlock(?insn, ?next) :-
   Instruction_Next(?insn, ?next),
   !BasicBlockBegin(?next).

.decl PrevInSameBasicBlock(?insn:Instruction, ?prev:Instruction)
PrevInSameBasicBlock(?insn, ?prev) :-
   NextInSameBasicBlock(?prev, ?insn).

BasicBlockHead(?insn, ?insn) :-
   BasicBlockBegin(?insn).
BasicBlockHead(?insn, ?headInsn) :-
   BasicBlockHead(?prev, ?headInsn),
   NextInSameBasicBlock(?prev, ?insn).

BasicBlockTail(?headInsn, ?tailInsn) :-
   BasicBlockHead(?tailInsn, ?headInsn),
   !NextInSameBasicBlock(?tailInsn, _).

BasicBlockEnd(?insn) :- BasicBlockTail(_, ?insn).

UnconditionalControlTransfer(?insn) :-
   isGoto_Insn(?insn) ;
   isSwitch_Insn(?insn) ;
   isReturnInstruction(?insn) ;
   isThrow_Insn(?insn).

MaySuccessorModuloThrow(?next, ?prev) :-
   JumpTarget(?next, ?prev).
MaySuccessorModuloThrow(?next, ?insn) :-
   Instruction_Next(?insn, ?next),
   !UnconditionalControlTransfer(?insn).

MayPredecessorModuloThrow(?prev, ?next) :-
   MaySuccessorModuloThrow(?next, ?prev).

MaySuccessorBBModuloThrow(?next, ?prev) :-
   MaySuccessorModuloThrow(?next, ?prevEnd),
   BasicBlockEnd(?prevEnd),
   BasicBlockBegin(?next),
   BasicBlockHead(?prevEnd, ?prev).

MayPredecessorBBModuloThrow(?prev, ?next) :-
   MaySuccessorBBModuloThrow(?next, ?prev).








Dominates(?dominator, ?insn) :-
   SameMethodBBHeads(?dominator, ?insn),
   !DoesNotDominate(?dominator, ?insn).


.decl CFGRoot(?insn:Instruction, ?method:Method)
CFGRoot(?insn, ?method) :-
   OptInstructionFromMethodIndex(?method, 1, ?insn).

CFGRoot(?insn, ?method) :-
   BBHeadInMethod(?insn, ?method),
   !(MayPredecessorBBModuloThrow(_, ?insn)).

.decl ExistsMayPredecessorBBModuloThrow(?insn:Instruction)
ExistsMayPredecessorBBModuloThrow(?insn) :-
   MayPredecessorBBModuloThrow(_, ?insn).



.decl DoesNotDominate(?dominatorCandidate:Instruction, ?insn:Instruction)
DoesNotDominate(?dominatorCandidate, ?insn) :-
   BBHeadInMethod(?dominatorCandidate, ?method),
   CFGRoot(?insn, ?method),
   ?dominatorCandidate != ?insn.

DoesNotDominate(?dominatorCandidate, ?insn) :-
   DoesNotDominate(?dominatorCandidate, ?otherInsn),
   MaySuccessorBBModuloThrow(?insn, ?otherInsn),
   ?insn != ?dominatorCandidate.




DominatesItsPredecessorInstruction(?prevInsn, ?insn) :-
   JumpTarget(?insn, ?prevInsn),
   BasicBlockHead(?prevInsn, ?prevInsnHead),
   (?insn = ?prevInsnHead;
    Dominates(?insn, ?prevInsnHead)).
NextInSamePhiNode(?insn, ?nextInsn) :-
   isAssignLocal_Insn(?insn),
   AssignInstruction_To(?insn, ?var),
   Instruction_Next(?insn, ?nextInsn),
   isAssignLocal_Insn(?nextInsn),
   AssignInstruction_To(?nextInsn, ?var).

PhiNodeHead(?nextInsn, ?insn),
PhiNodeHead(?insn, ?insn) :-
   NextInSamePhiNode(?insn, ?nextInsn),
   Instruction_Prev(?insn, ?prevInsn),
   !NextInSamePhiNode(?prevInsn, ?insn).

PhiNodeHead(?nextInsn, ?insn),
PhiNodeHead(?insn, ?insn) :-
   NextInSamePhiNode(?insn, ?nextInsn),
   !Instruction_Prev(?insn, _).

PhiNodeHead(?nextInsn, ?headInsn) :-
   PhiNodeHead(?phiInsn, ?headInsn),
   NextInSamePhiNode(?phiInsn, ?nextInsn).


InstructionInPhiNode(?insn, ?headInsn) :-
   PhiNodeHead(?insn, ?headInsn).



.decl OptReturnInsn(?insn:Instruction, ?method:Method)
OptReturnInsn(?insn, ?method) :-
   isReturnInstruction(?insn),
   Instruction_Method(?insn, ?method).

.decl HigherReturnIndex(?insn:Instruction, ?indexHigher:number)
HigherReturnIndex(?insn, ?indexHigher) :-
   OptReturnInsn(?insn, ?method),
   OptReturnInsn(?insnHigher, ?method),
   Instruction_Index(?insnHigher, ?indexHigher),
   Instruction_Index(?insn, ?index),
   ?index < ?indexHigher.

.decl NextReturnIndex(?returnInsn:Instruction, ?nextReturnIndex:number)
NextReturnIndex(?returnInsn, ?nextReturnIndex) :-
   isInstruction(?returnInsn),
   ?nextReturnIndex = min ?index : HigherReturnIndex(?returnInsn, ?index).

NextReturn(?returnInsn, ?nextReturnInsn) :-
   NextReturnIndex(?returnInsn, ?nextReturnIndex),
   Instruction_Method(?returnInsn, ?meth),
   OptInstructionFromMethodIndex(?meth, ?nextReturnIndex, ?nextReturnInsn).

.decl ExistsPreviousReturn(?insn:Instruction)
ExistsPreviousReturn(?insn) :-
   NextReturn(_, ?insn).

.decl BBHeadInMethod(?insn:Instruction, ?method:Method)
BBHeadInMethod(?insn, ?method) :-
   BasicBlockBegin(?insn),
   Instruction_Method(?insn, ?method).

.decl SameMethodBBHeads(?insn1:Instruction, ?insn2:Instruction)
SameMethodBBHeads(?insn1, ?insn2) :-
   BBHeadInMethod(?insn1, ?method),
   BBHeadInMethod(?insn2, ?method).





.decl PredecessorBBsToSameBB(?insn:Instruction, ?prev1:Instruction, ?prev2:Instruction)
PredecessorBBsToSameBB(?insn, ?prev1, ?prev2) :-
   MayPredecessorBBModuloThrow(?prev1, ?insn),
   MayPredecessorBBModuloThrow(?prev2, ?insn),
   ?prev1 != ?prev2.

.decl LargerPredecessorIndexToSameBB(?insn:Instruction, ?indexLarge:number, ?prevSmall:Instruction)
LargerPredecessorIndexToSameBB(?insn, ?indexLarge, ?prevSmall) :-
   PredecessorBBsToSameBB(?insn, ?prevLarge, ?prevSmall),
   Instruction_Index(?prevLarge, ?indexLarge),
   Instruction_Index(?prevSmall, ?indexSmall),
   ?indexLarge > ?indexSmall.

.decl NextPredecessorIndexToSameBB(?insn:Instruction, ?prev:Instruction, ?indexNext:number)
.output NextPredecessorIndexToSameBB
NextPredecessorIndexToSameBB(?insn, ?prev, ?indexNext) :-
   LargerPredecessorIndexToSameBB(?insn, _, ?prev),
   ?indexNext = min ?index : LargerPredecessorIndexToSameBB(?insn, ?index, ?prev).

.decl NextPredecessorToSameBB(?insn:Instruction, ?pred:Instruction, ?nextPred:Instruction)
NextPredecessorToSameBB(?insn, ?pred, ?nextPred) :-
   NextPredecessorIndexToSameBB(?insn, ?pred, ?indexNext),
   Instruction_Method(?insn, ?method),
   OptInstructionFromMethodIndex(?method, ?indexNext, ?nextPred).

.decl PreviousPredecessorToSameB(?insn:Instruction, ?nextPred:Instruction, ?prevPred:Instruction)
PreviousPredecessorToSameB(?insn, ?nextPred, ?prevPred) :-
   NextPredecessorToSameBB(?insn, ?prevPred, ?nextPred).

.decl ExistsPreviousPredecessorToSameBB(?pred:Instruction, ?insn:Instruction)
ExistsPreviousPredecessorToSameBB(?pred, ?insn) :-
   NextPredecessorToSameBB(?insn, _, ?pred).




.decl NonDomPredecessorBBsToSameBB(?insn:Instruction, ?prev1:Instruction, ?prev2:Instruction)
NonDomPredecessorBBsToSameBB(?insn, ?prev1, ?prev2) :-
   MayPredecessorBBModuloThrow(?prev1, ?insn),
   MayPredecessorBBModuloThrow(?prev2, ?insn),
   BasicBlockTail(?prev1, ?prevTail1),
   BasicBlockTail(?prev2, ?prevTail2),
   !DominatesItsPredecessorInstruction(?prevTail1, ?insn),
   !DominatesItsPredecessorInstruction(?prevTail2, ?insn),
   ?prev1 != ?prev2.

.decl LargerNonDomPredecessorIndexToSameBB(?insn:Instruction, ?indexLarge:number, ?prevSmall:Instruction)
LargerNonDomPredecessorIndexToSameBB(?insn, ?indexLarge, ?prevSmall) :-
   NonDomPredecessorBBsToSameBB(?insn, ?prevLarge, ?prevSmall),
   Instruction_Index(?prevLarge, ?indexLarge),
   Instruction_Index(?prevSmall, ?indexSmall),
   ?indexLarge > ?indexSmall.

.decl NextNonDomPredecessorIndexToSameBB(?insn:Instruction, ?prev:Instruction, ?indexNext:number)
.output NextNonDomPredecessorIndexToSameBB
NextNonDomPredecessorIndexToSameBB(?insn, ?prev, ?indexNext) :-
   LargerNonDomPredecessorIndexToSameBB(?insn, _, ?prev),
   ?indexNext = min ?index : LargerNonDomPredecessorIndexToSameBB(?insn, ?index, ?prev).

.decl NextNonDomPredecessorToSameBB(?insn:Instruction, ?pred:Instruction, ?nextPred:Instruction)
NextNonDomPredecessorToSameBB(?insn, ?pred, ?nextPred) :-
   NextNonDomPredecessorIndexToSameBB(?insn, ?pred, ?indexNext),
   Instruction_Method(?insn, ?method),
   OptInstructionFromMethodIndex(?method, ?indexNext, ?nextPred).

.decl PreviousNonDomPredecessorToSameBB(?insn:Instruction, ?nextPred:Instruction, ?prevPred:Instruction)
PreviousNonDomPredecessorToSameBB(?insn, ?nextPred, ?prevPred) :-
   NextNonDomPredecessorToSameBB(?insn, ?prevPred, ?nextPred).

.decl ExistsPreviousNonDomPredecessorToSameBB(?pred:Instruction, ?insn:Instruction)
ExistsPreviousNonDomPredecessorToSameBB(?pred, ?insn) :-
   NextNonDomPredecessorToSameBB(?insn, _, ?pred).

.output MayPredecessorBBModuloThrow
.output BasicBlockHead
.output Method_FirstInstruction
.output OptInstructionFromMethodIndex
.output PhiNodeHead
.output Dominates
.output InstructionInPhiNode
.output BasicBlockTail
.output JumpTarget
.output Instruction_Next
.output MaySuccessorBBModuloThrow
.output BasicBlockBegin
.output DominatesItsPredecessorInstruction
.output BBHeadInMethod






.comp AbstractContextSensitivity<Configuration> {
.decl ClassInitializer(?type:Type, ?method:Method)

.decl InitializedClass(?classOrInterface:Type)
.decl ImplicitReachable(?sig:Method)

.decl ApplicationEntryPoint(?meth:Method)


.decl ForcedReachable(?method:Method)
.decl RunningThread(?hctx:configuration.HContext, ?value:Value)

.decl ReachableCurrentThreadInvocation(?callerCtx:configuration.Context, ?local:Var)

.decl FakeInvocation_ThreadGroupInit(?invo: MethodInvocation)

.decl FakeInvocation_MainThreadInit(?invo: MethodInvocation)

.decl FakeInvocation_SystemThreadGroupInit(?invo: MethodInvocation)
.decl MockedMethodReturns(?method:Method, ?alloc:HeapAllocation, ?type:ReferenceType)
.output MockedMethodReturns




MockedMethodReturns(?method, ?value, ?type) :-
  ?method = "<java.sql.DriverManager: java.sql.Connection getConnection(java.lang.String,java.util.Properties,java.lang.Class)>",
  basic.SubtypeOf(?type, "java.sql.Connection"),
  isClassType(?type),
  ?value = cat("<mock SQL connection of type ", cat(?type, ">")).
.decl StringFactoryVar(?var:Var)
.decl StringFactoryVarPointsTo(?factoryHctx:configuration.HContext, ?factoryValue:Value, ?ctx:configuration.Context, ?var:Var)
.decl AssignInvokedynamic(?insn:DynamicMethodInvocation_Insn, ?ret:Var, ?value:Value, ?type:Type)
.output AssignInvokedynamic




AssignInvokedynamic(?insn, ?ret, ?heap, "java.lang.String"),
VarPointsTo(?hctx, ?heap, ?ctx, ?ret),
Value_isMock(?heap), isValue(?heap), Value_Type(?heap, "java.lang.String"), Value_DeclaringType(?heap, "java.lang.Object")  :-
  DynamicMethodInvocation_Bootstrap(?insn, "<java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>"),
  Instruction_Method(?insn, ?method),
  ReachableContext(?ctx, ?method),
  isImmutableHContext(?hctx),
  AssignReturnValue(?insn, ?ret),
  ?heap = "<mock string concatenation result>".
.decl Instruction_Throws(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?insn:Instruction)
.decl ThrowPointsTo(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?method:Method)

Instruction_Throws(?hctx, ?value, ?ctx, ?insn) :-
  Throw(?insn, ?var),
  VarPointsTo(?hctx, ?value, ?ctx, ?var).

Instruction_Throws(?hctx, ?value, ?callerCtx, ?invocation) :-
  ThrowPointsTo(?hctx, ?value, ?calleeCtx, ?tomethod),
  CallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?tomethod).
 .plan 1:(2,1)
ThrowPointsTo(?hctx, ?value, ?ctx, ?method) :-
  Instruction_Throws(?hctx, ?value, ?ctx, ?insn),
  Instruction_Method(?insn, ?method),
  !basic.ExceptionHandler_InRange(_, ?insn).

ThrowPointsTo(?hctx, ?value, ?ctx, ?method) :-
  Instruction_Throws(?hctx, ?value, ?ctx, ?insn),
  Value_Type(?value, ?valueType),
  Instruction_Method(?insn, ?method),
  basic.ExceptionHandler_SameInsn_Repr(?insn, ?repr),
  basic.ExceptionHandler_SameBlock_Repr(?repr, ?block),
  !basic.ExceptionHandler_TypeIsCaught(?valueType, ?block).



 .plan 1:(2,1,3,4,5)


VarPointsTo(?hctx, ?value, ?ctx, ?param) :-
  Instruction_Throws(?hctx, ?value, ?ctx, ?insn),
  Value_Type(?value, ?valueType),
  basic.ExceptionHandler_InRange(?handler, ?insn),
  ExceptionHandler_Type(?handler, ?handlerType),
  basic.SubtypeOf(?valueType, ?handlerType),
  ConcreteClass(?valueType),
  ExceptionHandler_FormalParam(?handler, ?param),
  !basic.ExceptionHandler_Impossible(?valueType, ?handler, ?insn).


 .plan 1:(2,1,3,4,5,6,7)
.type MethodType = Value
.type ParamTypes = symbol
.decl MethodType_ParamType(?mt:MethodType, ?index:number, ?pType:Type)
.decl MethodType_ParamTypes(?mt:MethodType, ?paramTypes:ParamTypes)
.decl MethodType_ReturnType(?mt:MethodType, ?retType:Type)
.decl MethodType_Arity(?mt:MethodType, ?arity:number)


.decl isInitialMethodType(?mt:MethodType)


MethodType_ParamType(?mt, ?idx, ?type) :- _MethodTypeConstantParam(?mt, ?idx, ?type).
MethodType_Arity(?mt, ?arity) :- MethodTypeConstant_Arity(?mt, ?arity).
MethodType_ReturnType(?mt, ?retType) :- MethodTypeConstant_ReturnType(?mt, ?retType).
MethodType_ParamTypes(?mt, ?paramTypes) :- MethodTypeConstant_ParamTypes(?mt, ?paramTypes).
HeapAllocation_ContextInsensitive(?heap) :-
  isMethodHandleConstant(?heap).

.type MethodHandle = Value
.decl MethodHandle_Method(?methodHandle:MethodHandle, ?method:Method)



.decl MethodHandle_MethodType(?mh:MethodHandle, ?mt:MethodType)


Value_isMock(?mt), isValue(?mt), Value_Type(?mt, "java.lang.invoke.MethodType"), Value_DeclaringType(?mt, "java.lang.Object") ,
isInitialMethodType(?mt),
MethodHandle_Method(?methodHandle, ?method),
MethodHandle_MethodType(?methodHandle, ?mt),
MethodType_Arity(?mt, ?arity),
MethodType_ParamTypes(?mt, ?paramTypes),
MethodType_ReturnType(?mt, ?retType) :-
  MethodHandleConstant_Method(?methodHandle, ?method),
  MethodHandleConstant_ParamTypes(?methodHandle, ?paramTypes),
  MethodHandleConstant_ReturnType(?methodHandle, ?retType),
  MethodHandleConstant_Arity(?methodHandle, ?arity),
  ?mt =  cat("<method type (", cat(?paramTypes, cat(")", cat(?retType, ">")))) .




.decl MethodHandleCallGraphEdge_Candidate(?callerCtx:configuration.Context, ?i:MethodInvocation, ?m:Method, ?mh:MethodHandle, ?name:symbol)
MethodHandleCallGraphEdge_Candidate(?callerCtx, ?invo, ?method, ?mh, ?name) :-

  ReachableContext(?callerCtx, ?containingMethod),
  (_VirtualMethodInvocation(?invo, _, _, ?base, ?containingMethod) ;
   _SpecialMethodInvocation(?invo, _, _, ?base, ?containingMethod)),
  _PolymorphicInvocation(?invo, ?name),
  VarPointsTo(_, ?mh, ?callerCtx, ?base),
  MethodHandle_Method(?mh, ?method).
.plan 1:(4,5,2,1,3), 2:(5,4,2,1,3)

.decl MethodHandleCallGraphEdge(?callerCtx:configuration.Context, ?i:MethodInvocation, ?calleeCtx:configuration.Context, ?m:Method, ?mh:MethodHandle, ?name:symbol)
configuration.StaticContextRequest(?callerCtx, ?invo) :-
  MethodHandleCallGraphEdge_Candidate(?callerCtx, ?invo, ?method, _, _),
  Method_Modifier("static", ?method).

MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, ?mh, ?name) :-
  configuration.StaticContextResponse(?callerCtx, ?invo, ?calleeCtx),
  MethodHandleCallGraphEdge_Candidate(?callerCtx, ?invo, ?method, ?mh, ?name).

MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, ?mh, ?name) :-
  MethodHandleCallGraphEdge_Candidate(?callerCtx, ?invo, ?method, ?mh, ?name),
  !Method_Modifier("static", ?method),

  isImmutableContext(?calleeCtx).

ReachableContext(?calleeCtx, ?method) :-
  MethodHandleCallGraphEdge(_, _, ?calleeCtx, ?method, _, _).


.decl BoxTypeConversion(?original:Type, ?new:Type)

.decl BoxAllocation(?value:Value, ?type:Type)


BoxTypeConversion(?t1, ?t2),
Value_isMock(?mockAlloc), isValue(?mockAlloc), Value_Type(?mockAlloc, ?t2), Value_DeclaringType(?mockAlloc, "java.lang.Object") ,
BoxAllocation(?mockAlloc, ?t2) :-
  PrimitiveType_Boxed(?t1, ?wrapperT),
  basic.SubtypeOf(?wrapperT, ?t2),
  ?mockAlloc =  cat("<mock box allocation for type ", cat(?t2, ">")) .
BoxTypeConversion(?t1, ?t2) :- PrimitiveType_Boxed(?t1, _), isNullType(?t2).
BoxTypeConversion(?t1, ?t2) :- PrimitiveType_Boxed(_, ?t2), isNullType(?t1).
BoxTypeConversion(?t1, ?t2) :- BoxTypeConversion(?t2, ?t1).

.decl CompatibleTypes(?t:Type, ?tConv:Type)
CompatibleTypes(?t, ?tConv) :- basic.SubtypeOf(?tConv, ?t).
CompatibleTypes(?t, ?tConv) :- BoxTypeConversion(?t, ?tConv).


.decl MethodHandleCGE_Arg(?callerCtx:configuration.Context, ?calleeCtx:configuration.Context, ?actual:Var, ?formal:Var, ?actualType:Type, ?formalType:Type, ?name:symbol)

MethodHandleCGE_Arg(?callerCtx, ?calleeCtx, ?actual, ?formal, ?actualType, ?formalType, ?name) :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, _, ?name),
  !Method_Modifier("static", ?method),
  ActualParam(?idx, ?invo, ?actual),
  ?idx > 0,
  FormalParam(?idx - 1, ?method, ?formal),
  Var_Type(?actual, ?actualType),
  Var_Type(?formal, ?formalType).

MethodHandleCGE_Arg(?callerCtx, ?calleeCtx, ?actual, ?formal, ?actualType, ?formalType, ?name) :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, _, ?name),
  Method_Modifier("static", ?method),
  ActualParam(?idx, ?invo, ?actual),
  FormalParam(?idx, ?method, ?formal),
  Var_Type(?actual, ?actualType),
  Var_Type(?formal, ?formalType).



VarPointsTo(?hctx, ?val, ?calleeCtx, ?formal) :-
  MethodHandleCGE_Arg(?callerCtx, ?calleeCtx, ?actual, ?formal, ?actualType, ?formalType, _),
  VarPointsTo(?hctx, ?val, ?callerCtx, ?actual),
  basic.SubtypeOf(?actualType, ?formalType).
VarPointsTo(?hctx, ?val, ?calleeCtx, ?this) :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, _, _),
  !Method_Modifier("static", ?method),
  ActualParam(0, ?invo, ?actual),
  VarPointsTo(?hctx, ?val, ?callerCtx, ?actual),
  ThisVar(?method, ?this),
  Var_Type(?actual, ?actualType),
  Var_Type(?this, ?thisType),
  basic.SubtypeOf(?actualType, ?thisType).


VarPointsTo(?hctx, ?val, ?callerCtx, ?var) :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, _, _),
  ReturnVar(?ret, ?method),
  VarPointsTo(?hctx, ?val, ?calleeCtx, ?ret),
  AssignReturnValue(?invo, ?var),
  Var_Type(?ret, ?retType),
  Var_Type(?var, ?varType),
  CompatibleTypes(?retType, ?varType).



OpaqueCallGraphEdge(?invo, ?sig),
Value_isMock(?adapterMH), isValue(?adapterMH), Value_Type(?adapterMH, "java.lang.invoke.MethodHandle"), Value_DeclaringType(?adapterMH, "java.lang.Object") ,

VarPointsTo(?hctx, ?adapterMH, ?ctx, ?ret),

MethodHandle_Method(?adapterMH, ?mhMethod),
MethodHandle_MethodType(?adapterMH, ?mt) :-
  _VirtualMethodInvocation(?invo, _, ?sig, ?base, ?method),
  ReachableContext(?ctx, ?method),
  ?sig = "<java.lang.invoke.MethodHandle: java.lang.invoke.MethodHandle asType(java.lang.invoke.MethodType)>",
  VarPointsTo(?hctx, ?mh, ?ctx, ?base),
  ActualParam(0, ?invo, ?arg),
  VarPointsTo(_, ?mt, ?ctx, ?arg),
  AssignReturnValue(?invo, ?ret),
  MethodHandle_Method(?mh, ?mhMethod),
  Method_ParamTypes(?mhMethod, _),
  ?adapterMH = cat("<adapter for ", cat(?mh, cat(" as ", ?mt))).
.decl MHLookup_Type(?value:Value, ?type:Type)
VarPointsTo(?hctx, ?value, ?calleeCtx, ?thisVar),
VarPointsTo(?hctx, ?value, ?callerCtx, ?ret),

Value_isMock(?value), isValue(?value), Value_Type(?value, ?type), Value_DeclaringType(?value, "java.lang.Object")  :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, ?mh, _),
  basic.ClassConstructor(?method, ?type),
  ThisVar(?method, ?thisVar),
  isImmutableHContext(?hctx),
  ?value = cat(?type, cat(" value constructed by method handle ", ?mh)),
  AssignReturnValue(?invo, ?ret),
  Var_Type(?ret, ?retType),
  basic.SubtypeOf(?type, ?retType).
.decl ReachableInvokedynamic(?invokedynamic:DynamicMethodInvocation_Insn, ?dynName:symbol, ?dynRetType:Type, ?ctx:configuration.Context)
ReachableInvokedynamic(?invokedynamic, ?dynName, ?dynRetType, ?ctx) :-
  isDynamicMethodInvocation_Insn(?invokedynamic),
  Instruction_Method(?invokedynamic, ?inMethod),
  DynamicMethodInvocation_DynName(?invokedynamic, ?dynName),
  DynamicMethodInvocation_DynReturnType(?invokedynamic, ?dynRetType),
  ReachableContext(?ctx, ?inMethod).


.decl isBootstrapMethodContext(?ctx:configuration.Context)
isBootstrapMethodContext(?ctx) :- isImmutableContext(?ctx).


.decl InvokedynamicBootCallGraphEdge(?callerCtx:configuration.Context, ?invokedynamic:DynamicMethodInvocation_Insn, ?calleeCtx:configuration.Context, ?bootMethod:Method)
InvokedynamicBootCallGraphEdge(?callerCtx, ?invokedynamic, ?calleeCtx, ?bootMethod) :-
  ReachableInvokedynamic(?invokedynamic, _, _, ?callerCtx),
  DynamicMethodInvocation_Bootstrap(?invokedynamic, ?bootMethod),
  isBootstrapMethodContext(?calleeCtx).

ReachableContext(?calleeCtx, ?bootMethod) :-
  InvokedynamicBootCallGraphEdge(_, _, ?calleeCtx, ?bootMethod).

.decl Invokedynamic_MethodType(?invokedynamic:DynamicMethodInvocation_Insn, ?mt:MethodType)
.decl PopulateMTParamTypes(?mt:Value, ?invokedynamic:DynamicMethodInvocation_Insn)


Value_isMock(?mt), isValue(?mt), Value_Type(?mt, "java.lang.invoke.MethodType"), Value_DeclaringType(?mt, "java.lang.Object") ,
MethodType_ReturnType(?mt, ?dynRetType),
PopulateMTParamTypes(?mt, ?invokedynamic),
Invokedynamic_MethodType(?invokedynamic, ?mt) :-
  InvokedynamicBootCallGraphEdge(_, ?invokedynamic, _, _),
  DynamicMethodInvocation_DynReturnType(?invokedynamic, ?dynRetType),
  DynamicMethodInvocation_DynParamTypes(?invokedynamic, ?dynParamTypes),
  ?mt =  cat("<method type (", cat(?dynParamTypes, cat(")", cat(?dynRetType, ">")))) .
MethodType_ParamType(?mt, ?index, ?pType) :-
  PopulateMTParamTypes(?mt, ?invokedynamic),
  _DynamicMethodInvocation_DynParamType(?invokedynamic, ?index, ?pType).




VarPointsTo(?immHctx, ?mockMHLookup, ?calleeCtx, ?caller),
VarPointsTo(?immHctx, ?mt, ?calleeCtx, ?invokedTypeParam),

Value_isMock(?mockMHLookup), isValue(?mockMHLookup), Value_Type(?mockMHLookup, "java.lang.invoke.MethodHandles$Lookup"), Value_DeclaringType(?mockMHLookup, "java.lang.Object") ,
MHLookup_Type(?mockMHLookup, ?callerClass) :-
  InvokedynamicBootCallGraphEdge(_, ?invokedynamic, ?calleeCtx, ?bootMethod),
  FormalParam(0, ?bootMethod, ?caller),
  FormalParam(2, ?bootMethod, ?invokedTypeParam),
  Invokedynamic_MethodType(?invokedynamic, ?mt),
  isImmutableHContext(?immHctx),
  Instruction_Method(?invokedynamic, ?method),
  Method_DeclaringType(?method, ?callerClass),
  ?mockMHLookup =  cat("<mock method handles lookup object for type ", cat(?callerClass, ">")) .
.decl MethodVarArgs(?method:Method, ?idx:number, ?formal:Var, ?type:ArrayType)
MethodVarArgs(?method, ?idx, ?formal, ?type) :-
  Method_Modifier("varargs", ?method),
  Method_Arity(?method, ?arity),
  ?idx = ?arity - 1,
  FormalParam(?idx, ?method, ?formal),
  Var_Type(?formal, ?type),
  isArrayType(?type).





ArrayIndexPointsTo(?immHctx, ?val, ?immHctx, ?mockArray),
Value_isMock(?mockArray), isValue(?mockArray), Value_Type(?mockArray, ?varArgsType), Value_DeclaringType(?mockArray, "java.lang.Object") ,
VarPointsTo(?immHctx, ?mockArray, ?calleeCtx, ?formalVarArgs) :-
  InvokedynamicBootCallGraphEdge(_, ?invokedynamic, ?calleeCtx, ?bootMethod),
  MethodVarArgs(?bootMethod, ?bootIdx, ?formalVarArgs, ?varArgsType),
  BootstrapParam(?idx, ?invokedynamic, ?actual),
  ?idx > ?bootIdx - 3,
  VarPointsTo(_, ?val, _, ?actual),
  isImmutableHContext(?immHctx),
  ?mockArray =  cat("<bootstrap varargs array for ", cat(?invokedynamic, ">")) .


VarPointsTo(?hctx, ?val, ?calleeCtx, ?formal) :-
  InvokedynamicBootCallGraphEdge(_, ?invokedynamic, ?calleeCtx, ?bootMethod),
  !Method_Modifier("varargs", ?bootMethod),
  FormalParam(?idx + 3, ?bootMethod, ?formal),
  BootstrapParam(?idx, ?invokedynamic, ?actual),
  VarPointsTo(?hctx, ?val, _, ?actual).


.type CallSite = Value
.decl InvokedynamicCallSite(?callsite:CallSite, ?invokedynamic:DynamicMethodInvocation_Insn, ?dynName:symbol, ?K:number, ?ctx:configuration.Context)




InvokedynamicCallSite(?callsite, ?invokedynamic, ?dynName, ?K, ?callerCtx) :-
  ReachableInvokedynamic(?invokedynamic, ?dynName, _, ?callerCtx),
  DynamicMethodInvocation_DynArity(?invokedynamic, ?K),
  DynamicMethodInvocation_Bootstrap(?invokedynamic, ?bootMethod),
  ReturnVar(?bootRetVar, ?bootMethod),
  isBootstrapMethodContext(?calleeCtx),
  VarPointsTo(_, ?callsite, ?calleeCtx, ?bootRetVar).



.decl CallSiteContents(?invokedynamic:DynamicMethodInvocation_Insn, ?methodHandle:MethodHandle, ?method:Method, ?mt:MethodType, ?ctx:configuration.Context)
CallSiteContents(?invokedynamic, ?methodHandle, ?method, ?mt, ?ctx) :-
  InvokedynamicCallSite(?callsite, ?invokedynamic, _, _, ?ctx),
  Invokedynamic_MethodType(?invokedynamic, ?mt),
  InstanceFieldPointsTo(_, ?methodHandle, "<java.lang.invoke.CallSite: java.lang.invoke.MethodHandle target>", _, ?callsite),
  MethodHandle_Method(?methodHandle, ?method).



.decl CallSiteMatchesMethodHandleType(?invokedynamic:DynamicMethodInvocation_Insn, ?mh:MethodHandle, ?method:Method, ?ctx:configuration.Context)
CallSiteMatchesMethodHandleType(?invokedynamic, ?mh, ?method, ?ctx) :-
  CallSiteContents(?invokedynamic, ?mh, ?method, ?mtDyn, ?ctx),




  MethodHandle_MethodType(?mh, ?mtDyn).



CallSiteMatchesMethodHandleType(?invokedynamic, ?mh, ?method, ?ctx) :-
  CallSiteContents(?invokedynamic, ?mh, ?method, ?mt, ?ctx),
  MethodType_ReturnType(?mt, ?dynRetType),
  basic.ClassConstructor(?method, ?dynRetType),
  MethodHandle_Method(?mh, ?method).






.decl StaticMethodHandleCall(?callerCtx:configuration.Context, ?invo:MethodInvocation, ?method:Method, ?mh:MethodHandle)
StaticMethodHandleCall(?callerCtx, ?invokedynamic, ?method, ?mh),
configuration.StaticContextRequest(?callerCtx, ?invokedynamic) :-
  CallSiteMatchesMethodHandleType(?invokedynamic, ?mh, ?method, ?callerCtx),
  Method_Modifier("static", ?method).
MethodHandleCallGraphEdge(?callerCtx, ?invokedynamic, ?calleeCtx, ?method, ?mh, "invokeExact") :-
  StaticMethodHandleCall(?callerCtx, ?invokedynamic, ?method, ?mh),
  configuration.StaticContextResponse(?callerCtx, ?invokedynamic, ?calleeCtx).




MethodHandleCallGraphEdge(?callerCtx, ?invokedynamic, ?calleeCtx, ?method, ?mh, "invokeExact") :-
  CallSiteMatchesMethodHandleType(?invokedynamic, ?mh, ?method, ?callerCtx),
  !Method_Modifier("static", ?method),
  isImmutableContext(?calleeCtx).

ReachableContext(?calleeCtx, ?callee) :-
  MethodHandleCallGraphEdge(_, _, ?calleeCtx, ?callee, _, _).
.decl LambdaMetafactoryInvoke(?invokedynamic:DynamicMethodInvocation_Insn)
LambdaMetafactoryInvoke(?invokedynamic) :-
  DynamicMethodInvocation_Bootstrap(?invokedynamic, ?method),
  (?method =  "<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>"  ; ?method =  "<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite altMetafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.Object[])>" ).

.decl ReachableLambdaMetafactoryInvoke(?invokedynamic:DynamicMethodInvocation_Insn, ?dynName:symbol, ?dynRetType:Type, ?ctx:configuration.Context)
ReachableLambdaMetafactoryInvoke(?invokedynamic, ?dynName, ?dynRetType, ?ctx) :-
  LambdaMetafactoryInvoke(?invokedynamic),
  ReachableInvokedynamic(?invokedynamic, ?dynName, ?dynRetType, ?ctx).



.decl UnhandledInvokedynamic(?invokedynamic:DynamicMethodInvocation_Insn, ?bootMethodId:symbol)

UnhandledInvokedynamic(?invokedynamic, ?bootMethodId) :-
  DynamicMethodInvocation_Bootstrap(?invokedynamic, ?bootMethodId),
  !LambdaMetafactoryInvoke(?invokedynamic).
.type Lambda = Value


.decl LambdaObject(?invokedynamic:DynamicMethodInvocation_Insn, ?lambda:Lambda, ?dynName:symbol, ?K:number, ?implMethod:Method, ?ctx:configuration.Context)
Value_isMock(?lambda), isValue(?lambda), Value_Type(?lambda, ?dynRetType), Value_DeclaringType(?lambda, "java.lang.Object") ,

VarPointsTo(?hctx, ?lambda, ?callerCtx, ?ret),

LambdaObject(?invokedynamic, ?lambda, ?dynName, ?K, ?implMethod, ?callerCtx) :-
  ReachableLambdaMetafactoryInvoke(?invokedynamic, ?dynName, ?dynRetType, ?callerCtx),
  DynamicMethodInvocation_DynArity(?invokedynamic, ?K),
  BootstrapParam(1, ?invokedynamic, ?handleVar),
  VarPointsTo(?hctx, ?handleVal, ?callerCtx, ?handleVar),
  MethodHandleConstant_Method(?handleVal, ?implMethod),

  Method_SimpleName(?implMethod, ?handleMeth),
  Method_DeclaringType(?implMethod, ?handleType),
  ?lambda =  cat(?invokedynamic, cat("::: ", cat(?dynRetType, cat("::: (Mock)::: ", cat("reference ", cat(?handleType, cat ("::", cat(?handleMeth, cat(" from ", cat(?implMethod, cat(" wrapped as ", cat(?dynRetType, cat(".", ?dynName))))))))))))) ,

  AssignReturnValue(?invokedynamic, ?ret).




.decl LambdaCaptured(?invokedynamic:DynamicMethodInvocation_Insn, ?val:Value, ?idx:number, ?hctx:configuration.HContext)
LambdaCaptured(?invokedynamic, ?val, ?idx, ?hctx) :-
  ReachableLambdaMetafactoryInvoke(?invokedynamic, _, _, ?callerCtx),
  DynamicMethodInvocation_DynArity(?invokedynamic, ?K),
  ?K > 0,
  ActualParam(?idx, ?invokedynamic, ?actual),
  VarPointsTo(?hctx, ?val, ?callerCtx, ?actual).








.decl LambdaCallGraphEdge(?callerCtx:configuration.Context, ?i:MethodInvocation, ?calleeCtx:configuration.Context, ?m:Method, ?lambda:Lambda)





LambdaCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?implMethod, ?lambda) :-
  LambdaObject(_, ?lambda, ?dynName, _, ?implMethod, _),
  VarPointsTo(_, ?lambda, ?callerCtx, ?var),
  VirtualMethodInvocation_Base(?i, ?var),
  VirtualMethodInvocation_SimpleName(?i, ?dynName),
  isImmutableContext(?calleeCtx).

ReachableContext(?calleeCtx, ?callee) :-
  LambdaCallGraphEdge(_, _, ?calleeCtx, ?callee, _).



VarPointsTo(?hctx, ?retVal, ?callerCtx, ?ret) :-
  LambdaCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?method, _),
  ReturnVar(?realReturnVar, ?method),
  VarPointsTo(?hctx, ?retVal, ?calleeCtx, ?realReturnVar),
  AssignReturnValue(?i, ?ret).



.decl CalledInstanceImplMethod(?invokedynamic:DynamicMethodInvocation_Insn, ?implMethod:Method, ?this:Var, ?thisType:Type, ?calleeCtx:configuration.Context, ?lambda:Lambda)
CalledInstanceImplMethod(?invokedynamic, ?implMethod, ?this, ?thisType, ?calleeCtx, ?lambda) :-
  LambdaCallGraphEdge(_, _, ?calleeCtx, ?implMethod, ?lambda),
  !Method_Modifier("static", ?implMethod),
  LambdaObject(?invokedynamic, ?lambda, _, _, ?implMethod, _),
  ThisVar(?implMethod, ?this),
  Var_Type(?this, ?thisType).




.decl Params_ReceiverShiftRight(?lambda:Lambda, ?implMethod:Method, ?shiftK:number, ?shiftN:number)
Params_ReceiverShiftRight(?lambda, ?implMethod, 0, 0) :-
  LambdaObject(_, ?lambda, _, _, ?implMethod, _),
  Method_Modifier("static", ?implMethod).

Params_ReceiverShiftRight(?lambda, ?implMethod, 0, 1) :-
  CalledInstanceImplMethod(?invokedynamic, ?implMethod, _, _, _, ?lambda),
  DynamicMethodInvocation_DynArity(?invokedynamic, 0).

Params_ReceiverShiftRight(?lambda, ?implMethod, 1, 0) :-
  CalledInstanceImplMethod(?invokedynamic, ?implMethod, _, _, _, ?lambda),
  LambdaCaptured(?invokedynamic, _, 0, _).


.decl LambdaArg(?calleeCtx:configuration.Context, ?formal:Var, ?formalType:Type, ?actual:Var, ?invokedynamic:DynamicMethodInvocation_Insn)


LambdaArg(?calleeCtx, ?formal, ?formalType, ?actual, ?invokedynamic) :-
  LambdaCallGraphEdge(_, ?i, ?calleeCtx, ?implMethod, ?lambda),
  Params_ReceiverShiftRight(?lambda, ?implMethod, ?shiftK, ?shiftN),
  LambdaObject(?invokedynamic, ?lambda, _, ?K, ?implMethod, _),
  ActualParam(?idx, ?i, ?actual),
  FormalParam(?K - ?shiftK + ?idx - ?shiftN, ?implMethod, ?formal),
  Var_Type(?formal, ?formalType).



VarPointsTo(?hctx, ?val, ?calleeCtx, ?formal) :-
  LambdaArg(?calleeCtx, ?formal, ?formalType, ?actual, _),
  VarPointsTo(?hctx, ?val, _, ?actual),
  Value_Type(?val, ?valType),
  basic.SubtypeOf(?valType, ?formalType).



.decl BoxingFunction(?functionType:ReferenceType, ?primType:Type, ?refType:ReferenceType)
BoxingFunction(?intArgLambdaType, "int", "java.lang.Integer") :-
  ?intArgLambdaType = "java.util.function.IntBinaryOperator";
  ?intArgLambdaType = "java.util.function.IntConsumer";
  ?intArgLambdaType = "java.util.function.IntFunction";
  ?intArgLambdaType = "java.util.function.IntPredicate";
  ?intArgLambdaType = "java.util.function.IntToDoubleFunction";
  ?intArgLambdaType = "java.util.function.IntToLongFunction";
  ?intArgLambdaType = "java.util.function.IntUnaryOperator";
  ?intArgLambdaType = "java.util.function.ObjIntConsumer".
BoxingFunction(?longArgLambdaType, "long", "java.lang.Long") :-
  ?longArgLambdaType = "java.util.function.LongBinaryOperator";
  ?longArgLambdaType = "java.util.function.LongConsumer";
  ?longArgLambdaType = "java.util.function.LongFunction";
  ?longArgLambdaType = "java.util.function.LongPredicate";
  ?longArgLambdaType = "java.util.function.LongToDoubleFunction";
  ?longArgLambdaType = "java.util.function.LongToIntFunction";
  ?longArgLambdaType = "java.util.function.LongUnaryOperator";
  ?longArgLambdaType = "java.util.function.ObjLongConsumer".
BoxingFunction(?doubleArgLambdaType, "double", "java.lang.Double") :-
  ?doubleArgLambdaType = "java.util.function.DoubleBinaryOperator";
  ?doubleArgLambdaType = "java.util.function.DoubleConsumer";
  ?doubleArgLambdaType = "java.util.function.DoubleFunction";
  ?doubleArgLambdaType = "java.util.function.DoublePredicate";
  ?doubleArgLambdaType = "java.util.function.DoubleToIntFunction";
  ?doubleArgLambdaType = "java.util.function.DoubleToLongFunction";
  ?doubleArgLambdaType = "java.util.function.DoubleUnaryOperator";
  ?doubleArgLambdaType = "java.util.function.ObjDoubleConsumer".

VarPointsTo(?hctx, ?val, ?calleeCtx, ?formal) :-
  LambdaArg(?calleeCtx, ?formal, ?formalType, ?actual, ?invokedynamic),
  ReachableLambdaMetafactoryInvoke(?invokedynamic, _, ?dynRetType, _),
  Var_Type(?actual, ?primType),
  BoxingFunction(?dynRetType, ?primType, ?formalType),
  BoxAllocation(?val, ?formalType),
  isImmutableHContext(?hctx).


VarPointsTo(?hctx, ?val, ?calleeCtx, ?formal) :-
  LambdaCallGraphEdge(_, _, ?calleeCtx, ?implMethod, ?lambda),
  Params_ReceiverShiftRight(?lambda, ?implMethod, ?shiftK, _),
  LambdaObject(?invokedynamic, ?lambda, _, ?K, ?implMethod, _),
  LambdaCaptured(?invokedynamic, ?val, ?idx, ?hctx),
  ?idx + ?shiftK <= ?K,
  FormalParam(?idx - ?shiftK, ?implMethod, ?formal),
  Value_Type(?val, ?valType),
  Var_Type(?formal, ?formalType),
  basic.SubtypeOf(?valType, ?formalType).


VarPointsTo(?hctx, ?thisValue, ?calleeCtx, ?this) :-
  Params_ReceiverShiftRight(?lambda, ?implMethod, 1, 0),
  CalledInstanceImplMethod(?invokedynamic, ?implMethod, ?this, ?thisType, ?calleeCtx, ?lambda),
  LambdaCaptured(?invokedynamic, ?thisValue, 0, ?hctx),
  Value_Type(?thisValue, ?thisValueType),
  basic.SubtypeOf(?thisValueType, ?thisType).



VarPointsTo(?hctx, ?argValue, ?calleeCtx, ?this) :-
  LambdaCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?implMethod, ?lambda),
  Params_ReceiverShiftRight(?lambda, ?implMethod, 0, 1),
  ActualParam(0, ?i, ?actual),
  VarPointsTo(?hctx, ?argValue, ?callerCtx, ?actual),
  Value_Type(?argValue, ?argType),
  ThisVar(?implMethod, ?this),
  Var_Type(?this, ?thisType),
  basic.SubtypeOf(?argType, ?thisType).




VarPointsTo(?hctx, ?mockObj, ?callerCtx, ?var),
VarPointsTo(?hctx, ?mockObj, ?calleeCtx, ?thisVar),
Value_isMock(?mockObj), isValue(?mockObj), Value_Type(?mockObj, ?type), Value_DeclaringType(?mockObj, "java.lang.Object")  :-
  LambdaCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?implMethod, _),
  basic.ClassConstructor(?implMethod, ?type),
  AssignReturnValue(?i, ?var),
  ThisVar(?implMethod, ?thisVar),
  ?mockObj = cat("<mock object of type ", cat(?type, cat(" constructed by constructor reference at ", cat(?i, ">")))),
  isImmutableHContext(?hctx).
  .decl FakeInvocation_RegisterFinalize0(?heap:HeapAllocation, ?invo:MethodInvocation)

  .decl FakeInvocation_RegisterFinalize(?value:Value, ?invo:MethodInvocation)

  .decl Value_isHeap(?value:Value)
  .decl Value_isMock(?value:Value)




  .decl Value_Num(?value:Value, ?const:symbol, ?valueType:Type)

  .decl Value_isNonHeap(?value:Value)




  .decl NotSpecialObject(?value:Value)

  .decl Value_Type(?value:Value, ?type:Type)
  .decl Value_DeclaringType(?value:Value, ?type:Type)


  .decl Value_Null(?null:Value)
.decl isContext(?ctx:configuration.Context)
.decl isHContext(?hctx:configuration.HContext)



.decl isImmutableContext(?ctx:configuration.Context)
.decl isInitialContext(?ctx:configuration.Context)
.decl isJVMStartupContext(?ctx:configuration.Context)
.decl isClinitContext(?ctx:configuration.Context)
.decl isImmutableHContext(?hctx:configuration.HContext)
.decl isJVMStartupHContext(?hctx:configuration.HContext)


.decl VarPointsTo(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?var:Var)

.decl InstanceFieldPointsTo(?hctx:configuration.HContext, ?value:Value, ?sig:Field, ?basehctx:configuration.HContext, ?basevalue:Value)

.decl StaticFieldPointsTo(?hctx:configuration.HContext, ?value:Value, ?sig:Field)


.decl ArrayIndexPointsTo(?hctx:configuration.HContext, ?value:Value, ?basehctx:configuration.HContext, ?basevalue:Value)
.decl CallGraphEdge(?callerCtx:configuration.Context, ?invocation:MethodInvocation, ?calleeCtx:configuration.Context, ?method:Method) overridable
.decl OpaqueCallGraphEdge(?invocation:MethodInvocation, ?method:Method)
.decl Reachable(?method:Method)
.decl ReachableClass(?class:ReferenceType)
.decl ReachableContext(?ctx:configuration.Context, ?method:Method)
.decl OptInterproceduralAssign(?toCtx:configuration.Context, ?to:Var, ?fromCtx:configuration.Context, ?from:Var)

.decl OptLoadArrayIndex(?to:Var, ?base:Var)

.decl OptStoreArrayIndex(?from:Var, ?base:Var)

.decl OptArgAssign(?toCtx:configuration.Context, ?to:Var, ?fromCtx:configuration.Context, ?from:Var, ?allowedType:Type)


.decl OptReturnAssign(?toCtx:configuration.Context, ?to:Var, ?fromCtx:configuration.Context, ?from:Var)


.decl OptArgVarPointsTo(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?var:Var)

.decl OptRetVarPointsTo(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?var:Var)

.decl HeapInterproceduralAssign(?toCtx:configuration.Context, ?to:Var, ?fromCtx:configuration.Context, ?from:Var)

.decl LoadHeapInstanceField(?ctx:configuration.Context, ?to:Var, ?sig:Field, ?basehctx:configuration.HContext, ?basevalue:Value)

.decl StoreHeapInstanceField(?sig:Field, ?basehctx:configuration.HContext, ?basevalue:Value, ?ctx:configuration.Context, ?from:Var)

.decl LoadHeapArrayIndex(?ctx:configuration.Context, ?to:Var, ?basehctx:configuration.HContext, ?basevalue:Value)

.decl StoreHeapArrayIndex(?basehctx:configuration.HContext, ?basevalue:Value, ?ctx:configuration.Context, ?from:Var)
.decl SystemThreadGroup(?hctx:configuration.HContext, ?value:Value)

.decl MainThreadGroup(?hctx:configuration.HContext, ?value:Value)

.decl MainThread(?hctx:configuration.HContext, ?value:Value)
Value_DeclaringType(?value, "java.lang.System") :-
   ?value = "<<string-constant>>",
   isValue(?value) ;
   ?value = "<<reflection-string-constant>>",
   isValue(?value) ;
   ?value = "<<string-buffer>>",
   isValue(?value) ;
   ?value = "<<string-builder>>",
   isValue(?value) ;
   ?value = "<<initial-context>>",
   isValue(?value) ;
   ?value = "<<jvm-startup-context>>",
   isValue(?value) ;
   ?value = "<<jvm-startup-hcontext>>",
   isValue(?value) ;
   ?value = "<<clinit-context>>",
   isValue(?value) ;
   ?value = "<<system-thread-group>>",
   isValue(?value) ;
   ?value = "<<main-thread-group>>",
   isValue(?value) ;
   ?value = "<<main-thread>>",
   isValue(?value) ;
   ?value = "<<immutable-context>>",
   isValue(?value) ;
   ?value = "<<immutable-hcontext>>",
   isValue(?value) ;
   ?value = "<<immutable>>",
   isValue(?value).



.decl PrimitiveType_Boxed(?type:Type, ?boxedType:Type)

PrimitiveType_Boxed("boolean", "java.lang.Boolean" ).
PrimitiveType_Boxed("byte" , "java.lang.Byte" ).
PrimitiveType_Boxed("short" , "java.lang.Short" ).
PrimitiveType_Boxed("char" , "java.lang.Character").
PrimitiveType_Boxed("int" , "java.lang.Integer" ).
PrimitiveType_Boxed("long" , "java.lang.Long" ).
PrimitiveType_Boxed("float" , "java.lang.Float" ).
PrimitiveType_Boxed("double" , "java.lang.Double" ).
ClassInitializer(?type, ?method) :-
   basic.MethodImplemented("<clinit>", "void()", ?type, ?method).
InitializedClass(?superclass) :-
   InitializedClass(?class),
   DirectSuperclass(?class, ?superclass).

InitializedClass(?superinterface) :-
   InitializedClass(?classOrInterface),
   DirectSuperinterface(?classOrInterface, ?superinterface).
InitializedClass(?class) :-
   basic.MainMethodDeclaration(?method),
   Method_DeclaringType(?method, ?class).
InitializedClass(?class) :-
   Reachable(?inmethod),
   AssignHeapAllocation(?heap, _, ?inmethod),
   HeapAllocation_Type(?heap, ?class).
InitializedClass(?class) :-
   Reachable(?inmethod),
   Instruction_Method(?invocation, ?inmethod),
   isStaticMethodInvocation_Insn(?invocation),
   MethodInvocation_Method(?invocation, ?signature),
   Method_DeclaringType(?signature, ?class).
InitializedClass(?classOrInterface) :-
   Reachable(?inmethod),
   StoreStaticField(_, ?signature, ?inmethod),
   Field_DeclaringType(?signature, ?classOrInterface).
InitializedClass(?classOrInterface) :-
   Reachable(?inmethod),
   LoadStaticField(?signature, _, ?inmethod),
   Field_DeclaringType(?signature, ?classOrInterface).
.decl FinalizeContextRequest(?callerCtx:configuration.Context, ?hctx:configuration.HContext, ?fakeinvo:MethodInvocation, ?heapValue:Value, ?register:Method, ?formal:Var)
FinalizeContextRequest(?callerCtx, ?hctx, ?fakeinvo, ?heapValue, ?register, ?formal),
configuration.ContextRequest(?callerCtx, ?hctx, ?fakeinvo, ?heapValue, ?register, 1) :-
  FakeInvocation_RegisterFinalize(?heapValue, ?fakeinvo),
  basic.AllocatedObjectSupportsFinalize(?heapValue, ?inmethod),
  (!(HeapAllocation_Merge(?heapValue, _));
  HeapAllocation_Merge(?heapValue, ?heapValue)),
  ReachableContext(?callerCtx, ?inmethod),
  ?register = "<java.lang.ref.Finalizer: void register(java.lang.Object)>",
  isMethod(?register),
  FormalParam(0, ?register, ?formal),
  isImmutableHContext(?hctx).


ReachableContext(?calleeCtx, ?register),
VarPointsTo(?hctx, ?heapValue, ?calleeCtx, ?formal) :-
  configuration.ContextResponse(?callerCtx, ?hctx, ?fakeinvo, ?heapValue, ?register, ?calleeCtx),
  FinalizeContextRequest(?callerCtx, ?hctx, ?fakeinvo, ?heapValue, ?register, ?formal).
.plan 1:(2,1)




FakeInvocation_RegisterFinalize0(?val2,  cat("<register-finalize ", cat(?val1, cat( "/", cat(?val2, "  >")))) ),
isInstruction( cat("<register-finalize ", cat(?val1, cat( "/", cat(?val2, "  >")))) ), isMethodInvocation( cat("<register-finalize ", cat(?val1, cat( "/", cat(?val2, "  >")))) )  :-
    basic.AllocatedObjectSupportsFinalize(?val2, ?val1),
    isMethod(?val1),
    isHeapAllocation(?val2).
ImplicitReachable("<java.lang.System: void initializeSystemClass()>") :- isMethod("<java.lang.System: void initializeSystemClass()>") .
ImplicitReachable("<java.lang.Thread: void <init>(java.lang.ThreadGroup,java.lang.Runnable)>") :- isMethod("<java.lang.Thread: void <init>(java.lang.ThreadGroup,java.lang.Runnable)>") .
ImplicitReachable("<java.lang.Thread: void <init>(java.lang.ThreadGroup,java.lang.String)>") :- isMethod("<java.lang.Thread: void <init>(java.lang.ThreadGroup,java.lang.String)>") .
ImplicitReachable("<java.lang.ThreadGroup: void <init>()>") :- isMethod("<java.lang.ThreadGroup: void <init>()>") .
ImplicitReachable("<java.lang.Thread: void exit()>") :- isMethod("<java.lang.Thread: void exit()>") .
ImplicitReachable("<java.lang.ThreadGroup: void uncaughtException(java.lang.Thread,java.lang.Throwable)>") :- isMethod("<java.lang.ThreadGroup: void uncaughtException(java.lang.Thread,java.lang.Throwable)>") .
ImplicitReachable("<java.lang.ClassLoader: void <init>()>") :- isMethod("<java.lang.ClassLoader: void <init>()>") .
ImplicitReachable("<java.lang.ClassLoader: java.lang.Class loadClassInternal(java.lang.String)>") :- isMethod("<java.lang.ClassLoader: java.lang.Class loadClassInternal(java.lang.String)>") .
ImplicitReachable("<java.lang.ClassLoader: void checkPackageAccess(java.lang.Class,java.security.ProtectionDomain)>") :- isMethod("<java.lang.ClassLoader: void checkPackageAccess(java.lang.Class,java.security.ProtectionDomain)>") .
ImplicitReachable("<java.lang.ClassLoader: void addClass(java.lang.Class)>") :- isMethod("<java.lang.ClassLoader: void addClass(java.lang.Class)>") .
ImplicitReachable("<java.lang.ClassLoader: long findNative(java.lang.ClassLoader,java.lang.String)>") :- isMethod("<java.lang.ClassLoader: long findNative(java.lang.ClassLoader,java.lang.String)>") .
ImplicitReachable("<java.security.PrivilegedActionException: void <init>(java.lang.Exception)>") :- isMethod("<java.security.PrivilegedActionException: void <init>(java.lang.Exception)>") .
ApplicationEntryPoint(?meth) :-
  ForcedReachable(?meth),
  ApplicationMethod(?meth).

.decl ForcedReachableContext(?ctx:configuration.Context, ?meth:Method)


ForcedReachableContext(?ctx, ?method) :-
  ForcedReachable(?method),
  isImmutableContext(?ctx).


ReachableContext(?ctx, ?meth) :-
  ForcedReachableContext(?ctx, ?meth).


.decl FormalOfForcedReachableContext(?ctx:configuration.Context, ?formal:Var, ?formalType:Type)
FormalOfForcedReachableContext(?ctx, ?formal, ?formalType) :-
  ForcedReachableContext(?ctx, ?meth),
  FormalParam(_, ?meth, ?formal),
  Var_Type(?formal, ?formalType).

.decl ApplicationConcreteType(?type:ClassType)

ApplicationConcreteType(?type) :-
    ApplicationClass(?type),
    !isInterfaceType(?type),
    !ClassModifier("abstract", ?type).





.decl AllApplicationConcreteImplementations(?class:ClassType, ?type:Type)
.decl TypeHasApplicationConcreteSubtypes(?type:Type)

TypeHasApplicationConcreteSubtypes(?abstractType),
AllApplicationConcreteImplementations(?class, ?abstractType) :-
    ApplicationClass(?class),
    basic.SubtypeOf(?class, ?abstractType),
    ?abstractType != "java.lang.Object",
    !ClassModifier("abstract", ?class).

AllApplicationConcreteImplementations(?class, ?class) :- ConcreteClass(?class).

.decl ServletParamType(?paramType:ReferenceType)
ServletParamType(?paramType) :-
  basic.SubtypeOf(?paramType, "javax.servlet.ServletRequest");
  basic.SubtypeOf(?paramType, "javax.servlet.ServletResponse");
  basic.SubtypeOf(?paramType, "org.springframework.http.HttpMethod");
  basic.SubtypeOf(?paramType, "org.apache.commons.httpclient.HttpMethod");
  basic.SubtypeOf(?paramType, "org.springframework.extensions.webscripts.WebScriptRequest");
  basic.SubtypeOf(?paramType, "org.springframework.extensions.webscripts.WebScriptResponse");
  basic.SubtypeOf(?paramType, "javax.servlet.http.HttpServletRequest");
  basic.SubtypeOf(?paramType, "javax.servlet.http.HttpServletResponse");
  basic.SubtypeOf(?paramType, "javax.servlet.http.HttpSessionEvent");
  basic.SubtypeOf(?paramType, "javax.servlet.ServletContextEvent").


.decl SpecialConcreteImplementations(?class:ClassType, ?type:ReferenceType)
SpecialConcreteImplementations(?class, ?type) :-
  isClassType(?class),
  basic.SubtypeOf(?class, ?type),
  ServletParamType(?type).

.decl TypeToConcreteImplementation(?type:ReferenceType, ?class:ClassType)
TypeToConcreteImplementation(?type, ?class) :-
  AllApplicationConcreteImplementations(?class, ?type) ;
  SpecialConcreteImplementations(?class, ?type).
Value_isMock(?mockObj), isValue(?mockObj), Value_Type(?mockObj, ?class), Value_DeclaringType(?mockObj, "java.lang.Object") ,
MockObjFromOpenProgramEntryPointArg(?mockObj),
VarPointsTo(?hctx, ?mockObj, ?ctx, ?formal) :-
  FormalOfForcedReachableContext(?ctx, ?formal, ?formalType),
  TypeToConcreteImplementation(?formalType, ?class),
  isImmutableHContext(?hctx),
  ?mockObj = cat("<mock value for forced-reachable parameter ", cat(?class, ">")).


UnmockableFormalOfForcedReachableContext(?formal, ?formalType) :-
  FormalOfForcedReachableContext(_, ?formal, ?formalType),
  !TypeToConcreteImplementation(?formalType, _).
Value_isMock(?value), isValue(?value), Value_Type(?value, ?class), Value_DeclaringType(?value, "java.lang.Object") ,
VarPointsTo(?hctx, ?value, ?ctx, ?receiver),
MockObjFromOpenProgramEntryPointReceiver(?value),
MockObject(?value, ?class) :-
  ( ExercisedEntryPointMethod(?class, ?method)
  ; (ForcedReachable(?method), Method_DeclaringType(?method, ?class))),
  ThisVar(?method, ?receiver),
  ?value =  cat(?class, "::MockObject") ,
  mainAnalysis.isImmutableContext(?ctx),
  mainAnalysis.isImmutableHContext(?hctx).
ForcedReachable(?meth) :-
  (KeepMethod(?meth) ; RootCodeElement(?meth)),
  isMethod(?meth).




ForcedReachable(?meth) :-
  KeepClass(?class),
  basic.ClassConstructor(?meth, ?class),
  !FormalParam(_, ?meth, _).





ForcedReachableContext(?ctx, ?method) :-
  ( KeepClassMembers(?method) ; KeepClassesWithMembers(?method) ),
  Method_DeclaringType(?method, ?type),
  Method_DeclaringType(?someMethod, ?type),
  Reachable(?someMethod),
  isImmutableContext(?ctx).


VarPointsTo(?hctx, ?argArray, ?ctx, ?args),
ArrayIndexPointsTo(?hctx, ?argArrayContent, ?hctx, ?argArray) :-
   isImmutableHContext(?hctx),
   basic.MainMethodDeclaration(?mainMethod),
   ReachableContext(?ctx, ?mainMethod),
   FormalParam(0, ?mainMethod, ?args),
   MainMethodArgArray(?argArray),
   MainMethodArgArrayContent(?argArrayContent).
.decl SimulateNativeAllocation(?strMethod: Method, ?strHeap: HeapAllocation, ?strConstructor: Method)


AssignHeapAllocation(?strHeap, ?return, ?strMethod),
Value_DeclaringType(?strHeap, ?strType) :-
  SimulateNativeAllocation(?strMethod, ?strHeap, _),
  Method_DeclaringType(?strMethod, ?strType),
  NativeReturnVar(?return, ?strMethod),
  isHeapAllocation(?strHeap).


SpecialMethodInvocation_Base(?newInstrId, ?return),
Instruction_Method(?newInstrId, ?strMethod),
MethodInvocation_Method(?newInstrId, strConstructor),
isInstruction(?newInstrId), isMethodInvocation(?newInstrId), isSpecialMethodInvocation_Insn(?newInstrId) ,
Instruction_Index(?newInstrId, ?index) :-
  SimulateNativeAllocation(?strMethod, _, strConstructor),
  isMethod(?strMethod),
  NativeReturnVar(?return, ?strMethod),
  isMethod(strConstructor),
  ?index = 1,
  ?newInstrId = cat(?strMethod, cat("/native ", strConstructor)).

.decl SimulatedNativeAllocation(?heap:HeapAllocation, ?method:Method)
.output SimulatedNativeAllocation
AssignLocal(?this, ?ret, ?method) :-
  ?method = "<java.lang.Object: java.lang.Object clone()>",
  isMethod(?method),
  ThisVar(?method, ?this),
  ReturnVar(?ret, ?method).
StoreStaticField("<java.lang.System: void setIn0(java.io.InputStream)>/@parameter0", "<java.lang.System: java.io.InputStream in>", "<java.lang.System: void setIn0(java.io.InputStream)>") :- isMethod("<java.lang.System: void setIn0(java.io.InputStream)>"), isVar("<java.lang.System: void setIn0(java.io.InputStream)>/@parameter0"), isField("<java.lang.System: java.io.InputStream in>") .
StoreStaticField("<java.lang.System: void setIn0(java.io.InputStream)>/v1", "<java.lang.System: java.io.InputStream in>", "<java.lang.System: void setIn0(java.io.InputStream)>") :- isMethod("<java.lang.System: void setIn0(java.io.InputStream)>"), isVar("<java.lang.System: void setIn0(java.io.InputStream)>/v1"), isField("<java.lang.System: java.io.InputStream in>") .
StoreStaticField("<java.lang.System: void setOut0(java.io.PrintStream)>/@parameter0", "<java.lang.System: java.io.PrintStream out>", "<java.lang.System: void setOut0(java.io.PrintStream)>") :- isMethod("<java.lang.System: void setOut0(java.io.PrintStream)>"), isVar("<java.lang.System: void setOut0(java.io.PrintStream)>/@parameter0"), isField("<java.lang.System: java.io.PrintStream out>") .
StoreStaticField("<java.lang.System: void setOut0(java.io.PrintStream)>/v1", "<java.lang.System: java.io.PrintStream out>", "<java.lang.System: void setOut0(java.io.PrintStream)>") :- isMethod("<java.lang.System: void setOut0(java.io.PrintStream)>"), isVar("<java.lang.System: void setOut0(java.io.PrintStream)>/v1"), isField("<java.lang.System: java.io.PrintStream out>") .
StoreStaticField("<java.lang.System: void setErr0(java.io.PrintStream)>/@parameter0", "<java.lang.System: java.io.PrintStream err>", "<java.lang.System: void setErr0(java.io.PrintStream)>") :- isMethod("<java.lang.System: void setErr0(java.io.PrintStream)>"), isVar("<java.lang.System: void setErr0(java.io.PrintStream)>/@parameter0"), isField("<java.lang.System: java.io.PrintStream err>") .
StoreStaticField("<java.lang.System: void setErr0(java.io.PrintStream)>/v1", "<java.lang.System: java.io.PrintStream err>", "<java.lang.System: void setErr0(java.io.PrintStream)>") :- isMethod("<java.lang.System: void setErr0(java.io.PrintStream)>"), isVar("<java.lang.System: void setErr0(java.io.PrintStream)>/v1"), isField("<java.lang.System: java.io.PrintStream err>") .
isVar(cat(?invocation, "/@tmp-arraycopy")), Var_Type(cat(?invocation, "/@tmp-arraycopy"), ?tmpType), Var_DeclaringMethod(cat(?invocation, "/@tmp-arraycopy"), ?inmethod) ,
LoadArrayIndex(?src, cat(?invocation, "/@tmp-arraycopy"), ?inmethod),
StoreArrayIndex(cat(?invocation, "/@tmp-arraycopy"), ?dest, ?inmethod) :-
   ?arraycopy = "<java.lang.System: void arraycopy(java.lang.Object,int,java.lang.Object,int,int)>",
   isMethod(?arraycopy),
   StaticMethodInvocation(?invocation, ?arraycopy, ?inmethod),
   ActualParam(0, ?invocation, ?src),
   ActualParam(2, ?invocation, ?dest),
   isMethodInvocation(?invocation),
   ?tmpType = "java.lang.Object",
   isType(?tmpType).
StoreArrayIndex(?from, ?base, ?inmethod) :-
  ?casObject = "<sun.misc.Unsafe: boolean compareAndSwapObject(java.lang.Object,long,java.lang.Object,java.lang.Object)>",
  isMethod(?casObject),
  VirtualMethodInvocation(?invocation, ?casObject, ?inmethod),
  ActualParam(0, ?invocation, ?base),
  ActualParam(3, ?invocation, ?from).

StoreArrayIndex(?from, ?base, ?inmethod) :-
  (?putObj = "<sun.misc.Unsafe: void putObject(java.lang.Object,long,java.lang.Object)>";
   ?putObj = "<sun.misc.Unsafe: void putObject(java.lang.Object,int,java.lang.Object)>";
   ?putObj = "<sun.misc.Unsafe: void putObjectVolatile(java.lang.Object,long,java.lang.Object)>";
   ?putObj = "<sun.misc.Unsafe: void putOrderedObject(java.lang.Object,long,java.lang.Object)>"),
  isMethod(?putObj),
  VirtualMethodInvocation(?invocation, ?putObj, ?inmethod),
  ActualParam(0, ?invocation, ?base),
  ActualParam(2, ?invocation, ?from).

LoadArrayIndex(?base, ?to, ?inmethod) :-
  (?getObj = "<sun.misc.Unsafe: java.lang.Object getObjectVolatile(java.lang.Object,long)>";
   ?getObj = "<sun.misc.Unsafe: java.lang.Object getObject(java.lang.Object,long)>";
   ?getObj = "<sun.misc.Unsafe: java.lang.Object getObject(java.lang.Object,int)>"),
  isMethod(?getObj),
  VirtualMethodInvocation(?invocation, ?getObj, ?inmethod),
  ActualParam(0, ?invocation, ?base),
  AssignReturnValue(?invocation, ?to).
SimulatedNativeAllocation("<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>/new java.lang.String[]/0", "<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>"). SimulatedNativeAllocation("<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>/new java.lang.String/0", "<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>"). AssignHeapAllocation("<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>/new java.lang.String[]/0", ?return, "<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>") :- isMethod("<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>"), NativeReturnVar(?return, "<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>"), isHeapAllocation("<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>/new java.lang.String[]/0"). isVar(cat("<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>", "/@native-array-element")), Var_Type(cat("<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>", "/@native-array-element"), "java.lang.String"), Var_DeclaringMethod(cat("<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>", "/@native-array-element"), "<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>"), AssignHeapAllocation("<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>/new java.lang.String/0", cat("<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>", "/@native-array-element"), "<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>"), StoreArrayIndex(cat("<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>", "/@native-array-element"), ?base, "<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>") :- isMethod("<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>"), NativeReturnVar(?base, "<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>"), isType("java.lang.String"), isHeapAllocation("<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>/new java.lang.String/0") .
isInstruction(cat("<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", cat("/native ", "<java.lang.Object: void finalize()>"))), isMethodInvocation(cat("<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", cat("/native ", "<java.lang.Object: void finalize()>"))), isVirtualMethodInvocation_Insn(cat("<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", cat("/native ", "<java.lang.Object: void finalize()>"))) , VirtualMethodInvocation(cat("<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", cat("/native ", "<java.lang.Object: void finalize()>")), "<java.lang.Object: void finalize()>", "<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>"), VirtualMethodInvocation_Base(cat("<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", cat("/native ", "<java.lang.Object: void finalize()>")), ?base), Instruction_Method(cat("<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", cat("/native ", "<java.lang.Object: void finalize()>")), "<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>"), MethodInvocation_Method(cat("<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", cat("/native ", "<java.lang.Object: void finalize()>")), "<java.lang.Object: void finalize()>"), Instruction_Index(cat("<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", cat("/native ", "<java.lang.Object: void finalize()>")), ?index) :- isMethod("<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>"), FormalParam(0, "<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", ?base), isMethod("<java.lang.Object: void finalize()>"), ?index = 1. isInstruction(cat("<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", cat("/native ", "<java.lang.Object: void finalize()>"))), isMethodInvocation(cat("<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", cat("/native ", "<java.lang.Object: void finalize()>"))) , AssignReturnValue(cat("<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", cat("/native ", "<java.lang.Object: void finalize()>")), ?return) :- isMethod("<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>"), NativeReturnVar(?return, "<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>") .
isInstruction(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", cat("/native ", "<java.security.PrivilegedAction: java.lang.Object run()>"))), isMethodInvocation(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", cat("/native ", "<java.security.PrivilegedAction: java.lang.Object run()>"))), isVirtualMethodInvocation_Insn(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", cat("/native ", "<java.security.PrivilegedAction: java.lang.Object run()>"))) , VirtualMethodInvocation(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", cat("/native ", "<java.security.PrivilegedAction: java.lang.Object run()>")), "<java.security.PrivilegedAction: java.lang.Object run()>", "<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>"), VirtualMethodInvocation_Base(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", cat("/native ", "<java.security.PrivilegedAction: java.lang.Object run()>")), ?base), Instruction_Method(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", cat("/native ", "<java.security.PrivilegedAction: java.lang.Object run()>")), "<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>"), MethodInvocation_Method(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", cat("/native ", "<java.security.PrivilegedAction: java.lang.Object run()>")), "<java.security.PrivilegedAction: java.lang.Object run()>"), Instruction_Index(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", cat("/native ", "<java.security.PrivilegedAction: java.lang.Object run()>")), ?index) :- isMethod("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>"), FormalParam(0, "<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", ?base), isMethod("<java.security.PrivilegedAction: java.lang.Object run()>"), ?index = 1. isInstruction(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", cat("/native ", "<java.security.PrivilegedAction: java.lang.Object run()>"))), isMethodInvocation(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", cat("/native ", "<java.security.PrivilegedAction: java.lang.Object run()>"))) , AssignReturnValue(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", cat("/native ", "<java.security.PrivilegedAction: java.lang.Object run()>")), ?return) :- isMethod("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>"), NativeReturnVar(?return, "<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>") .
isInstruction(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", cat("/native ", "<java.security.PrivilegedAction: java.lang.Object run()>"))), isMethodInvocation(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", cat("/native ", "<java.security.PrivilegedAction: java.lang.Object run()>"))), isVirtualMethodInvocation_Insn(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", cat("/native ", "<java.security.PrivilegedAction: java.lang.Object run()>"))) , VirtualMethodInvocation(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", cat("/native ", "<java.security.PrivilegedAction: java.lang.Object run()>")), "<java.security.PrivilegedAction: java.lang.Object run()>", "<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>"), VirtualMethodInvocation_Base(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", cat("/native ", "<java.security.PrivilegedAction: java.lang.Object run()>")), ?base), Instruction_Method(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", cat("/native ", "<java.security.PrivilegedAction: java.lang.Object run()>")), "<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>"), MethodInvocation_Method(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", cat("/native ", "<java.security.PrivilegedAction: java.lang.Object run()>")), "<java.security.PrivilegedAction: java.lang.Object run()>"), Instruction_Index(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", cat("/native ", "<java.security.PrivilegedAction: java.lang.Object run()>")), ?index) :- isMethod("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>"), FormalParam(0, "<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", ?base), isMethod("<java.security.PrivilegedAction: java.lang.Object run()>"), ?index = 1. isInstruction(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", cat("/native ", "<java.security.PrivilegedAction: java.lang.Object run()>"))), isMethodInvocation(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", cat("/native ", "<java.security.PrivilegedAction: java.lang.Object run()>"))) , AssignReturnValue(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", cat("/native ", "<java.security.PrivilegedAction: java.lang.Object run()>")), ?return) :- isMethod("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>"), NativeReturnVar(?return, "<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>") .
isInstruction(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", cat("/native ", "<java.security.PrivilegedExceptionAction: java.lang.Object run()>"))), isMethodInvocation(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", cat("/native ", "<java.security.PrivilegedExceptionAction: java.lang.Object run()>"))), isVirtualMethodInvocation_Insn(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", cat("/native ", "<java.security.PrivilegedExceptionAction: java.lang.Object run()>"))) , VirtualMethodInvocation(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", cat("/native ", "<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), "<java.security.PrivilegedExceptionAction: java.lang.Object run()>", "<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>"), VirtualMethodInvocation_Base(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", cat("/native ", "<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), ?base), Instruction_Method(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", cat("/native ", "<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), "<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>"), MethodInvocation_Method(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", cat("/native ", "<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), "<java.security.PrivilegedExceptionAction: java.lang.Object run()>"), Instruction_Index(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", cat("/native ", "<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), ?index) :- isMethod("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>"), FormalParam(0, "<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", ?base), isMethod("<java.security.PrivilegedExceptionAction: java.lang.Object run()>"), ?index = 1. isInstruction(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", cat("/native ", "<java.security.PrivilegedExceptionAction: java.lang.Object run()>"))), isMethodInvocation(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", cat("/native ", "<java.security.PrivilegedExceptionAction: java.lang.Object run()>"))) , AssignReturnValue(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", cat("/native ", "<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), ?return) :- isMethod("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>"), NativeReturnVar(?return, "<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>") .
isInstruction(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", cat("/native ", "<java.security.PrivilegedExceptionAction: java.lang.Object run()>"))), isMethodInvocation(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", cat("/native ", "<java.security.PrivilegedExceptionAction: java.lang.Object run()>"))), isVirtualMethodInvocation_Insn(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", cat("/native ", "<java.security.PrivilegedExceptionAction: java.lang.Object run()>"))) , VirtualMethodInvocation(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", cat("/native ", "<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), "<java.security.PrivilegedExceptionAction: java.lang.Object run()>", "<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>"), VirtualMethodInvocation_Base(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", cat("/native ", "<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), ?base), Instruction_Method(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", cat("/native ", "<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), "<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>"), MethodInvocation_Method(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", cat("/native ", "<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), "<java.security.PrivilegedExceptionAction: java.lang.Object run()>"), Instruction_Index(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", cat("/native ", "<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), ?index) :- isMethod("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>"), FormalParam(0, "<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", ?base), isMethod("<java.security.PrivilegedExceptionAction: java.lang.Object run()>"), ?index = 1. isInstruction(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", cat("/native ", "<java.security.PrivilegedExceptionAction: java.lang.Object run()>"))), isMethodInvocation(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", cat("/native ", "<java.security.PrivilegedExceptionAction: java.lang.Object run()>"))) , AssignReturnValue(cat("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", cat("/native ", "<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), ?return) :- isMethod("<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>"), NativeReturnVar(?return, "<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>") .
SimulateNativeAllocation(
  "<sun.misc.Perf: java.nio.ByteBuffer createLong(java.lang.String,int,int,long)>",
  "<sun.misc.Perf: java.nio.ByteBuffer createLong(java.lang.String,int,int,long)>/new java.nio.DirectByteBuffer/0",
  "<java.nio.DirectByteBuffer: void <init>()>").
.decl StoreIntoWeakReference(?basehctx:configuration.HContext, ?basevalue:Value, ?ctx:configuration.Context, ?from:Var)
.decl LoadFromReference(?ctx:configuration.Context, ?to:Var, ?basehctx:configuration.HContext, ?basevalue:Value)

.decl StoreIntoWeakReferenceArgs(?from:Var, ?base:Var)
StoreIntoWeakReferenceArgs(?from, ?base) :-
  ?weakRefCtor = "<java.lang.ref.WeakReference: void <init>(java.lang.Object)>",
  MethodInvocation_Method(?invo, ?weakRefCtor),
  OptSpecialMethodInvocationBase(?invo, ?base),
  ActualParam(0, ?invo, ?from).

StoreIntoWeakReference(?basehctx, ?basevalue, ?ctx, ?from) :-
  StoreIntoWeakReferenceArgs(?from, ?base),
  VarPointsTo(?basehctx, ?basevalue, ?ctx, ?base).

.decl LoadFromReferenceArgs(?base:Var, ?to:Var)
LoadFromReferenceArgs(?base, ?to) :-
  ?refGet = "<java.lang.ref.Reference: java.lang.Object getReferent()>",
  MethodInvocation_Method(?invo, ?refGet),
  OptSpecialMethodInvocationBase(?invo, ?base),
  AssignReturnValue(?invo, ?to).

LoadFromReference(?ctx, ?to, ?basehctx, ?basevalue) :-
  LoadFromReferenceArgs(?base, ?to),
  VarPointsTo(?basehctx, ?basevalue, ?ctx, ?base).

HeapInterproceduralAssign(?ctxTo, ?to, ?ctxFrom, ?from) :-
  LoadFromReference(?ctxTo, ?to, ?basehctx, ?basevalue),
  StoreIntoWeakReference(?basehctx, ?basevalue, ?ctxFrom, ?from),
  !Value_Null(?basevalue).
  .plan 1:(2,1)
.decl isNativeContext(?ctx:configuration.Context)
isNativeContext(?ctx) :- isImmutableContext(?ctx).
StaticFieldPointsTo(?hctx, ?value, ?pending) :-
   ?pending = "<java.lang.ref.Reference: java.lang.ref.Reference pending>",
   ( ?this = "<java.lang.ref.Reference: void <init>(java.lang.Object,java.lang.ref.ReferenceQueue)>/@this" ;
   ?this = "<java.lang.ref.Reference: void <init>(java.lang.Object,java.lang.ref.ReferenceQueue)>/v1"),
   isField(?pending),
   isVar(?this),
   VarPointsTo(?hctx, ?value, _, ?this).
.decl HeapAllocation_ContextInsensitive(?heap:HeapAllocation)


HeapAllocation_ContextInsensitive(?heap) :-
  HeapAllocation_Merge(?heap, _).
.decl HeapAllocation_Merge(?heap:HeapAllocation, ?mergeHeap:HeapAllocation)


.decl HeapAllocation_Keep(?heap:HeapAllocation)
.decl AssignNormalHeapAllocation(?heap:HeapAllocation, ?var:Var, ?inmethod:Method)
.decl AssignContextInsensitiveHeapAllocation(?heap:HeapAllocation, ?var:Var, ?inmethod:Method)

AssignNormalHeapAllocation(?heap, ?var, ?inmethod) :-
  AssignHeapAllocation(?heap, ?var, ?inmethod),
  !HeapAllocation_ContextInsensitive(?heap).

AssignContextInsensitiveHeapAllocation(?mergeHeap, ?var, ?inmethod) :-
  AssignHeapAllocation(?heap, ?var, ?inmethod),
  HeapAllocation_Merge(?heap, ?mergeHeap).

AssignContextInsensitiveHeapAllocation(?heap, ?var, ?inmethod) :-
  AssignHeapAllocation(?heap, ?var, ?inmethod),
  HeapAllocation_ContextInsensitive(?heap),
  !(HeapAllocation_Merge(?heap, _)).
.decl HeapRepresentative(?heap:HeapAllocation, ?heapRepr:symbol)
.decl HeapIsMergedString(?heap:HeapAllocation)



HeapIsMergedString(?heap) :-
  HeapRepresentative("<<string-constant>>", ?heap).

.decl HeapIsMergedStringFactory(?heap:HeapAllocation)


HeapAllocation_Merge(?heap, ?heapRepr) :-
  ?heapRepr = "<<string-constant>>",
  HeapRepresentative(?heapRepr, ?heap).

HeapIsMergedStringFactory(?heap) :-
  HeapRepresentative("<<string-buffer>>", ?heap);
  HeapRepresentative("<<string-builder>>", ?heap).

HeapAllocation_Merge(?heap, ?heapRepr) :-
  (?heapRepr = "<<string-buffer>>",
   HeapRepresentative(?heapRepr, ?heap));
  (?heapRepr = "<<string-builder>>",
   HeapRepresentative(?heapRepr, ?heap));


  (?heapRepr = "<<pystring-object>>",
   HeapRepresentative(?heapRepr, ?heap)).

.decl RepresentativesToPickFrom(?heapRepr:HeapAllocation, ?heap:HeapAllocation)

RepresentativesToPickFrom(?heapRepr, ?heap) :-
  HeapRepresentative(?heapRepr, ?heap),
  !HeapIsMergedString(?heap),
  !HeapIsMergedStringFactory(?heap),
  !HeapAllocation_Keep(?heap).

.decl MinRepresentativeHeapToPickFromOrdinal(?minHeapReprOrd:number, ?heap:HeapAllocation)

MinRepresentativeHeapToPickFromOrdinal(?minHeapReprOrd, ?heap) :-
  RepresentativesToPickFrom(_, ?heap),
  ?minHeapReprOrd = min ord(?heapRepr): RepresentativesToPickFrom(?heapRepr, ?heap).

HeapAllocation_Merge(?heap, ?mergeHeap) :-
  isHeapAllocation(?mergeHeap),
  ord(?mergeHeap) = ?minHeapReprOrd,
  MinRepresentativeHeapToPickFromOrdinal(?minHeapReprOrd, ?heap).
HeapRepresentative(?constant, ?heap) :-
  isStringConstant(?heap),
  ?constant = "<<string-constant>>",
  isHeapAllocation(?constant),
  !HeapAllocation_Keep(?heap).
.decl ReflectionStringConstant(?heap:HeapAllocation)
.decl ReflectionSubstringObject(?heap:HeapAllocation)
HeapAllocation_ContextInsensitive(?heap) :-
  isStringConstant(?heap),
  !HeapRepresentative(_, ?heap).

.decl NonTrivialStringConstant(?heap:StringConstant)

NonTrivialStringConstant(?heap) :-
  isStringConstant(?heap),
  strlen(?heap) >= 7.
.decl ClassNameMatchingStringConstant_Type(?type:Type, ?heap:HeapAllocation)
.decl MethodNameMatchingStringConstant_Signature(?sig:Method, ?heap:HeapAllocation)
.decl FieldNameMatchingStringConstant_Signature(?sig:Field, ?heap:HeapAllocation)

.decl PreClassNameMatchingStringConstant(?heap:HeapAllocation)
.decl PreClassNameMatchingStringConstant_Type(?type:Type, ?heap:HeapAllocation)
.decl PreClassNameMatchingStringConstantExact_Type(?type:Type, ?heap:HeapAllocation)
.decl PreClassNameMatchingStringConstantInexact_Type(?type:Type, ?heap:HeapAllocation)




ClassNameMatchingStringConstant_Type(?type, ?heap) :-
  PreClassNameMatchingStringConstant_Type(?type, ?heap).
MethodNameMatchingStringConstant_Signature(?sig, ?heap) :-
  PreMethodNameMatchingStringConstant_Signature(?sig, ?heap).
FieldNameMatchingStringConstant_Signature(?sig, ?heap) :-
  PreFieldNameMatchingStringConstant_Signature(?sig, ?heap).




PreClassNameMatchingStringConstant(?string),
PreClassNameMatchingStringConstant_Type(?type, ?string),
PreClassNameMatchingStringConstantExact_Type(?type, ?string) :-
  isStringConstant(?string),
  isReferenceType(?type),

  ApplicationClass(?type),








  ord(?type) = ord(?string).

.decl PreMethodNameMatchingStringConstant(?heap:HeapAllocation)
.decl PreMethodNameMatchingStringConstant_Signature(?sig:Method, ?heap:HeapAllocation)
.decl PreMethodNameMatchingStringConstantExact_Signature(?sig:Method, ?heap:HeapAllocation)
.decl PreMethodNameMatchingStringConstantInexact_Signature(?sig:Method, ?heap:HeapAllocation)

PreMethodNameMatchingStringConstant(?string),
PreMethodNameMatchingStringConstant_Signature(?sig, ?string),
PreMethodNameMatchingStringConstantExact_Signature(?sig, ?string) :-
  isStringConstant(?string),






  Method_SimpleName(?sig, ?string),
  ?string != "<init>",
  ?string != "<clinit>".

.decl PreFieldNameMatchingStringConstant(?heap:HeapAllocation)
.decl PreFieldNameMatchingStringConstant_Signature(?sig:Field, ?heap:HeapAllocation)
.decl PreFieldNameMatchingStringConstantExact_Signature(?sig:Field, ?heap:HeapAllocation)
.decl PreFieldNameMatchingStringConstantInexact_Signature(?sig:Field, ?heap:HeapAllocation)

PreFieldNameMatchingStringConstant(?string),
PreFieldNameMatchingStringConstant_Signature(?sig, ?string),
PreFieldNameMatchingStringConstantExact_Signature(?sig, ?string) :-
  isStringConstant(?string),







  Field_SimpleName(?sig, ?string).
HeapAllocation_ContextInsensitive(?heap) :-
  isClassHeap(?heap).
.decl MethodAllocationMergeThreshold(?t:number)

MethodAllocationMergeThreshold(50).

.decl ExceptionType(?type:Type)

ExceptionType(?type) :-
  ?throw = "java.lang.Throwable",
  isType(?throw),
  basic.SubtypeOf(?type, ?throw).

.decl OptAssignHeapAllocation(?inmethod:Method, ?heap:HeapAllocation)

OptAssignHeapAllocation(?inmethod, ?heap) :-
  AssignHeapAllocation(?heap, _, ?inmethod).



.decl ObjectMultipleAllocated(?heap:HeapAllocation)

ObjectMultipleAllocated(?heap) :-
  OptAssignHeapAllocation(?inmethod1, ?heap),
  OptAssignHeapAllocation(?inmethod2, ?heap),
  ?inmethod1 != ?inmethod2.

.decl MethodAndTypeToHeap(?heap:HeapAllocation, ?heapType:Type, ?method:Method)

MethodAndTypeToHeap(?heap, ?heaptype, ?meth) :-
  AssignHeapAllocation(?heap, _, ?meth),
  HeapAllocation_Type(?heap, ?heaptype),
  !isStringConstant(?heap),
  !StringFactoryHeap(?heap),
  !HeapAllocation_EmptyArray(?heap),
  !ObjectMultipleAllocated(?heap),
  !HeapAllocation_Keep(?heap).

.decl AllocationsPerMethodAndType(?type:Type, ?meth:Method, ?n:number)

AllocationsPerMethodAndType(?type, ?meth, ?n) :-
  MethodAndTypeToHeap(_, ?type, ?meth),
  ?n = count : MethodAndTypeToHeap(_, ?type, ?meth).

.decl AllocationShouldBeMergedPerMethod(?heaptype:Type, ?meth:Method)

AllocationShouldBeMergedPerMethod(?heaptype, ?meth) :-
  AllocationsPerMethodAndType(?heaptype, ?meth, ?n),
  MethodAllocationMergeThreshold(?t),
  ?n > ?t.

.decl MethodAndTypeToMergedHeap(?heap:HeapAllocation, ?heaptype:Type, ?meth:Method)

MethodAndTypeToMergedHeap(?heap, ?heaptype, ?meth) :-
  AllocationShouldBeMergedPerMethod(?heaptype, ?meth),
  MethodAndTypeToHeap(?heap, ?heaptype, ?meth).

.decl MinHeapOrdinalPerMethodAndType(?ord:number, ?type:Type, ?meth:Method)
.decl MethodAndTypeToRepresentative(?type:Type, ?meth:Method, ?reprHeap:HeapAllocation)

MinHeapOrdinalPerMethodAndType(?minHeapOrd, ?type, ?meth) :-
  MethodAndTypeToMergedHeap(_, ?type, ?meth),
  ?minHeapOrd = min ord(?heap): MethodAndTypeToMergedHeap(?heap, ?type, ?meth).

MethodAndTypeToRepresentative(?type, ?meth, ?representativeHeap) :-
  isHeapAllocation(?representativeHeap),
  MinHeapOrdinalPerMethodAndType(?minHeapOrd, ?type, ?meth),
  ord(?representativeHeap) = ?minHeapOrd.


HeapRepresentative(?representativeHeap, ?heap) :-
  MethodAndTypeToRepresentative(?type, ?meth, ?representativeHeap),
  MethodAndTypeToMergedHeap(?heap, ?type, ?meth).




.decl ClassAndTypeToHeap(?heap:HeapAllocation, ?heaptype:Type, ?class:ReferenceType)
.decl AllocationsPerClassAndType(?type:Type, ?class:ReferenceType, ?n:number)

ClassAndTypeToHeap(?heap, ?heaptype, ?class) :-
  MethodAndTypeToHeap(?heap, ?heaptype, ?meth),
  Method_DeclaringType(?meth, ?class).

AllocationsPerClassAndType(?type, ?class, ?n) :-
  ClassAndTypeToHeap(_, ?type, ?class),
  ?n = count : ClassAndTypeToHeap(_, ?type, ?class).


.decl AllocationShouldBeMergedPerClass(?heaptype:Type, ?class:Type)

.decl ClassAndTypeToMergedHeap(?heap:HeapAllocation, ?heaptype:Type, ?class:Type)

ClassAndTypeToMergedHeap(?heap, ?heaptype, ?class) :-
  AllocationShouldBeMergedPerClass(?heaptype, ?class),
  ClassAndTypeToHeap(?heap, ?heaptype, ?class).

.decl MinHeapOrdinalPerClassAndType(?minHeapOrd:number, ?type:Type, ?class:Type)
.decl ClassAndTypeToRepresentative(?type:Type, ?class:Type, ?reprHeap:HeapAllocation)

MinHeapOrdinalPerClassAndType(?minHeapOrd, ?type, ?class) :-
  ClassAndTypeToMergedHeap(_, ?type, ?class),
  ?minHeapOrd = min ord(?heap): ClassAndTypeToMergedHeap(?heap, ?type, ?class).

ClassAndTypeToRepresentative(?type, ?class, ?representativeHeap) :-
  isHeapAllocation(?representativeHeap),
  MinHeapOrdinalPerClassAndType(?minHeapOrd, ?type, ?class),
  ord(?representativeHeap) = ?minHeapOrd.


HeapRepresentative(?representativeHeap, ?heap) :-
  ClassAndTypeToRepresentative(?type, ?class, ?representativeHeap),
  ClassAndTypeToMergedHeap(?heap, ?type, ?class).
.decl ClassNameIndexes(?pos:number, ?type:ClassType)

ClassNameIndexes(0, ?type) :-
  isClassType(?type).

ClassNameIndexes(?pos+1, ?t) :-
  ClassNameIndexes(?pos, ?t),
  ?pos+1 < strlen(?t).


.decl DotsInClassName(?type:ClassType, ?pos:number)
.decl NotLastDot(?pos:number, ?type:ClassType)
.decl NotSecondLastDot(?pos:number, ?type:ClassType)
.decl LastDot(?type:ClassType, ?pos:number)
.decl SecondLastDot(?type:ClassType, ?pos:number)

.decl Class_PackageHack(?type:ClassType, ?packageName:symbol)

DotsInClassName(?type, ?pos) :-
  ClassNameIndexes(?pos, ?type),
  substr(?type, ?pos, 1) = ".".

NotLastDot(?pos, ?type) :-
  DotsInClassName(?type, ?pos),
  DotsInClassName(?type, ?pos2),
  ?pos2 > ?pos.

NotSecondLastDot(?pos, ?type) :-
  DotsInClassName(?type, ?pos),
  DotsInClassName(?type, ?pos2),
  ?pos2 > ?pos,
  NotLastDot(?pos2, ?type).

NotSecondLastDot(?pos, ?type) :-
  LastDot(?type, ?pos).

LastDot(?type, ?pos) :-
  DotsInClassName(?type, ?pos),
  !NotLastDot(?pos, ?type).

SecondLastDot(?type, ?pos) :-
  DotsInClassName(?type, ?pos),
  !NotSecondLastDot(?pos, ?type).


Class_PackageHack(?type, substr(?type, 0, ?secondLastPos)) :-
  SecondLastDot(?type, ?secondLastPos),
  isClassType(?type).

Class_PackageHack(?type, substr(?type, 0, ?lastPos)) :-
  !(SecondLastDot(?type, _)),
  isClassType(?type),
  LastDot(?type, ?lastPos).

Class_PackageHack(?type, ?type) :-
  !(LastDot(?type, _)),
  isClassType(?type).

.decl PackageAndTypeToHeap(?heap:HeapAllocation, ?heaptype:Type, ?packageName:symbol)
.decl AllocationsPerPackageAndType(?type:Type, ?packageName:symbol, ?n:number)

PackageAndTypeToHeap(?heap, ?heaptype, ?packageName) :-
  ClassAndTypeToHeap(?heap, ?heaptype, ?class),
  Class_PackageHack(?class, ?packageName).

AllocationsPerPackageAndType(?type, ?packageName, ?n) :-
  PackageAndTypeToHeap(_, ?type, ?packageName),
  ?n = count : PackageAndTypeToHeap(_, ?type, ?packageName).


.decl AllocationShouldBeMergedPerPackage(?heaptype:Type, ?packageName:symbol)

.decl PackageAndTypeToMergedHeap(?heap:HeapAllocation, ?heaptype:Type, ?packageName:symbol)

PackageAndTypeToMergedHeap(?heap, ?heaptype, ?packageName) :-
  AllocationShouldBeMergedPerPackage(?heaptype, ?packageName),
  PackageAndTypeToHeap(?heap, ?heaptype, ?packageName).

.decl MinHeapOrdinalPerPackageAndType(?minHeapOrd:number, ?type:Type, ?packageName:symbol)
.decl PackageAndTypeToRepresentative(?type:Type, ?packageName:symbol, ?representativeHeap:HeapAllocation)

MinHeapOrdinalPerPackageAndType(?minHeapOrd, ?type, ?packageName) :-
  PackageAndTypeToMergedHeap(_, ?type, ?packageName),
  ?minHeapOrd = min ord(?heap): PackageAndTypeToMergedHeap(?heap, ?type, ?packageName).

PackageAndTypeToRepresentative(?type, ?packageName, ?representativeHeap) :-
  isHeapAllocation(?representativeHeap),
  MinHeapOrdinalPerPackageAndType(?minHeapOrd, ?type, ?packageName),
  ord(?representativeHeap) = ?minHeapOrd.


HeapRepresentative(?representativeHeap, ?heap) :-
  PackageAndTypeToRepresentative(?type, ?packageName, ?representativeHeap),
  PackageAndTypeToMergedHeap(?heap, ?type, ?packageName).


.decl TypeToHeap(?heap:HeapAllocation, ?heaptype:Type)
.decl AllocationsPerType(?type:Type, ?n:number)

TypeToHeap(?heap, ?heaptype) :-
  ClassAndTypeToHeap(?heap, ?heaptype, _).

AllocationsPerType(?type, ?n) :-
  TypeToHeap(_, ?type),
  ?n = count : TypeToHeap(_, ?type).


.decl AllocationShouldBeMergedGlobally(?heaptype:Type)

.decl TypeToMergedHeap(?heap:HeapAllocation, ?heaptype:Type)

TypeToMergedHeap(?heap, ?heaptype) :-
  AllocationShouldBeMergedGlobally(?heaptype),
  TypeToHeap(?heap, ?heaptype).

.decl MinHeapOrdinalPerType(?minHeapOrd:number, ?type:Type)
.decl TypeToRepresentative(?type:Type, ?representativeHeap:HeapAllocation)

MinHeapOrdinalPerType(?minHeapOrd, ?type) :-
  TypeToMergedHeap(_, ?type),
  ?minHeapOrd = min ord(?heap): TypeToMergedHeap(?heap, ?type).

TypeToRepresentative(?type, ?representativeHeap) :-
  isHeapAllocation(?representativeHeap),
  MinHeapOrdinalPerType(?minHeapOrd, ?type),
  ord(?representativeHeap) = ?minHeapOrd.


HeapRepresentative(?representativeHeap, ?heap) :-
  TypeToRepresentative(?type, ?representativeHeap),
  TypeToMergedHeap(?heap, ?type).
.decl SpecialLibraryObject(?heap:HeapAllocation)

SpecialLibraryObject(?heap) :-
  AssignHeapAllocation_Heap(?insn, ?heap),
  Instruction_Method(?insn, ?method),
  SpecialLibraryMethod(?method).

.decl SpecialLibraryMethod(?method:Method)
SpecialLibraryMethod(?method) :-
  Method_DeclaringType(?method, ?class),
  SpecialLibraryClass(?class).

.decl SpecialLibraryClass(?class:Type)
SpecialLibraryClass(?class) :-
  isClassType(?class),
  !ApplicationClass(?class),
  !CollectionClass(?class).

.decl CollectionClass(?class:Type)
CollectionClass(?class) :-
  isClassType(?class),
  !ApplicationClass(?class),
  basic.SubtypeOf(?class, ?superclass),
  (?superclass = "java.util.Map";
   ?superclass = "java.util.Collection";
   ?superclass = "java.util.Iterable";
   ?superclass = "java.util.Iterator";
   ?superclass = "java.util.Comparator";
   ?superclass = "java.util.Dictionary";
   ?superclass = "java.util.TimSort";
   ?superclass = "java.util.ComparableTimSort";
   ?superclass = "java.util.Arrays";
   ?superclass = "java.util.Objects";
   ?superclass = "java.util.Collections").

.decl CollectionInnerClass(?class:ClassType)

CollectionInnerClass(?innerClass),
CollectionClass(?innerClass) :-
  CollectionInnerClassPrefix(?innerClassPrefix),
  isClassType(?innerClass),
  substr(?innerClass, 0, strlen(?innerClassPrefix)) = ?innerClassPrefix.

.decl CollectionInnerClassPrefix(?innerClassPrefix:symbol)

CollectionInnerClassPrefix(?innerClassPrefix) :-
  CollectionClass(?class),
  ?innerClassPrefix = cat(?class, "$").

.output CollectionClass
  HeapAllocation_ContextInsensitive(?heap) :-
    SpecialLibraryObject(?heap),
    !HeapRepresentative(_, ?heap).


    AllocationShouldBeMergedPerMethod(?heaptype, ?meth) :-
      AllocationsPerMethodAndType(?heaptype, ?meth, ?n),
      ?n > 1,
      Method_DeclaringType(?meth, ?class),
      SpecialLibraryClass(?class).
.decl _StringFactoryType(?type:Type)
_StringFactoryType(?type) :-
  ?type = "java.lang.StringBuffer" ;
  ?type = "java.lang.StringBuilder".

.decl StringFactoryHeap(?heap:HeapAllocation)
StringFactoryHeap(?heap) :-
  HeapAllocation_Type(?heap, ?heaptype),
  _StringFactoryType(?heaptype).


.decl StringFactoryType(?type:Type)
StringFactoryType(?type) :-
  _StringFactoryType(?type).
HeapRepresentative("<<string-buffer>>", ?heap) :-
  HeapAllocation_Type(?heap, "java.lang.StringBuffer"),
  !HeapAllocation_Keep(?heap).

HeapRepresentative("<<string-builder>>", ?heap) :-
  HeapAllocation_Type(?heap, "java.lang.StringBuilder"),
  !HeapAllocation_Keep(?heap).

HeapRepresentative("<<pystring-object>>", ?heap) :-
  HeapAllocation_Type(?heap, "org.python.core.PyString"),
  !HeapAllocation_Keep(?heap).
.decl ExceptionTypeToHeap(?heap:HeapAllocation, ?type:Type)

ExceptionTypeToHeap(?heap, ?heaptype) :-
  AssignHeapAllocation(?heap, _, _),
  HeapAllocation_Type(?heap, ?heaptype),
  ExceptionType(?heaptype).

.decl ExceptionHeapTypeRepresentativeOrdinal(?type:Type, ?reprHeapOrd:number)

ExceptionHeapTypeRepresentativeOrdinal(?type, ?representativeHeapOrd) :-
  ExceptionTypeToHeap(_, ?type),
  ?representativeHeapOrd = min ord(?heap) : ExceptionTypeToHeap(?heap, ?type).


HeapRepresentative(?representativeHeap, ?heap) :-
  ExceptionHeapTypeRepresentativeOrdinal(?heaptype, ?representativeHeapOrd),
  ExceptionTypeToHeap(?heap, ?heaptype),
  ord(?representativeHeap) = ?representativeHeapOrd,
  isHeapAllocation(?representativeHeap).
HeapAllocation_ContextInsensitive(?heap) :-
  HeapAllocation_Type(?heap, ?type),
  isArrayType(?type),
  ComponentType(?type, ?componentType),
  isPrimitiveType(?componentType).
ReflectionStringConstant("int").
ReflectionStringConstant("float").
ReflectionStringConstant("double").
ReflectionStringConstant("byte").
ReflectionStringConstant("boolean").
ReflectionStringConstant("char").
ReflectionStringConstant("long").
ReflectionStringConstant("short").
ReflectionStringConstant("void").
.decl _StringIterationTrick(?pos:number)
_StringIterationTrick(0).
_StringIterationTrick(?pos + 1) :- _StringIterationTrick(?pos), ?pos < 256.

.decl RelevantSuffixPosition(?typeName: Type, ?pos:number)
RelevantSuffixPosition(?typeName, ?pos) :-
  isType(?typeName),
  _StringIterationTrick(?pos), ?pos < strlen(?typeName).

.decl Suffix(?type:Type, ?suffix:symbol, ?suffixLen:number)

Suffix(?type, ?suffix, ?suffixLen) :-
  RelevantSuffixPosition(?type, ?pos),
  substr(?type, ?pos, 1) = ".",
  ?suffixLen = strlen(?type) - ?pos - 1,
  ?suffix = substr(?type, ?pos + 1, ?suffixLen).

Suffix(?type, ?type, ?suffixLen) :-
  isType(?type),
  ?suffixLen = strlen(?type).

.decl MinimalSuffixLen(?type:Type, ?suffixLen:number)

MinimalSuffixLen(?type, ?suffixLen) :-
  isType(?type),
  ?suffixLen = min ?len : Suffix(?type, _, ?len).


.decl MinimalSuffix(?type:Type, ?suffix:symbol)

MinimalSuffix(?type, ?suffix) :-
  MinimalSuffixLen(?type, ?suffixLen),
  Suffix(?type, ?suffix, ?suffixLen).
RunningThread(?hctx, ?value) :-
    MainThread(?hctx, ?value).
ReachableContext(?calleeCtx, ?run),
VarPointsTo(?hctx, ?value, ?calleeCtx, ?runThis),
RunningThread(?hctx, ?value)
:-



    ?start = "<java.lang.Thread: void start0()>",

    ThisVar(?start, ?startThis),
    CallGraphEdge(_, _, ?calleeCtx, ?start),
    VarPointsTo(?hctx, ?value, ?calleeCtx, ?startThis),
    Value_Type(?value, ?valuetype),
    basic.MethodLookup("run", "void()", ?valuetype, ?run),
    ThisVar(?run, ?runThis).
VarPointsTo(?hctx, ?value, ?callerCtx, ?local) :-
   ReachableCurrentThreadInvocation(?callerCtx, ?local),
   RunningThread(?hctx, ?value).


ReachableCurrentThreadInvocation(?callerCtx, ?local) :-
   ?signature = "<java.lang.Thread: java.lang.Thread currentThread()>",
   StaticMethodInvocation(?invocation, ?signature, ?inmethod),
   ReachableContext(?callerCtx, ?inmethod),
   AssignReturnValue(?invocation, ?local).
configuration.ContextRequest(?callerCtx, ?hctx, ?invo, ?value, ?signature, 1) :-
    SystemThreadGroup(?hctx, ?value),
    isImmutableContext(?callerCtx),
    FakeInvocation_ThreadGroupInit(?invo),
    ?signature = "<java.lang.ThreadGroup: void <init>()>".



VarPointsTo(?hctx, ?value, ?calleeCtx, ?this),

isContext(?calleeCtx),
ReachableContext(?calleeCtx, ?signature) :-
    ?signature = "<java.lang.ThreadGroup: void <init>()>",
    ThisVar(?signature, ?this),
    SystemThreadGroup(?hctx, ?value),
    configuration.ContextRequest(?callerCtx, ?hctx, ?invo, ?value, ?signature, 1),
    configuration.ContextResponse(?callerCtx, ?hctx, ?invo, ?value, ?signature, ?calleeCtx).
configuration.ContextRequest(?callerCtx, ?hctx, ?invo, ?value, ?signature, 1) :-
    MainThreadGroup(?hctx, ?value),
    isImmutableContext(?callerCtx),
    FakeInvocation_ThreadGroupInit(?invo),
    ?signature = "<java.lang.ThreadGroup: void <init>(java.lang.ThreadGroup,java.lang.String)>".


VarPointsTo(?hctx, ?value, ?calleeCtx, ?this),
VarPointsTo(?groupHCtx, ?group, ?calleeCtx, ?groupParam),

isContext(?calleeCtx),
ReachableContext(?calleeCtx, ?signature) :-
    ?signature = "<java.lang.ThreadGroup: void <init>(java.lang.ThreadGroup,java.lang.String)>",
    ThisVar(?signature, ?this),
    MainThreadGroup(?hctx, ?value),
    FormalParam(0, ?signature, ?groupParam),
    SystemThreadGroup(?groupHCtx, ?group),
    configuration.ContextRequest(?callerCtx, ?hctx, ?invo, ?value, ?signature, 1),
    configuration.ContextResponse(?callerCtx, ?hctx, ?invo, ?value, ?signature, ?calleeCtx).
configuration.ContextRequest(?callerCtx, ?hctx, ?invo, ?value, ?signature, 1) :-
    MainThread(?hctx, ?value),
    isImmutableContext(?callerCtx),
    FakeInvocation_MainThreadInit(?invo),
    ?signature = "<java.lang.Thread: void <init>(java.lang.ThreadGroup,java.lang.String)>".


VarPointsTo(?hctx, ?value, ?calleeCtx, ?this),
VarPointsTo(?groupHCtx, ?group, ?calleeCtx, ?groupParam),

isContext(?calleeCtx),
ReachableContext(?calleeCtx, ?signature) :-
    ?signature = "<java.lang.Thread: void <init>(java.lang.ThreadGroup,java.lang.String)>",
    ThisVar(?signature, ?this),
    MainThread(?hctx, ?value),
    FormalParam(0, ?signature, ?groupParam),
    MainThreadGroup(?groupHCtx, ?group),
    configuration.ContextRequest(?callerCtx, ?hctx, ?invo, ?value, ?signature, 1),
    configuration.ContextResponse(?callerCtx, ?hctx, ?invo, ?value, ?signature, ?calleeCtx).



FakeInvocation_ThreadGroupInit(?invo),
isInstruction(?invo), isMethodInvocation(?invo)  :-
  ?invo = "<thread-group-init>/0".

FakeInvocation_MainThreadInit(?invo),
isInstruction(?invo), isMethodInvocation(?invo)  :-
  ?invo = "<main-thread-init>/0".

FakeInvocation_SystemThreadGroupInit(?invo),
isInstruction(?invo), isMethodInvocation(?invo)  :-
  ?invo = "<system-thread-group-init>/0".
FakeInvocation_RegisterFinalize(?heapValue, ?invo) :-
  FakeInvocation_RegisterFinalize0(?heapValue, ?invo).

Value_isHeap(?heapValue),
isValue(?heapValue),
Value_Type(?heapValue, ?type) :-
  isHeapAllocation(?heapValue),
  HeapAllocation_Type(?heapValue, ?type).
Value_isNonHeap(?value) :-
  Value_isMock(?value) ;
  Value_Num(?value, _, _).

Value_Null(?nullheap) :-
  HeapAllocation_Null(?nullheap).


Value_DeclaringType(?heapValue, ?type) :-
  AssignHeapAllocation(?heapValue, _, ?inmethod),
  Method_DeclaringType(?inmethod, ?type),
  isNormalHeap(?heapValue).

Value_DeclaringType(?heapValue, "java.lang.System") :-
  isClassHeap(?heapValue).

Value_DeclaringType(?heapValue, "java.lang.String") :-
  isStringConstant(?heapValue).

Value_DeclaringType(?value, "java.lang.Object") :-
  Value_Null(?value);
  MainMethodArgArray(?value);
  MainMethodArgArrayContent(?value).

Value_DeclaringType(?heapValue, "java.lang.invoke.MethodHandle") :-
  isMethodHandleConstant(?heapValue).

Value_DeclaringType(?heapValue, "java.lang.invoke.MethodType") :-
  isMethodTypeConstant(?heapValue).

Value_DeclaringType(?heapValue, ?type) :-
  SimulatedNativeAllocation(?heapValue, ?method),
  Method_DeclaringType(?method, ?type).


NotSpecialObject(?value) :-
  Value_isHeap(?value) ;
  Value_isMock(?value) ;
  Value_Num(?value, _, _).

configuration.InitContextRequest("<<immutable-context>>").




isImmutableContext(?ctx),
isContext(?ctx) :-
  ?s = "<<immutable-context>>",
  configuration.InitContextRequest(?s),
  configuration.InitContextResponse(?s, ?ctx).
ApplicationEntryPoint(?method),
ReachableContext(?initialContext, ?method) :-
  isImmutableContext(?initialContext),
  basic.MainMethodDeclaration(?method).


ReachableContext(?ctx, ?method) :-
  isImmutableContext(?ctx),
  ImplicitReachable(?method).



ReachableContext(?clinitContext, ?clinit) :-
  isImmutableContext(?clinitContext),
  InitializedClass(?class),
  ClassInitializer(?class, ?clinit).

configuration.InitHContextRequest("<<immutable-hcontext>>").


isImmutableHContext(?hctx),
isHContext(?hctx) :-
  ?s = "<<immutable-hcontext>>",
  configuration.InitHContextRequest(?s),
  configuration.InitHContextResponse(?s, ?hctx).
SystemThreadGroup(?hctx, ?alloc) :-
  isImmutableHContext(?hctx),
  ?alloc = "<<system-thread-group>>",
  isValue(?alloc).

MainThreadGroup(?hctx, ?alloc) :-
  isImmutableHContext(?hctx),
  ?alloc = "<<main-thread-group>>",
  isValue(?alloc).

MainThread(?hctx, ?alloc) :-
  isImmutableHContext(?hctx),
  ?alloc = "<<main-thread>>",
  isValue(?alloc).
.decl ReachableValue(?hctx:configuration.HContext, ?value: Value)

ReachableValue(?hctx, ?heapValue) :-
  AssignContextInsensitiveHeapAllocation(?heapValue, _, ?inmethod),
  ReachableContext(_, ?inmethod),
  isImmutableHContext(?hctx).

isHContext(?newHCtx),
ReachableValue(?newHCtx, ?heapValue) :-
  configuration.RecordContextRequest(?ctx, ?heapValue, ?var),
  configuration.RecordContextResponse(?ctx, ?heapValue, ?var, ?newHCtx).







ReachableValue(?hctx, ?value) :-
  VarPointsTo(?hctx, ?value, _, _).

.decl TypeHasReachableValue(?valueType: Type)
TypeHasReachableValue(?valueType) :-
  ReachableValue(_, ?value),
  Value_Type(?value, ?valueType).
configuration.RecordContextRequest(?ctx, ?heapValue, ?var) :-
  AssignNormalHeapAllocation(?heapValue, ?var, ?inmethod),
  ReachableContext(?ctx, ?inmethod).



VarPointsTo(?newHCtx, ?heapValue, ?ctx, ?var) :-
  configuration.RecordContextRequest(?ctx, ?heapValue, ?var),
  configuration.RecordContextResponse(?ctx, ?heapValue, ?var, ?newHCtx).

VarPointsTo(?hctx, ?heapValue, ?ctx, ?var) :-
  Reachable(?inmethod),
  AssignContextInsensitiveHeapAllocation(?heapValue, ?var, ?inmethod),
  ReachableContext(?ctx, ?inmethod),
  isImmutableHContext(?hctx).
  .plan 1:(4,3,2,1)
VarPointsTo(?hctx, ?null, ?toCtx, ?to) :-
   Reachable(?inmethod),
   AssignNull(?to, ?inmethod),
   Value_Null(?null),
   ReachableContext(?toCtx, ?inmethod),
   isImmutableHContext(?hctx).
VarPointsTo(?hctx, ?value, ?ctx, ?to) :-
  VarPointsTo(?hctx, ?value, ?ctx, ?from),
  AssignLocal(?from, ?to, _).
VarPointsTo(?hctx, ?value, ?ctx, ?to) :-
  OptAssignCast(?type, ?to, ?from),
  VarPointsTo(?hctx, ?value, ?ctx, ?from),
  Value_Type(?value, ?valuetype),
  basic.SupertypeOf(?type, ?valuetype).
 .plan 2:(3,2,1,4)

.decl OptAssignCast(?type:Type, ?to:Var, ?from:Var)
OptAssignCast(?type, ?to, ?from) :-
  Reachable(?inmethod),
  AssignCast(?type, ?from, ?to, ?inmethod).
LoadHeapInstanceField(?ctx, ?to, ?sig, ?basehctx, ?basevalue) :-
  LoadInstanceField(?base, ?sig, ?to, _),
  VarPointsTo(?basehctx, ?basevalue, ?ctx, ?base).

StoreHeapInstanceField(?signature, ?basehctx, ?basevalue, ?ctx, ?from) :-
  StoreInstanceField(?from, ?base, ?signature, _),
  VarPointsTo(?basehctx, ?basevalue, ?ctx, ?base).








HeapInterproceduralAssign(?ctxTo, ?to, ?ctxFrom, ?from) :-
  LoadHeapInstanceField(?ctxTo, ?to, ?signature, ?basehctx, ?basevalue),
  StoreHeapInstanceField(?signature, ?basehctx, ?basevalue, ?ctxFrom, ?from),
  !Value_Null(?basevalue).
 .plan 1:(2,1)

VarPointsTo(?hctx, ?value, ?toCtx, ?to) :-
  HeapInterproceduralAssign(?toCtx, ?to, ?fromCtx, ?from),
  VarPointsTo(?hctx, ?value, ?fromCtx, ?from),
  NotSpecialObject(?value).
 .plan 1:(2,1,3), 2:(3,2,1)

VarPointsTo(?hctx, ?value, ?ctx, ?to) :-
  LoadHeapInstanceField(?ctx, ?to, ?signature, ?basehctx, ?basevalue),
  InstanceFieldPointsTo(?hctx, ?value, ?signature, ?basehctx, ?basevalue).

InstanceFieldPointsTo(?hctx, ?value, ?signature, ?basehctx, ?basevalue) :-
  StoreHeapInstanceField(?signature, ?basehctx, ?basevalue, ?ctx, ?from),
  VarPointsTo(?hctx, ?value, ?ctx, ?from),
  NotSpecialObject(?value),
  !Value_Null(?basevalue).
 .plan 1:(2,1,3), 2:(3,2,1)
VarPointsTo(?hctx, ?value, ?ctx, ?to) :-
  StaticFieldPointsTo(?hctx, ?value, ?sig),
  LoadStaticField(?sig, ?to, ?inmethod),
  ReachableContext(?ctx, ?inmethod).

  .plan 1:(3,2,1)
StaticFieldPointsTo(?hctx, ?value, ?signature) :-
  ReachableStoreStaticFieldFrom(?from),
  StoreStaticField(?from, ?signature, _),
  VarPointsTo(?hctx, ?value, _, ?from).
.decl ReachableStoreStaticFieldFrom(?from:Var)

ReachableStoreStaticFieldFrom(?from) :-
  Reachable(?inmethod),
  StoreStaticField(?from, _, ?inmethod).
.decl OptLoadHeapArrayIndex(?var:Var, ?value:Value)
.decl Temp1(?value:Value, ?var:Var)
.decl Temp2(?ctx:configuration.Context, ?var:Var, ?hctx:configuration.HContext, ?value:Value)

OptLoadHeapArrayIndex(?to, ?basevalue) :-
  LoadHeapArrayIndex(_, ?to, _, ?basevalue).

Temp1(?basevalue, ?to) :-
  NotEmptyArrayValue(?basevalue),
  OptLoadHeapArrayIndex(?to, ?basevalue),
  Value_Type(?basevalue, ?basevaluetype),
  ComponentType(?basevaluetype, ?basecomponenttype),
  Var_Type(?to, ?type),
  basic.SupertypeOf(?type, ?basecomponenttype).

Temp2(?ctx, ?to, ?basehctx, ?basevalue) :-
  Temp1(?basevalue, ?to),
  LoadHeapArrayIndex(?ctx, ?to, ?basehctx, ?basevalue).

VarPointsTo(?hctx, ?value, ?ctx, ?to) :-
  Temp2(?ctx, ?to, ?basehctx, ?basevalue),
  ArrayIndexPointsTo(?hctx, ?value, ?basehctx, ?basevalue).
.decl NotEmptyArrayValue(?value:Value)

NotEmptyArrayValue(?heapValue) :-
  Value_isHeap(?heapValue),
  isHeapAllocation(?heapValue),
  !HeapAllocation_EmptyArray(?heapValue).
NotEmptyArrayValue(?value) :-
  Value_isNonHeap(?value).

LoadHeapArrayIndex(?ctx, ?to, ?basehctx, ?basevalue) :-
  ReachableLoadArrayIndexBase(?base),
  OptLoadArrayIndex(?to, ?base),
  VarPointsTo(?basehctx, ?basevalue, ?ctx, ?base).

OptLoadArrayIndex(?to, ?base) :-
  LoadArrayIndex(?base, ?to, _).

.decl ReachableLoadArrayIndexBase(?base:Var)

ReachableLoadArrayIndexBase(?base) :-
  Reachable(?inmethod),
  LoadArrayIndex(?base, _, ?inmethod).
.decl OptStoreIntoArray(?hctx:configuration.HContext, ?value:Value, ?basehctx:configuration.HContext, ?basevalue:Value)


OptStoreIntoArray(?hctx, ?value, ?basehctx, ?basevalue) :-
  StoreHeapArrayIndex(?basehctx, ?basevalue, ?ctx, ?from),
  VarPointsTo(?hctx, ?value, ?ctx, ?from).
ArrayIndexPointsTo(?hctx, ?value, ?basehctx, ?basevalue) :-
  OptStoreIntoArray(?hctx, ?value, ?basehctx, ?basevalue),
  NotSpecialObject(?value),
  NotEmptyArrayValue(?basevalue),
  Value_Type(?value, ?valuetype),
  Value_Type(?basevalue, ?basevaluetype),
  ComponentType(?basevaluetype, ?componenttype),
  basic.SupertypeOf(?componenttype, ?valuetype).
 .plan 1:(2,1,3,4,5,6,7),
       2:(3,1,2,4,5,6,7),
       3:(4,1,2,3,5,6,7),
       4:(5,1,2,3,4,6,7)

StoreHeapArrayIndex(?basehctx, ?basevalue, ?ctx, ?from) :-
  ReachableStoreArrayIndexBase(?base),
  OptStoreArrayIndex(?from, ?base),
  VarPointsTo(?basehctx, ?basevalue, ?ctx, ?base).

.decl ReachableStoreArrayIndexBase(?base:Var)

ReachableStoreArrayIndexBase(?base) :-
  Reachable(?inmethod),
  StoreArrayIndex(_, ?base, ?inmethod).

OptStoreArrayIndex(?from, ?base) :-
  StoreArrayIndex(?from, ?base, _).
OptArgAssign(?calleeCtx, ?formal, ?callerCtx, ?actual, ?allowedType) :-
  CallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?method),
  ActualParam(?index, ?invocation, ?actual),
  FormalParam(?index, ?method, ?formal),
  Var_Type(?formal, ?allowedType).
OptReturnAssign(?callerCtx, ?local, ?calleeCtx, ?return) :-
  CallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?method),
  AssignReturnValue(?invocation, ?local),
  ReturnVar(?return, ?method).

VarPointsTo(?hctx, ?value, ?toCtx, ?to) :-
  OptRetVarPointsTo(?hctx, ?value, ?fromCtx, ?from),
  OptReturnAssign(?toCtx, ?to, ?fromCtx, ?from).
  .plan 1:(2,1)



OptArgVarPointsTo(?hctx, ?value, ?actualCtx, ?actual) :-
  VarPointsTo(?hctx, ?value, ?actualCtx, ?actual),
  ActualParam(_, _, ?actual).

OptRetVarPointsTo(?hctx, ?value, ?returnCtx, ?return) :-
  VarPointsTo(?hctx, ?value, ?returnCtx, ?return),
  ReturnVar(?return, _).
VarPointsTo(?hctx, ?value, ?toCtx, ?to) :-
  OptArgVarPointsTo(?hctx, ?value, ?fromCtx, ?from),
  OptArgAssign(?toCtx, ?to, ?fromCtx, ?from, ?allowedType),
  Value_Type(?value, ?type),
  basic.SubtypeOf(?type, ?allowedType).
  .plan 1:(2,1,3,4)
VarPointsTo(?hctx, ?value, ?toCtx, ?to) :-
  OptInterproceduralAssign(?toCtx, ?to, ?fromCtx, ?from),
  VarPointsTo(?hctx, ?value, ?fromCtx, ?from).
.decl OptVirtualMethodInvocationBase(?invocation:MethodInvocation, ?base:Var)

OptVirtualMethodInvocationBase(?invocation, ?base) :-
  Reachable(?inmethod),
  Instruction_Method(?invocation, ?inmethod),
  VirtualMethodInvocation_Base(?invocation, ?base).









configuration.ContextRequest(?callerCtx, ?hctx, ?invocation, ?value, ?tomethod, 1) :-
  OptVirtualMethodInvocationBase(?invocation, ?base),
  VarPointsTo(?hctx, ?value, ?callerCtx, ?base),
  Value_Type(?value, ?valuetype),
  basic.ResolveInvocation(?valuetype, ?invocation, ?tomethod).
VarPointsTo(?hctx, ?value, ?calleeCtx, ?this) :-
  configuration.ContextRequest(?callerCtx, ?hctx, ?invocation, ?value, ?tomethod, _),
  configuration.ContextResponse(?callerCtx, ?hctx, ?invocation, ?value, ?tomethod, ?calleeCtx),
  ThisVar(?tomethod, ?this),
  !Value_Null(?value).

 .plan 1:(2,1,3)
.decl OptSuperMethodInvocationBase(?invocation:MethodInvocation, ?base:Var)

OptSuperMethodInvocationBase(?invocation, ?base) :-
  Reachable(?inmethod),
  Instruction_Method(?invocation, ?inmethod),
  SuperMethodInvocation_Base(?invocation, ?base).

configuration.ContextRequest(?callerCtx, ?hctx, ?invocation, ?value, ?tomethod, 1) :-
  OptSuperMethodInvocationBase(?invocation, ?base),
  VarPointsTo(?hctx, ?value, ?callerCtx, ?base),
  MethodInvocation_Method(?invocation, ?tomethod).
.decl OptSpecialMethodInvocationBase(?invocation:MethodInvocation, ?base:Var)

OptSpecialMethodInvocationBase(?invocation, ?base) :-
  Reachable(?inmethod),
  Instruction_Method(?invocation, ?inmethod),
  SpecialMethodInvocation_Base(?invocation, ?base).

configuration.ContextRequest(?callerCtx, ?hctx, ?invocation, ?value, ?tomethod, 1) :-
  OptSpecialMethodInvocationBase(?invocation, ?base),
  VarPointsTo(?hctx, ?value, ?callerCtx, ?base),
  MethodInvocation_Method(?invocation, ?tomethod).
ReachableContext(?ctx, ?method) :-
  CallGraphEdge(_, _, ?ctx, ?method).

Reachable(?method) :-
  ReachableContext(_, ?method).

ReachableClass(?class) :-
  mainAnalysis.Reachable(?method),
  Method_DeclaringType(?method, ?class).

.decl AppReachable(?method:Method)

AppReachable(?method) :-
  Reachable(?method),
  ApplicationMethod(?method).
.decl ReachableAnnotationMethod(?method:Method, ?annotation:Annotation)

ReachableAnnotationMethod(?annotMethod, ?annotation) :-
  ReachableContext(_, ?method),
  Method_Annotation(?method, ?annotation),
  Method_DeclaringType(?annotMethod, ?annotation).

ReachableContext(?ctx0, ?annotMethod) :-
  ReachableAnnotationMethod(?annotMethod, _),
  isImmutableContext(?ctx0).
Value_isMock(?value), isValue(?value), Value_Type(?value, ?type), Value_DeclaringType(?value, "java.lang.Object") ,
VarPointsTo(?hctx, ?value, ?ctx, ?return) :-
  Instruction_Method(?invocation, ?inmethod),
  ReachableContext(?ctx, ?inmethod),
  MethodInvocation_Method(?invocation, ?method),
  MockedMethodReturns(?method, ?value, ?type),
  AssignReturnValue(?invocation, ?return),
  isImmutableHContext(?hctx).


.decl AnyCallGraphEdge(?instr:Instruction, ?method:Method)

AnyCallGraphEdge(?i, ?m) :- CallGraphEdge(_, ?i, _, ?m).
AnyCallGraphEdge(?i, ?m) :- InvokedynamicBootCallGraphEdge(_, ?i, _, ?m).
AnyCallGraphEdge(?i, ?m) :- LambdaCallGraphEdge(_, ?i, _, ?m, _).
AnyCallGraphEdge(?i, ?m) :- MethodHandleCallGraphEdge(_, ?i, _, ?m, _, _).
AnyCallGraphEdge(?i, ?m) :- OpaqueCallGraphEdge(?i, ?m).
.output Stats_Metrics(IO="file",filename="Stats_Metrics.csv",delimiter="\t")







.output CallGraphEdge(IO="file",filename="CallGraphEdge.csv",delimiter="\t")
.output AnyCallGraphEdge(IO="file",filename="AnyCallGraphEdge.csv",delimiter="\t")

.output VarPointsTo(IO="file",filename="VarPointsTo.csv",delimiter="\t")
.output ReachableContext(IO="file",filename="ReachableContext.csv",delimiter="\t")
.output InstanceFieldPointsTo(IO="file",filename="InstanceFieldPointsTo.csv",delimiter="\t")
.output StaticFieldPointsTo(IO="file",filename="StaticFieldPointsTo.csv",delimiter="\t")
.output Reachable(IO="file",filename="Reachable.csv",delimiter="\t")






.decl PhantomInvoke(?instruction:Instruction)

PhantomInvoke(?instruction),
isUnsupportedInstruction(?instruction) :-
  MethodInvocation_Method(?instruction, ?method),
  Method_DeclaringType(?method, ?pt),
  PhantomType(?pt).

PhantomInvoke(?instruction),
isUnsupportedInstruction(?instruction) :-
  MethodInvocation_Method(?instruction, ?method),
  PhantomMethod(?method).

.decl DeadInstruction(?i:Instruction)



DeadInstruction(?instruction) :-
  AssignHeapAllocation_Heap(?instruction, ?heap),
  HeapAllocation_Type(?heap, ?pt),
  PhantomType(?pt).

DeadInstruction(?instruction) :-
  (AssignCast_Type(?instruction, ?pt);
   AssignInstanceOf_Type(?instruction, ?pt)),
  PhantomType(?pt).

DeadInstruction(?instruction) :-
  PhantomInvoke(?instruction).



DeadInstruction(?instruction) :-
  MethodInvocation_Method(?instruction, ?method),
  DeadMethod(?method).

.decl DeadMethod(?m:Method)



DeadMethod(?m) :- Instruction_Method(?i, ?m), DeadInstruction(?i).
DeadMethod(?m) :- PhantomBasedMethod(?m).

.decl DeadType(?type:Type)




DeadType(?type) :-
  Field_DeclaringType(?sig, ?type),
  Field_Type(?sig, ?pt),
  PhantomType(?pt).

DeadType(?type) :-
  PhantomBasedMethod(?m),
  Method_DeclaringType(?m, ?type).

DeadType(?type) :-
  DeadMethod(?m),
  Method_DeclaringType(?m, ?type).





.decl RemovedMethod(?method:Method)

RemovedMethod(?method) :-
  PhantomMethod(?method),
  Method_DeclaringType(?method, ?type),
  !PhantomType(?type).

  .init configuration = Configuration
}
.comp BasicContextSensitivity<Configuration> : AbstractContextSensitivity<Configuration> {

configuration.StaticContextRequest(?callerCtx, ?invocation) :-
  ReachableContext(?callerCtx, ?inmethod),
  StaticMethodInvocation(?invocation, _, ?inmethod).
isContext(?calleeCtx),
CallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?tomethod) :-
  configuration.ContextRequest(?callerCtx, ?hctx, ?invocation, ?value, ?tomethod, 1),
  configuration.ContextResponse(?callerCtx, ?hctx, ?invocation, ?value, ?tomethod, ?calleeCtx).

 .plan 1:(2,1)


isContext(?calleeCtx),
CallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?tomethod) :-
  configuration.StaticContextResponse(?callerCtx, ?invocation, ?calleeCtx),
  MethodInvocation_Method(?invocation, ?tomethod).


}

.init mainAnalysis = BasicContextSensitivity< ContextInsensitiveConfiguration >
.comp AbstractConfiguration {

  .decl ContextRequest(?ctx:configuration.Context, ?hctx:configuration.HContext, ?invo:MethodInvocation, ?value:Value, ?method:Method, ?createCGE:number)
  .decl StaticContextRequest(?ctx:configuration.Context, ?invo:MethodInvocation)

  .decl ContextResponse(?callerCtx:configuration.Context, ?hctx:configuration.HContext, ?invo:MethodInvocation, ?value:Value, ?method:Method, ?calleeCtx:Context)
  .decl StaticContextResponse(?callerCtx:configuration.Context, ?invo:MethodInvocation, ?calleeCtx:Context)

  .decl RecordContextRequest(?callerCtx:configuration.Context, ?value:Value, ?var:Var)
  .decl RecordContextResponse(?callerCtx:configuration.Context, ?value:Value, ?var:Var, ?hctx:configuration.HContext)

  .decl InitContextRequest(?symbol:symbol)
  .decl InitContextResponse(?symbol:symbol, ?context:Context)

  .decl InitHContextRequest(?symbol:symbol)
  .decl InitHContextResponse(?symbol:symbol, ?hcontext:HContext)
}






.comp ContextInsensitiveConfiguration : AbstractConfiguration {

  .type Context = symbol
  .type HContext = symbol

  ContextResponse(?callerCtx, ?hctx, ?invo, ?value, ?tomethod, ?calleeCtx) :-
    ContextRequest(?callerCtx, ?hctx, ?invo, ?value, ?tomethod, _),
    ?calleeCtx = ?callerCtx.

  StaticContextResponse(?callerCtx, ?invo, ?calleeCtx) :-
    StaticContextRequest(?callerCtx, ?invo),
    ?calleeCtx = ?callerCtx.
  RecordContextResponse(?ctx, ?value, ?var, ?hctx) :-
    RecordContextRequest(?ctx, ?value, ?var),
    isImmutableHContext(?hctx).

  InitContextResponse(?s, ?ctx) :-
    ?ctx = "<<immutable-context>>",
    InitContextRequest(?s).

  InitHContextResponse(?s, ?hctx) :-
    ?hctx = "<<immutable-hcontext>>",
    InitHContextRequest(?s).
}
.decl Stats_Simple_JavaUtilInsensVarPointsTo(?value:Value, ?var:Var)
.output Stats_Simple_JavaUtilInsensVarPointsTo

.decl Stats_Simple_JavaUtilVarPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?ctx:mainAnalysis.configuration.Context, ?var:Var)
.output Stats_Simple_JavaUtilVarPointsTo

.decl Stats_Simple_InsensVarPointsTo(?value:Value, ?var:Var)
.output Stats_Simple_InsensVarPointsTo

.decl Stats_Simple_AssignedVariable(?var:Var)


.decl Stats_Simple_Application_InsensVarPointsTo(?value:Value, ?var:Var)


.decl Stats_Simple_Application_VarPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?ctx:mainAnalysis.configuration.Context, ?var:Var)


.decl Stats_Simple_InsensReachableVar(?var:Var)


.decl Stats_Simple_ReachableVar(?ctx:mainAnalysis.configuration.Context, ?var:Var)

.decl Stats_Simple_InsensArrayIndexPointsTo(?value:Value, ?basevalue:Value)


.decl Stats_Simple_Application_InsensArrayIndexPointsTo(?value:Value, ?basevalue:Value)


.decl Stats_Simple_Application_ArrayIndexPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value)

.decl Stats_Simple_InsensInstanceFieldPointsTo(?value:Value, ?sig:Field, ?basevalue:Value)


.decl Stats_Simple_InsensStaticFieldPointsTo(?value:Value, ?sig:Field)


.decl Stats_Simple_Application_InsensInstanceFieldPointsTo(?value:Value, ?sig:Field, ?basevalue:Value)


.decl Stats_Simple_Application_InstanceFieldPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?sig:Field, ?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value)

.decl Stats_Simple_InsensCallGraphEdge(?from:MethodInvocation, ?to:Method)
.output Stats_Simple_InsensCallGraphEdge

.decl Stats_Simple_VirtualCallGraphEdge(?from:MethodInvocation, ?to:Method)

.decl Stats_Simple_InsensReachableApplicationMethod(?method:Method)


.decl Stats_Simple_ReachableApplicationMethod(?ctx:mainAnalysis.configuration.Context, ?method:Method)


.decl Stats_Simple_ApplicationConcreteMethod(?method:Method)


.decl Stats_Simple_NonReachableApplicationConcreteMethod(?method:Method)
.output Stats_Simple_NonReachableApplicationConcreteMethod
.decl Stats_Simple_ReachableVirtualMethodInvocation(?invocation:MethodInvocation)


.decl Stats_Simple_Application_ReachableVirtualMethodInvocation(?invocation:MethodInvocation)



.decl Stats_Simple_VirtualTargets(?invocation:MethodInvocation, ?c:number)

.decl Stats_Simple_PolymorphicCallSite(?invocation:MethodInvocation)


.decl Stats_Simple_NullVirtualMethodInvocation(?invocation:MethodInvocation)


.decl Stats_Simple_EmptyVirtualMethodInvocation(?invocation:MethodInvocation)


.decl Stats_Simple_Application_VirtualMethodInvocation(?invocation:MethodInvocation)


.decl Stats_Simple_Application_PolymorphicCallSite(?invocation:MethodInvocation)


.decl Stats_Simple_Application_NullVirtualMethodInvocation(?invocation:MethodInvocation)


.decl Stats_Simple_Application_EmptyReachableVirtualMethodInvocation(?invocation:MethodInvocation)

.decl Stats_Simple_ReachableCast(?inmethod:Method, ?type:Type, ?to:Var, ?from:Var)


.decl Stats_Simple_PotentiallyFailingCast(?type:Type, ?from:Var, ?to:Var)


.decl Stats_Simple_Application_Cast(?type:Type, ?from:Var, ?to:Var, ?inmethod:Method)


.decl Stats_Simple_Application_ReachableCast(?inmethod:Method, ?type:Type, ?to:Var, ?from:Var)


.decl Stats_Simple_Application_ReachableMethod(?method:Method)
.output Stats_Simple_Application_ReachableMethod

.decl Stats_Simple_Application_PotentiallyFailingCast(?type:Type, ?from:Var, ?to:Var)

Stats_Simple_JavaUtilInsensVarPointsTo(?value, ?var) :-
  Stats_Simple_JavaUtilVarPointsTo(_, ?value, _, ?var).

Stats_Simple_JavaUtilVarPointsTo(?hctx, ?value, ?ctx, ?var) :-
  Method_DeclaringType(?method, ?type),
  match("java[.]util[.].*", ?type),
  Var_DeclaringMethod(?var, ?method),
  mainAnalysis.VarPointsTo(?hctx, ?value, ?ctx, ?var).

Stats_Simple_InsensVarPointsTo(?value, ?var) :-
  mainAnalysis.VarPointsTo(_, ?value, _, ?var).

Stats_Simple_AssignedVariable(?var) :-
  Stats_Simple_InsensVarPointsTo(_, ?var).

Stats_Simple_Application_InsensVarPointsTo(?value, ?var),
Stats_Simple_Application_VarPointsTo(?hctx, ?value, ?ctx, ?var) :-
  ApplicationVar(?var),
  mainAnalysis.VarPointsTo(?hctx, ?value, ?ctx, ?var).

Stats_Simple_InsensReachableVar(?var),
Stats_Simple_ReachableVar(?ctx, ?var) :-
  Stats_Simple_AssignedVariable(?var),
  Var_DeclaringMethod(?var, ?method),
  mainAnalysis.ReachableContext(?ctx, ?method).
Stats_Simple_InsensArrayIndexPointsTo(?value, ?basevalue) :-
   mainAnalysis.ArrayIndexPointsTo(_, ?value, _, ?basevalue).

Stats_Simple_Application_InsensArrayIndexPointsTo(?value, ?basevalue),
Stats_Simple_Application_ArrayIndexPointsTo(?hctx, ?value, ?baseHCtx, ?basevalue) :-
  ApplicationMethod(?meth),
  mainAnalysis.AssignNormalHeapAllocation(?basevalue, _, ?meth),
  mainAnalysis.ArrayIndexPointsTo(?hctx, ?value, ?baseHCtx, ?basevalue).
Stats_Simple_InsensInstanceFieldPointsTo(?value, ?sig, ?basevalue) :-
  mainAnalysis.InstanceFieldPointsTo(_, ?value, ?sig, _, ?basevalue).

Stats_Simple_InsensStaticFieldPointsTo(?value, ?sig) :-
  mainAnalysis.StaticFieldPointsTo(_, ?value, ?sig).

Stats_Simple_Application_InsensInstanceFieldPointsTo(?value, ?sig, ?basevalue),
Stats_Simple_Application_InstanceFieldPointsTo(?hctx, ?value, ?sig, ?baseHCtx, ?basevalue) :-
  ApplicationMethod(?meth),
  mainAnalysis.AssignNormalHeapAllocation(?basevalue, _, ?meth),
  mainAnalysis.InstanceFieldPointsTo(?hctx, ?value, ?sig, ?baseHCtx, ?basevalue).
Stats_Simple_InsensCallGraphEdge(?from, ?to) :-
   mainAnalysis.CallGraphEdge(_, ?from, _, ?to).

Stats_Simple_VirtualCallGraphEdge(?from, ?to) :-
   Stats_Simple_ReachableVirtualMethodInvocation(?from),
   Stats_Simple_InsensCallGraphEdge(?from, ?to).
Stats_Simple_InsensReachableApplicationMethod(?method),
Stats_Simple_ReachableApplicationMethod(?ctx, ?method) :-
  ApplicationMethod(?method),
  mainAnalysis.ReachableContext(?ctx, ?method).

Stats_Simple_ApplicationConcreteMethod(?method) :-
  ApplicationMethod(?method),
  !Method_Modifier("abstract", ?method).

Stats_Simple_NonReachableApplicationConcreteMethod(?method) :-
  Stats_Simple_ApplicationConcreteMethod(?method),
  !Stats_Simple_InsensReachableApplicationMethod(?method).
Stats_Simple_ReachableVirtualMethodInvocation(?invocation) :-
  mainAnalysis.Reachable(?method),
  Instruction_Method(?invocation, ?method),
  isVirtualMethodInvocation_Insn(?invocation).

Stats_Simple_Application_ReachableVirtualMethodInvocation(?invocation) :-
  Stats_Simple_InsensReachableApplicationMethod(?method),
  Instruction_Method(?invocation, ?method),
  isVirtualMethodInvocation_Insn(?invocation).

Stats_Simple_VirtualTargets(?from, ?c) :-
  Stats_Simple_VirtualCallGraphEdge(?from, _),
  ?c = count : Stats_Simple_VirtualCallGraphEdge(?from, _).

Stats_Simple_PolymorphicCallSite(?from) :-
  Stats_Simple_VirtualTargets(?from, ?size),
  ?size > 1.







Stats_Simple_NullVirtualMethodInvocation(?invocation) :-
  mainAnalysis.Value_Null(?null),
  Stats_Simple_InsensVarPointsTo(?null, ?base),
  VirtualMethodInvocation_Base(?invocation, ?base),
  Stats_Simple_ReachableVirtualMethodInvocation(?invocation).

Stats_Simple_EmptyVirtualMethodInvocation(?invocation) :-
  Stats_Simple_ReachableVirtualMethodInvocation(?invocation),
  VirtualMethodInvocation_Base(?invocation, ?base),
  !Stats_Simple_InsensVarPointsTo(_, ?base).

Stats_Simple_Application_VirtualMethodInvocation(?invocation) :-
  ApplicationMethod(?method),
  Instruction_Method(?invocation, ?method),
  isVirtualMethodInvocation_Insn(?invocation).

Stats_Simple_Application_PolymorphicCallSite(?from) :-
  Stats_Simple_PolymorphicCallSite(?from),
  Stats_Simple_Application_ReachableVirtualMethodInvocation(?from).

Stats_Simple_Application_NullVirtualMethodInvocation(?invocation) :-
  mainAnalysis.Value_Null(?null),
  Stats_Simple_InsensVarPointsTo(?null, ?base),
  VirtualMethodInvocation_Base(?invocation, ?base),
  Stats_Simple_Application_ReachableVirtualMethodInvocation(?invocation).

Stats_Simple_Application_EmptyReachableVirtualMethodInvocation(?invocation) :-
  Stats_Simple_Application_ReachableVirtualMethodInvocation(?invocation),
  VirtualMethodInvocation_Base(?invocation, ?base),
  !Stats_Simple_InsensVarPointsTo(_, ?base).
Stats_Simple_ReachableCast(?inmethod, ?type, ?to, ?from) :-
  Stats_Simple_AssignedVariable(?from),
  AssignCast(?type, ?from, ?to, ?inmethod),
  mainAnalysis.Reachable(?inmethod).

Stats_Simple_PotentiallyFailingCast(?type, ?from, ?to) :-
  Stats_Simple_ReachableCast(_, ?type, ?to, ?from),
  Stats_Simple_InsensVarPointsTo(?value, ?from),
  mainAnalysis.Value_Type(?value, ?valuetype),
  !basic.SupertypeOf(?type, ?valuetype).

Stats_Simple_Application_Cast(?type, ?from, ?to, ?inmethod) :-
  ApplicationMethod(?inmethod),
  AssignCast(?type, ?from, ?to, ?inmethod).

Stats_Simple_Application_ReachableCast(?inmethod, ?type, ?to, ?from) :-
  ApplicationMethod(?inmethod),
  Stats_Simple_ReachableCast(?inmethod, ?type, ?to, ?from).

Stats_Simple_Application_ReachableMethod(?method) :-
  mainAnalysis.Reachable(?method),
  ApplicationMethod(?method).

Stats_Simple_Application_PotentiallyFailingCast(?type, ?from, ?to) :-
  Stats_Simple_Application_ReachableCast(_, ?type, ?to, ?from),
  Stats_Simple_InsensVarPointsTo(?value, ?from),
  mainAnalysis.Value_Type(?value, ?valuetype),
  !basic.SupertypeOf(?type, ?valuetype).



Stats_Metrics("1.0", "var points-to (INS)", c) :- c = count : { Stats_Simple_InsensVarPointsTo(_, _) } .
Stats_Metrics("1.5", "var points-to (SENS)", c) :- c = count : { mainAnalysis.VarPointsTo(_, _, _, _) } .
Stats_Metrics("5.0", "app var points-to (INS)", c) :- c = count : { Stats_Simple_Application_InsensVarPointsTo(_, _) } .
Stats_Metrics("5.5", "app var points-to (SENS)", c) :- c = count : { Stats_Simple_Application_VarPointsTo(_, _, _, _) } .
Stats_Metrics("5.7", "java.util var points-to (INS)", c) :- c = count : { Stats_Simple_JavaUtilInsensVarPointsTo(_, _) } .
Stats_Metrics("5.8", "java.util var points-to (SENS)", c) :- c = count : { Stats_Simple_JavaUtilVarPointsTo(_, _, _, _) } .
Stats_Metrics("10.0", "reachable variables (INS)", c) :- c = count : { Stats_Simple_InsensReachableVar(_) } .
Stats_Metrics("10.5", "reachable variables (SENS)", c) :- c = count : { Stats_Simple_ReachableVar(_, _) } .

Stats_Metrics("2.0", "array index points-to (INS)", c) :- c = count : { Stats_Simple_InsensArrayIndexPointsTo(_, _) } .
Stats_Metrics("2.5", "array index points-to (SENS)", c) :- c = count : { mainAnalysis.ArrayIndexPointsTo(_, _, _, _) } .
Stats_Metrics("6.0", "app array index points-to (INS)", c) :- c = count : { Stats_Simple_Application_InsensArrayIndexPointsTo(_, _) } .
Stats_Metrics("6.5", "app array index points-to (SENS)", c) :- c = count : { Stats_Simple_Application_ArrayIndexPointsTo(_, _, _, _) } .

Stats_Metrics("3.0", "instance field points-to (INS)", c) :- c = count : { Stats_Simple_InsensInstanceFieldPointsTo(_, _, _) } .
Stats_Metrics("3.5", "instance field points-to (SENS)", c) :- c = count : { mainAnalysis.InstanceFieldPointsTo(_, _, _, _, _) } .

Stats_Metrics("4.0", "static field points-to (INS)", c) :- c = count : { Stats_Simple_InsensStaticFieldPointsTo(_, _) } .
Stats_Metrics("4.5", "static field points-to (SENS)", c) :- c = count : { mainAnalysis.StaticFieldPointsTo(_, _, _) } .

Stats_Metrics("7.0", "app instance field points-to (INS)", c) :- c = count : { Stats_Simple_Application_InsensInstanceFieldPointsTo(_, _, _) } .
Stats_Metrics("7.5", "app instance field points-to (SENS)", c) :- c = count : { Stats_Simple_Application_InstanceFieldPointsTo(_, _, _, _, _) } .


Stats_Metrics("8.0", "call graph edges (INS)", c) :- c = count : { Stats_Simple_InsensCallGraphEdge(_, _) } .
Stats_Metrics("8.5", "call graph edges (SENS)", c) :- c = count : { mainAnalysis.CallGraphEdge(_, _, _, _) } .
Stats_Metrics("9.0", "non-reachable app concrete methods", c) :- c = count : { Stats_Simple_NonReachableApplicationConcreteMethod(_) } .
Stats_Metrics("11.0", "reachable methods (INS)", c) :- c = count : { mainAnalysis.Reachable(_) } .
Stats_Metrics("11.5", "reachable methods (SENS)", c) :- c = count : { mainAnalysis.ReachableContext(_, _) } .
Stats_Metrics("11.75", "total methods", c) :- c = count : { isMethod(_) } .


Stats_Metrics("12.0", "virtual call sites (statically)", c) :- c = count : { isVirtualMethodInvocation_Insn(_) } .
Stats_Metrics("13.0", "reachable virtual call sites", c) :- c = count : { Stats_Simple_ReachableVirtualMethodInvocation(_) } .
Stats_Metrics("14.0", "polymorphic virtual call sites", c) :- c = count : { Stats_Simple_PolymorphicCallSite(_) } .
Stats_Metrics("15.0", "null virtual call sites", c) :- c = count : { Stats_Simple_NullVirtualMethodInvocation(_) } .
Stats_Metrics("15.5", "empty virtual call sites", c) :- c = count : { Stats_Simple_EmptyVirtualMethodInvocation(_) } .
Stats_Metrics("16.0", "app virtual call sites (statically)", c) :- c = count : { Stats_Simple_Application_VirtualMethodInvocation(_) } .
Stats_Metrics("17.0", "app reachable virtual call sites", c) :- c = count : { Stats_Simple_Application_ReachableVirtualMethodInvocation(_) } .
Stats_Metrics("18.0", "app polymorphic virtual call sites", c) :- c = count : { Stats_Simple_Application_PolymorphicCallSite(_) } .
Stats_Metrics("19.0", "app null virtual call sites", c) :- c = count : { Stats_Simple_Application_NullVirtualMethodInvocation(_) } .
Stats_Metrics("19.5", "app empty reachable virtual call sites", c) :- c = count : { Stats_Simple_Application_EmptyReachableVirtualMethodInvocation(_) } .

Stats_Metrics("20.0", "casts (statically)", c) :- c = count : { AssignCast(_, _, _, _) } .
Stats_Metrics("21.0", "reachable casts", c) :- c = count : { Stats_Simple_ReachableCast(_, _, _, _) } .
Stats_Metrics("22.0", "reachable casts that may fail", c) :- c = count : { Stats_Simple_PotentiallyFailingCast(_, _, _) } .
Stats_Metrics("23.0", "app casts (statically)", c) :- c = count : { Stats_Simple_Application_Cast(_, _, _, _) } .
Stats_Metrics("24.0", "app reachable casts", c) :- c = count : { Stats_Simple_Application_ReachableCast(_, _, _, _) } .
Stats_Metrics("25.0", "app reachable casts that may fail", c) :- c = count : { Stats_Simple_Application_PotentiallyFailingCast(_, _, _) } .
Stats_Metrics("25.5", "app reachable methods", c) :- c = count : { Stats_Simple_Application_ReachableMethod(_) } .
Stats_Metrics("25.75", "app concrete methods", c) :- c = count : { Stats_Simple_ApplicationConcreteMethod(_) } .
Stats_Metrics("61.0", "mock objects", c) :- c = count : { MockObject(_, _) } .
Stats_Metrics("61.1", "mock objects for receivers", c) :- c = count : { MockObjFromOpenProgramEntryPointReceiver(_) } .
Stats_Metrics("61.2", "mock objects for arg", c) :- c = count : { MockObjFromOpenProgramEntryPointArg(_) } .
Stats_Metrics("61.6", "forced-reachable formals that could not be mocked", c) :- c = count : { UnmockableFormalOfForcedReachableContext(_, _) } .
.decl Stats_Simple_Application_InsensCallGraphEdge(?invocation:Instruction, ?toMeth:Method)


Stats_Simple_Application_InsensCallGraphEdge(?invocation, ?toMeth) :-
  Stats_Simple_InsensCallGraphEdge(?invocation, ?toMeth),
  ApplicationMethod(?toMeth),
  Instruction_Method(?invocation, ?fromMeth),
  ApplicationMethod(?fromMeth).
.decl Stats_ApplicationHeap(?heap:HeapAllocation)

.decl Stats_VarCount(?ctx:mainAnalysis.configuration.Context, ?var:Var, ?n:number)


.decl Stats_InsensValueVarPointsTo(?value:Value, ?ctx:mainAnalysis.configuration.Context, ?var:Var)



.decl Stats_InsensValueVarCount(?ctx:mainAnalysis.configuration.Context, ?var:Var, ?n:number)


.decl Stats_InsensBaseVarPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?var:Var)



.decl Stats_InsensBaseVarCount(?var:Var, ?n:number)



.decl Stats_InsensVarCount(?var:Var, ?n:number)



.decl Stats_Vars(?n:number)



.decl Stats_InsensVars(?n:number)

.decl Stats_ArrayCount(?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value, ?n:number)


.decl Stats_InsensValueArrayIndexPointsTo(?value:Value, ?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value)



.decl Stats_InsensValueArrayCount(?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value, ?n:number)


.decl Stats_InsensBaseValueArrayIndexPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?basevalue:Value)



.decl Stats_InsensBaseValueArrayCount(?basevalue:Value, ?n:number)



.decl Stats_InsensArrayCount(?basevalue:Value, ?n:number)



.decl Stats_Arrays(?n:number)



.decl Stats_InsensArrays(?n:number)

.decl Stats_FieldCount(?sig:Field, ?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value, ?n:number)


.decl Stats_InsensValueInstanceFieldPointsTo(?value:Value, ?sig:Field, ?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value)



.decl Stats_InsensValueFieldCount(?sig:Field, ?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value, ?n:number)


.decl Stats_InsensBaseValueInstanceFieldPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?sig:Field, ?basevalue:Value)



.decl Stats_InsensBaseValueFieldCount(?sig:Field, ?basevalue:Value, ?n:number)



.decl Stats_InsensFieldCount(?sig:Field, ?basevalue:Value, ?n:number)



.decl Stats_Fields(?n:number)



.decl Stats_InsensFields(?n:number)

.decl Stats_MethodContextCount(?method:Method, ?n:number)


.decl Stats_Methods(?n:number)


.decl Method_NumberOfContexts(?method:Method, ?n:number)


.decl Method_VPTCountPerMethodVariable(?method:Method, ?var:Var, ?n:number)


.decl Method_TotalVPT(?method:Method, Y:number)

.decl Stats_InsensValueThrowPointsTo(?value:Value, ?ctx:mainAnalysis.configuration.Context, ?method:Method)





.decl Stats_InsensThrowPointsTo(?value:Value, ?method:Method)

Stats_ApplicationHeap(?heap) :-
  ApplicationMethod(?method),
  mainAnalysis.AssignNormalHeapAllocation(?heap, _, ?method).

Stats_ApplicationHeap(?heap) :-
  ApplicationMethod(?method),
  mainAnalysis.AssignContextInsensitiveHeapAllocation(?heap, _, ?method).
Stats_VarCount(?ctx, ?var, ?n) :-
 mainAnalysis.VarPointsTo(_, _, ?ctx, ?var),
 ?n = count : mainAnalysis.VarPointsTo(_, _, ?ctx, ?var).


Stats_InsensValueVarPointsTo(?value, ?ctx, ?var) :-
  mainAnalysis.VarPointsTo(_, ?value, ?ctx, ?var).

Stats_InsensValueVarCount(?ctx, ?var, ?n) :-
  Stats_InsensValueVarPointsTo(_, ?ctx, ?var),
  ?n = count : Stats_InsensValueVarPointsTo(_, ?ctx, ?var).


Stats_InsensBaseVarPointsTo(?hctx, ?value, ?var) :-
  mainAnalysis.VarPointsTo(?hctx, ?value, _, ?var).

Stats_InsensBaseVarCount(?var, ?n) :-
  Stats_InsensBaseVarPointsTo(_, _, ?var),
  ?n = count : Stats_InsensBaseVarPointsTo(_, _, ?var).


Stats_InsensVarCount(?var, ?n) :-
  Stats_Simple_InsensVarPointsTo(_, ?var),
  ?n = count : Stats_Simple_InsensVarPointsTo(_, ?var).


Stats_Vars(?n) :-
  ?n = count : Stats_VarCount(_, _, _).


Stats_InsensVars(?n) :-
  ?n = count : Stats_InsensVarCount(_, _).
Stats_ArrayCount(?basehctx, ?basevalue, ?n) :-
  mainAnalysis.ArrayIndexPointsTo(_, _, ?basehctx, ?basevalue),
  ?n = count : mainAnalysis.ArrayIndexPointsTo(_, _, ?basehctx, ?basevalue).


Stats_InsensValueArrayIndexPointsTo(?value, ?basehctx, ?basevalue) :-
  mainAnalysis.ArrayIndexPointsTo(_, ?value, ?basehctx, ?basevalue).

Stats_InsensValueArrayCount(?basehctx, ?basevalue, ?n) :-
  Stats_InsensValueArrayIndexPointsTo(_, ?basehctx, ?basevalue),
  ?n = count : Stats_InsensValueArrayIndexPointsTo(_, ?basehctx, ?basevalue).


Stats_InsensBaseValueArrayIndexPointsTo(?hctx, ?value, ?basevalue) :-
  mainAnalysis.ArrayIndexPointsTo(?hctx, ?value, _, ?basevalue).

Stats_InsensBaseValueArrayCount(?basevalue, ?n) :-
  Stats_InsensBaseValueArrayIndexPointsTo(_, _, ?basevalue),
  ?n = count : Stats_InsensBaseValueArrayIndexPointsTo(_, _, ?basevalue).


Stats_InsensArrayCount(?basevalue, ?n) :-
  Stats_Simple_InsensArrayIndexPointsTo(_, ?basevalue),
  ?n = count : Stats_Simple_InsensArrayIndexPointsTo(_, ?basevalue).


Stats_Arrays(?n) :-
  ?n = count : Stats_ArrayCount(_, _, _).


Stats_InsensArrays(?n) :-
  ?n = count : Stats_InsensArrayCount(_, _).
Stats_FieldCount(?sig, ?basehctx, ?basevalue, ?n) :-
  mainAnalysis.InstanceFieldPointsTo(_, _, ?sig, ?basehctx, ?basevalue),
  ?n = count : mainAnalysis.InstanceFieldPointsTo(_, _, ?sig, ?basehctx, ?basevalue).


Stats_InsensValueInstanceFieldPointsTo(?value, ?sig, ?basehctx, ?basevalue) :-
  mainAnalysis.InstanceFieldPointsTo(_, ?value, ?sig, ?basehctx, ?basevalue).

Stats_InsensValueFieldCount(?sig, ?basehctx, ?basevalue, ?n) :-
  Stats_InsensValueInstanceFieldPointsTo(_, ?sig, ?basehctx, ?basevalue),
  ?n = count : Stats_InsensValueInstanceFieldPointsTo(_, ?sig, ?basehctx, ?basevalue).


Stats_InsensBaseValueInstanceFieldPointsTo(?hctx, ?value, ?sig, ?basevalue) :-
  mainAnalysis.InstanceFieldPointsTo(?hctx, ?value, ?sig, _, ?basevalue).

Stats_InsensBaseValueFieldCount(?sig, ?basevalue, ?n) :-
  Stats_InsensBaseValueInstanceFieldPointsTo(_, _, ?sig, ?basevalue),
  ?n = count : Stats_InsensBaseValueInstanceFieldPointsTo(_, _, ?sig, ?basevalue).


Stats_InsensFieldCount(?sig, ?basevalue, ?n) :-
  Stats_Simple_InsensInstanceFieldPointsTo(_, ?sig, ?basevalue),
  ?n = count : Stats_Simple_InsensInstanceFieldPointsTo(_, ?sig, ?basevalue).


Stats_Fields(?n) :-
  ?n = count : Stats_FieldCount(_, _, _, _).


Stats_InsensFields(?n) :-
  ?n = count : Stats_InsensFieldCount(_, _, _).
Stats_MethodContextCount(?method, ?n) :-
  mainAnalysis.ReachableContext(_, ?method),
  ?n = count : mainAnalysis.ReachableContext(_, ?method).

Stats_Methods(?n) :-
  ?n = count : mainAnalysis.Reachable(_).

Method_NumberOfContexts(?method, ?n) :-
  mainAnalysis.Reachable(?method),
  ?n = count : {mainAnalysis.ReachableContext(_, ?method)}.

Method_VPTCountPerMethodVariable(?method, ?var, Y) :-
  Var_DeclaringMethod(?var, ?method),
  Y = count : {mainAnalysis.VarPointsTo(_, _, _, ?var)}.

Method_TotalVPT(?method, Y) :-
  mainAnalysis.Reachable(?method),
  Y = sum ?n : {Method_VPTCountPerMethodVariable(?method, _, ?n)}.

Method_TotalVPT(?method, 0) :-
  mainAnalysis.Reachable(?method),
  !Var_DeclaringMethod(_, ?method).
Stats_InsensValueThrowPointsTo(?value, ?ctx, ?method) :-
  mainAnalysis.ThrowPointsTo(_, ?value, ?ctx, ?method).





Stats_InsensThrowPointsTo(?value, ?method) :-
  Stats_InsensValueThrowPointsTo(?value, _, ?method).
